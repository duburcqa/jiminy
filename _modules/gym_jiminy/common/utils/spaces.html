

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>gym_jiminy.common.utils.spaces &mdash; jiminy 1.8.12 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../../../../_static/css/theme.css?v=e59714d7" />

  
      <script src="../../../../_static/documentation_options.js?v=32cf9813"></script>
      <script src="../../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../../index.html" class="icon icon-home">
            jiminy
              <img src="../../../../_static/jiminy_logo.svg" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">README</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../README.html">Key features</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../README.html#gym-jiminy">Gym Jiminy</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../README.html#demo">Demo</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../README.html#getting-started">Getting started</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">INSTALLATION</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../INSTALL.html">Easy-install on Ubuntu 18+</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../INSTALL.html#building-from-source">Building from source</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">TUTORIALS</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../tutorial.html">An introduction to Jiminy</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">API DOC</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/jiminy/index.html">Jiminy C++ API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/jiminy_py/index.html">Jiminy Python API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/gym_jiminy/common/index.html">Gym Jiminy API</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Technical Specifications</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../spec/src/tlmc_format_specification.html">HDF5 telemetry log format (TLMC)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../spec/pdf/index.html">Downloadable PDF</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../index.html">jiminy</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">gym_jiminy.common.utils.spaces</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for gym_jiminy.common.utils.spaces</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Utilities operating over complex `Gym.Space`s associated with arbitrarily</span>
<span class="sd">nested data structure of `np.ndarray` and heavily optimized for speed.</span>

<span class="sd">They combine static control flow pre-computed for given space and eventually</span>
<span class="sd">some pre-allocated values with Just-In-Time (JIT) compiling via Numba when</span>
<span class="sd">possible for optimal performance.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">partial</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">OrderedDict</span>
<span class="kn">from</span> <span class="nn">collections.abc</span> <span class="kn">import</span> <span class="n">Mapping</span><span class="p">,</span> <span class="n">MutableMapping</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">,</span> <span class="n">MutableSequence</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">Any</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Sequence</span> <span class="k">as</span> <span class="n">SequenceT</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Literal</span><span class="p">,</span>
    <span class="n">Mapping</span> <span class="k">as</span> <span class="n">MappingT</span><span class="p">,</span> <span class="n">SupportsFloat</span><span class="p">,</span> <span class="n">TypeVar</span><span class="p">,</span> <span class="n">Type</span><span class="p">,</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">no_type_check</span><span class="p">,</span>
    <span class="n">overload</span><span class="p">)</span>

<span class="kn">import</span> <span class="nn">numba</span> <span class="k">as</span> <span class="nn">nb</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">typing</span> <span class="k">as</span> <span class="n">npt</span>

<span class="kn">import</span> <span class="nn">gymnasium</span> <span class="k">as</span> <span class="nn">gym</span>

<span class="kn">import</span> <span class="nn">jiminy_py.core</span> <span class="k">as</span> <span class="nn">jiminy</span>
<span class="kn">from</span> <span class="nn">jiminy_py.core</span> <span class="kn">import</span> <span class="p">(</span>  <span class="c1"># pylint: disable=no-name-in-module</span>
    <span class="n">EncoderSensor</span><span class="p">,</span> <span class="n">EffortSensor</span><span class="p">,</span> <span class="n">array_copyto</span><span class="p">,</span> <span class="n">multi_array_copyto</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">jiminy_py</span> <span class="kn">import</span> <span class="n">tree</span>


<span class="n">ValueT</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;ValueT&#39;</span><span class="p">)</span>
<span class="n">ValueInT</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;ValueInT&#39;</span><span class="p">)</span>
<span class="n">ValueOutT</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;ValueOutT&#39;</span><span class="p">)</span>


<span class="n">StructNested</span> <span class="o">=</span> <span class="n">Union</span><span class="p">[</span><span class="n">MappingT</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="s1">&#39;StructNested[ValueT]&#39;</span><span class="p">],</span>
                     <span class="n">SequenceT</span><span class="p">[</span><span class="s1">&#39;StructNested[ValueT]&#39;</span><span class="p">],</span>
                     <span class="n">ValueT</span><span class="p">]</span>
<span class="n">FieldNested</span> <span class="o">=</span> <span class="n">StructNested</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span>
<span class="n">DataNested</span> <span class="o">=</span> <span class="n">StructNested</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span>
<span class="n">DataNestedT</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;DataNestedT&#39;</span><span class="p">,</span> <span class="n">bound</span><span class="o">=</span><span class="n">DataNested</span><span class="p">)</span>

<span class="n">ArrayOrScalar</span> <span class="o">=</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">SupportsFloat</span><span class="p">]</span>


<span class="nd">@no_type_check</span>
<span class="nd">@nb</span><span class="o">.</span><span class="n">jit</span><span class="p">(</span><span class="n">nopython</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">fastmath</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_array_clip</span><span class="p">(</span><span class="n">value</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                <span class="n">low</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ArrayOrScalar</span><span class="p">],</span>
                <span class="n">high</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ArrayOrScalar</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Element-wise out-of-place clipping of array elements.</span>

<span class="sd">    :param value: Array holding values to clip.</span>
<span class="sd">    :param low: Optional lower bound.</span>
<span class="sd">    :param high: Optional upper bound.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Short circuit if there is neither low or high bounds</span>
    <span class="k">if</span> <span class="n">low</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">high</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">value</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="c1"># Generic case.</span>
    <span class="c1"># Note that chaining `np.minimum` with `np.maximum` yields to better</span>
    <span class="c1"># performance than `np.clip` when &#39;fastmath&#39; compilation flag is set.</span>
    <span class="k">if</span> <span class="n">value</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">low</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">high</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">low</span><span class="p">),</span> <span class="n">high</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">low</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">low</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">high</span><span class="p">)</span>

    <span class="c1"># Scalar case.</span>
    <span class="c1"># Strangely, calling &#39;.item()&#39; on Python scalars is supported by Numba.</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">low</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">out</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">low</span><span class="o">.</span><span class="n">item</span><span class="p">())</span>
    <span class="k">if</span> <span class="n">high</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">out</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">high</span><span class="o">.</span><span class="n">item</span><span class="p">())</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>


<span class="nd">@no_type_check</span>
<span class="nd">@nb</span><span class="o">.</span><span class="n">jit</span><span class="p">(</span><span class="n">nopython</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">fastmath</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_array_contains</span><span class="p">(</span><span class="n">value</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                    <span class="n">low</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ArrayOrScalar</span><span class="p">],</span>
                    <span class="n">high</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ArrayOrScalar</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Check that all array elements are withing bounds, up to some tolerance</span>
<span class="sd">    threshold.</span>

<span class="sd">    :param value: Array holding values to check.</span>
<span class="sd">    :param low: Optional lower bound.</span>
<span class="sd">    :param high: Optional upper bound.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">value_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">value_</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span>
        <span class="n">value_1d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">value_</span><span class="p">)</span>
        <span class="c1"># Reversed bound check because &#39;all&#39; is always true for empty arrays</span>
        <span class="k">if</span> <span class="n">low</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="p">(</span><span class="n">low</span> <span class="o">&lt;=</span> <span class="n">value_1d</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">high</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="p">(</span><span class="n">value_1d</span> <span class="o">&lt;=</span> <span class="n">high</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="kc">True</span>
    <span class="k">if</span> <span class="n">low</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="p">(</span><span class="n">low</span><span class="o">.</span><span class="n">item</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">value_</span><span class="o">.</span><span class="n">item</span><span class="p">()):</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="n">high</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="p">(</span><span class="n">value_</span><span class="o">.</span><span class="n">item</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">high</span><span class="o">.</span><span class="n">item</span><span class="p">()):</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="k">return</span> <span class="kc">True</span>


<div class="viewcode-block" id="get_robot_state_space">
<a class="viewcode-back" href="../../../../api/gym_jiminy/common/utils/spaces.html#gym_jiminy.common.utils.spaces.get_robot_state_space">[docs]</a>
<span class="k">def</span> <span class="nf">get_robot_state_space</span><span class="p">(</span><span class="n">robot</span><span class="p">:</span> <span class="n">jiminy</span><span class="o">.</span><span class="n">Robot</span><span class="p">,</span>
                          <span class="n">use_theoretical_model</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                          <span class="n">ignore_velocity_limit</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
                          <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">gym</span><span class="o">.</span><span class="n">spaces</span><span class="o">.</span><span class="n">Dict</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Get the state space associated with a given robot.</span>

<span class="sd">    .. warning:</span>
<span class="sd">        This method is not meant to be overloaded in general since the</span>
<span class="sd">        definition of the state space is mostly consensual. One must rather</span>
<span class="sd">        overload `_initialize_observation_space` to customize the observation</span>
<span class="sd">        space as a whole.</span>

<span class="sd">    :param robot: Jiminy robot to consider.</span>
<span class="sd">    :param use_theoretical_model: Whether to compute the state space associated</span>
<span class="sd">                                  with the theoretical model instead of the</span>
<span class="sd">                                  extended simulation model.</span>
<span class="sd">    :param ignore_velocity_limit: Whether to ignore the velocity bounds</span>
<span class="sd">                                  specified in model.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Define some proxies for convenience</span>
    <span class="n">pinocchio_model</span> <span class="o">=</span> <span class="n">robot</span><span class="o">.</span><span class="n">pinocchio_model</span>
    <span class="n">position_limit_lower</span> <span class="o">=</span> <span class="n">pinocchio_model</span><span class="o">.</span><span class="n">lowerPositionLimit</span>
    <span class="n">position_limit_upper</span> <span class="o">=</span> <span class="n">pinocchio_model</span><span class="o">.</span><span class="n">upperPositionLimit</span>
    <span class="n">velocity_limit</span> <span class="o">=</span> <span class="n">pinocchio_model</span><span class="o">.</span><span class="n">velocityLimit</span>

    <span class="c1"># Deduce bounds associated the theoretical model from the extended one</span>
    <span class="k">if</span> <span class="n">use_theoretical_model</span><span class="p">:</span>
        <span class="n">position_limit_lower</span><span class="p">,</span> <span class="n">position_limit_upper</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span>
            <span class="n">robot</span><span class="o">.</span><span class="n">get_theoretical_position_from_extended</span><span class="p">,</span>
            <span class="p">(</span><span class="n">position_limit_lower</span><span class="p">,</span> <span class="n">position_limit_upper</span><span class="p">))</span>
        <span class="n">velocity_limit</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">robot</span><span class="o">.</span><span class="n">get_theoretical_velocity_from_extended</span><span class="p">(</span><span class="n">velocity_limit</span><span class="p">))</span>

    <span class="c1"># Ignore velocity bounds in requested</span>
    <span class="k">if</span> <span class="n">ignore_velocity_limit</span><span class="p">:</span>
        <span class="n">velocity_limit</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full_like</span><span class="p">(</span><span class="n">velocity_limit</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="s2">&quot;inf&quot;</span><span class="p">))</span>

    <span class="c1"># Aggregate position and velocity bounds to define state space</span>
    <span class="k">return</span> <span class="n">gym</span><span class="o">.</span><span class="n">spaces</span><span class="o">.</span><span class="n">Dict</span><span class="p">(</span>
        <span class="n">q</span><span class="o">=</span><span class="n">gym</span><span class="o">.</span><span class="n">spaces</span><span class="o">.</span><span class="n">Box</span><span class="p">(</span><span class="n">low</span><span class="o">=</span><span class="n">position_limit_lower</span><span class="p">,</span>
                         <span class="n">high</span><span class="o">=</span><span class="n">position_limit_upper</span><span class="p">,</span>
                         <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">),</span>
        <span class="n">v</span><span class="o">=</span><span class="n">gym</span><span class="o">.</span><span class="n">spaces</span><span class="o">.</span><span class="n">Box</span><span class="p">(</span><span class="n">low</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="s2">&quot;-inf&quot;</span><span class="p">),</span>
                         <span class="n">high</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="s2">&quot;inf&quot;</span><span class="p">),</span>
                         <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">robot</span><span class="o">.</span><span class="n">pinocchio_model</span><span class="o">.</span><span class="n">nv</span><span class="p">,),</span>
                         <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">))</span></div>



<div class="viewcode-block" id="get_robot_measurements_space">
<a class="viewcode-back" href="../../../../api/gym_jiminy/common/utils/spaces.html#gym_jiminy.common.utils.spaces.get_robot_measurements_space">[docs]</a>
<span class="k">def</span> <span class="nf">get_robot_measurements_space</span><span class="p">(</span><span class="n">robot</span><span class="p">:</span> <span class="n">jiminy</span><span class="o">.</span><span class="n">Robot</span><span class="p">,</span>
                                 <span class="n">is_finite</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">gym</span><span class="o">.</span><span class="n">spaces</span><span class="o">.</span><span class="n">Dict</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Get the sensor space associated with a given robot.</span>

<span class="sd">    It gathers the sensors data in a dictionary. It maps each available type of</span>
<span class="sd">    sensor to the associated data matrix. Rows correspond to the sensor type&#39;s</span>
<span class="sd">    fields, and columns correspond to each individual sensor.</span>

<span class="sd">    .. note:</span>
<span class="sd">        The mapping between row `i` of data matrix and associated sensor type&#39;s</span>
<span class="sd">        field is given by:</span>

<span class="sd">        .. code-block:: python</span>

<span class="sd">            field = getattr(jiminy_py.core, key).fieldnames[i]</span>

<span class="sd">        The mapping between column `j` of data matrix and associated sensor</span>
<span class="sd">        name and object are given by:</span>

<span class="sd">        .. code-block:: python</span>

<span class="sd">            sensor = env.robot.sensors[key][j]</span>

<span class="sd">    :param robot: Jiminy robot to consider.</span>
<span class="sd">    :param is_finite: Whether to set infer finite bounds from physical</span>
<span class="sd">                      properties of the robot whenever possible. For now, this</span>
<span class="sd">                      only has an effect for encoders (position only) and</span>
<span class="sd">                      effort sensors. In pratice, it may be worth to disable</span>
<span class="sd">                      finite bounds if sensors are flawed (noise and bias),</span>
<span class="sd">                      causing their measurement to be out-of-bounds.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Make sure that the robot is initialized</span>
    <span class="k">assert</span> <span class="n">robot</span><span class="o">.</span><span class="n">is_initialized</span>

    <span class="c1"># Define some proxies for convenience</span>
    <span class="n">position_limit_lower</span> <span class="o">=</span> <span class="n">robot</span><span class="o">.</span><span class="n">pinocchio_model</span><span class="o">.</span><span class="n">lowerPositionLimit</span>
    <span class="n">position_limit_upper</span> <span class="o">=</span> <span class="n">robot</span><span class="o">.</span><span class="n">pinocchio_model</span><span class="o">.</span><span class="n">upperPositionLimit</span>

    <span class="c1"># Initialize the bounds of the sensor space</span>
    <span class="n">sensor_measurements</span> <span class="o">=</span> <span class="n">robot</span><span class="o">.</span><span class="n">sensor_measurements</span>
    <span class="n">sensor_space_lower</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">(</span>
        <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">value</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">sensor_measurements</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
    <span class="n">sensor_space_upper</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">(</span>
        <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">value</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">sensor_measurements</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>

    <span class="c1"># Replace inf bounds of the encoder sensor space</span>
    <span class="k">if</span> <span class="n">is_finite</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">sensor</span> <span class="ow">in</span> <span class="n">robot</span><span class="o">.</span><span class="n">sensors</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">EncoderSensor</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="p">()):</span>
            <span class="c1"># Get the position bounds of the sensor.</span>
            <span class="c1"># Note that for rotary unbounded encoders, the sensor bounds cannot</span>
            <span class="c1"># be extracted from the motor because only the principal value of</span>
            <span class="c1"># the angle is observed by the sensor.</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sensor</span><span class="p">,</span> <span class="n">EncoderSensor</span><span class="p">)</span>
            <span class="n">joint</span> <span class="o">=</span> <span class="n">robot</span><span class="o">.</span><span class="n">pinocchio_model</span><span class="o">.</span><span class="n">joints</span><span class="p">[</span><span class="n">sensor</span><span class="o">.</span><span class="n">joint_index</span><span class="p">]</span>
            <span class="n">joint_type</span> <span class="o">=</span> <span class="n">jiminy</span><span class="o">.</span><span class="n">get_joint_type</span><span class="p">(</span><span class="n">joint</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">joint_type</span> <span class="o">==</span> <span class="n">jiminy</span><span class="o">.</span><span class="n">JointModelType</span><span class="o">.</span><span class="n">ROTARY_UNBOUNDED</span><span class="p">:</span>
                <span class="n">sensor_position_lower</span> <span class="o">=</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
                <span class="n">sensor_position_upper</span> <span class="o">=</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">motor</span> <span class="o">=</span> <span class="n">robot</span><span class="o">.</span><span class="n">motors</span><span class="p">[</span><span class="n">sensor</span><span class="o">.</span><span class="n">motor_index</span><span class="p">]</span>
                    <span class="n">sensor_position_lower</span> <span class="o">=</span> <span class="n">motor</span><span class="o">.</span><span class="n">position_limit_lower</span>
                    <span class="n">sensor_position_upper</span> <span class="o">=</span> <span class="n">motor</span><span class="o">.</span><span class="n">position_limit_upper</span>
                <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
                    <span class="n">sensor_position_lower</span> <span class="o">=</span> <span class="n">position_limit_lower</span><span class="p">[</span><span class="n">joint</span><span class="o">.</span><span class="n">idx_q</span><span class="p">]</span>
                    <span class="n">sensor_position_upper</span> <span class="o">=</span> <span class="n">position_limit_upper</span><span class="p">[</span><span class="n">joint</span><span class="o">.</span><span class="n">idx_q</span><span class="p">]</span>

            <span class="c1"># Update the bounds accordingly</span>
            <span class="n">sensor_space_lower</span><span class="p">[</span><span class="n">EncoderSensor</span><span class="o">.</span><span class="n">type</span><span class="p">][</span><span class="mi">0</span><span class="p">,</span> <span class="n">sensor</span><span class="o">.</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">sensor_position_lower</span><span class="p">)</span>
            <span class="n">sensor_space_upper</span><span class="p">[</span><span class="n">EncoderSensor</span><span class="o">.</span><span class="n">type</span><span class="p">][</span><span class="mi">0</span><span class="p">,</span> <span class="n">sensor</span><span class="o">.</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">sensor_position_upper</span><span class="p">)</span>

        <span class="c1"># Replace inf bounds of the effort sensor space</span>
        <span class="k">for</span> <span class="n">sensor</span> <span class="ow">in</span> <span class="n">robot</span><span class="o">.</span><span class="n">sensors</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">EffortSensor</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="p">()):</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sensor</span><span class="p">,</span> <span class="n">EffortSensor</span><span class="p">)</span>
            <span class="n">motor</span> <span class="o">=</span> <span class="n">robot</span><span class="o">.</span><span class="n">motors</span><span class="p">[</span><span class="n">sensor</span><span class="o">.</span><span class="n">motor_index</span><span class="p">]</span>
            <span class="n">sensor_space_lower</span><span class="p">[</span><span class="n">EffortSensor</span><span class="o">.</span><span class="n">type</span><span class="p">][</span><span class="mi">0</span><span class="p">,</span> <span class="n">sensor</span><span class="o">.</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="o">-</span> <span class="n">motor</span><span class="o">.</span><span class="n">effort_limit</span><span class="p">)</span>
            <span class="n">sensor_space_upper</span><span class="p">[</span><span class="n">EffortSensor</span><span class="o">.</span><span class="n">type</span><span class="p">][</span><span class="mi">0</span><span class="p">,</span> <span class="n">sensor</span><span class="o">.</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">motor</span><span class="o">.</span><span class="n">effort_limit</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">gym</span><span class="o">.</span><span class="n">spaces</span><span class="o">.</span><span class="n">Dict</span><span class="p">([</span>
        <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">gym</span><span class="o">.</span><span class="n">spaces</span><span class="o">.</span><span class="n">Box</span><span class="p">(</span><span class="n">low</span><span class="o">=</span><span class="n">min_val</span><span class="p">,</span> <span class="n">high</span><span class="o">=</span><span class="n">max_val</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">))</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">min_val</span><span class="p">),</span> <span class="n">max_val</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
            <span class="n">sensor_space_lower</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span> <span class="n">sensor_space_upper</span><span class="o">.</span><span class="n">values</span><span class="p">())])</span></div>



<div class="viewcode-block" id="get_bounds">
<a class="viewcode-back" href="../../../../api/gym_jiminy/common/utils/spaces.html#gym_jiminy.common.utils.spaces.get_bounds">[docs]</a>
<span class="k">def</span> <span class="nf">get_bounds</span><span class="p">(</span><span class="n">space</span><span class="p">:</span> <span class="n">gym</span><span class="o">.</span><span class="n">Space</span><span class="p">,</span>
               <span class="n">tol_abs</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
               <span class="n">tol_rel</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
               <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="n">ArrayOrScalar</span><span class="p">],</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ArrayOrScalar</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Get the lower and upper bounds of a given &#39;gym.Space&#39; if any.</span>

<span class="sd">    :param space: `gym.Space` on which to operate.</span>
<span class="sd">    :param tol_abs: Absolute tolerance.</span>
<span class="sd">                    Optional: 0.0 by default</span>
<span class="sd">    :param tol_rel: Relative tolerance. It will be ignored if either the lower</span>
<span class="sd">                    or upper is not specified.</span>
<span class="sd">                    Optional: 0.0 by default.</span>

<span class="sd">    :returns: Lower and upper bounds as a tuple.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Extract lower and upper bounds depending on the gym space</span>
    <span class="n">dtype</span><span class="p">:</span> <span class="n">npt</span><span class="o">.</span><span class="n">DTypeLike</span>
    <span class="n">low</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ArrayOrScalar</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">high</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ArrayOrScalar</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">space</span><span class="p">,</span> <span class="n">gym</span><span class="o">.</span><span class="n">spaces</span><span class="o">.</span><span class="n">Box</span><span class="p">):</span>
        <span class="n">low</span><span class="p">,</span> <span class="n">high</span> <span class="o">=</span> <span class="n">space</span><span class="o">.</span><span class="n">low</span><span class="p">,</span> <span class="n">space</span><span class="o">.</span><span class="n">high</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="n">low</span><span class="o">.</span><span class="n">dtype</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">space</span><span class="p">,</span> <span class="n">gym</span><span class="o">.</span><span class="n">spaces</span><span class="o">.</span><span class="n">Discrete</span><span class="p">):</span>
        <span class="n">low</span><span class="p">,</span> <span class="n">high</span> <span class="o">=</span> <span class="n">space</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">space</span><span class="o">.</span><span class="n">n</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">space</span><span class="p">,</span> <span class="n">gym</span><span class="o">.</span><span class="n">spaces</span><span class="o">.</span><span class="n">MultiDiscrete</span><span class="p">):</span>
        <span class="n">low</span><span class="p">,</span> <span class="n">high</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">space</span><span class="o">.</span><span class="n">nvec</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>

    <span class="c1"># Take into account the absolute and relative tolerances</span>
    <span class="c1"># assert tol_abs &gt;= 0.0 and tol_rel &gt;= 0.0</span>
    <span class="k">if</span> <span class="n">tol_abs</span> <span class="ow">or</span> <span class="n">tol_rel</span> <span class="ow">and</span> <span class="p">(</span><span class="n">low</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">high</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
        <span class="n">tol_abs_nd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full_like</span><span class="p">(</span><span class="n">low</span><span class="p">,</span> <span class="n">tol_abs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">tol_rel</span> <span class="ow">and</span> <span class="n">low</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">high</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">tol_abs_nd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span>
                <span class="p">(</span><span class="n">high</span> <span class="o">-</span> <span class="n">low</span><span class="p">)</span> <span class="o">*</span> <span class="n">tol_rel</span><span class="p">,</span> <span class="n">tol_abs_nd</span><span class="p">)</span>  <span class="c1"># type: ignore[operator]</span>
        <span class="k">if</span> <span class="n">low</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">low</span> <span class="o">=</span> <span class="p">(</span><span class="n">low</span> <span class="o">-</span> <span class="n">tol_abs_nd</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">high</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">high</span> <span class="o">=</span> <span class="p">(</span><span class="n">high</span> <span class="o">+</span> <span class="n">tol_abs_nd</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">low</span><span class="p">,</span> <span class="n">high</span></div>



<div class="viewcode-block" id="zeros">
<a class="viewcode-back" href="../../../../api/gym_jiminy/common/utils/spaces.html#gym_jiminy.common.utils.spaces.zeros">[docs]</a>
<span class="nd">@no_type_check</span>
<span class="k">def</span> <span class="nf">zeros</span><span class="p">(</span><span class="n">space</span><span class="p">:</span> <span class="n">gym</span><span class="o">.</span><span class="n">Space</span><span class="p">[</span><span class="n">DataNestedT</span><span class="p">],</span>
          <span class="n">dtype</span><span class="p">:</span> <span class="n">npt</span><span class="o">.</span><span class="n">DTypeLike</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
          <span class="n">enforce_bounds</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataNestedT</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Allocate data structure from `gym.Space` and initialize it to zero.</span>

<span class="sd">    :param space: `gym.Space` on which to operate.</span>
<span class="sd">    :param dtype: Can be specified to overwrite original space dtype.</span>
<span class="sd">                  Optional: None by default</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Note that it is not possible to take advantage of `jiminy_py.tree`</span>
    <span class="c1"># because the output type for collections (OrderedDict or Tuple) is not the</span>
    <span class="c1"># same as the input one (gym.Space).</span>
    <span class="n">value</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">space</span><span class="p">,</span> <span class="n">gym</span><span class="o">.</span><span class="n">spaces</span><span class="o">.</span><span class="n">Dict</span><span class="p">):</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">field</span><span class="p">,</span> <span class="n">subspace</span> <span class="ow">in</span> <span class="n">space</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">value</span><span class="p">[</span><span class="n">field</span><span class="p">]</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">subspace</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">value</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">space</span><span class="p">,</span> <span class="n">gym</span><span class="o">.</span><span class="n">spaces</span><span class="o">.</span><span class="n">Tuple</span><span class="p">):</span>
        <span class="n">value</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">zeros</span><span class="p">(</span><span class="n">subspace</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span> <span class="k">for</span> <span class="n">subspace</span> <span class="ow">in</span> <span class="n">space</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">space</span><span class="p">,</span> <span class="n">gym</span><span class="o">.</span><span class="n">spaces</span><span class="o">.</span><span class="n">Box</span><span class="p">):</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">space</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span> <span class="ow">or</span> <span class="n">space</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">space</span><span class="p">,</span> <span class="n">gym</span><span class="o">.</span><span class="n">spaces</span><span class="o">.</span><span class="n">Discrete</span><span class="p">):</span>
        <span class="c1"># Note that np.array of 0 dim is returned in order to be mutable</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">space</span><span class="p">,</span> <span class="n">gym</span><span class="o">.</span><span class="n">spaces</span><span class="o">.</span><span class="n">MultiDiscrete</span><span class="p">):</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">space</span><span class="o">.</span><span class="n">nvec</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">space</span><span class="p">,</span> <span class="n">gym</span><span class="o">.</span><span class="n">spaces</span><span class="o">.</span><span class="n">MultiBinary</span><span class="p">):</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">space</span><span class="o">.</span><span class="n">n</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">enforce_bounds</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">clip</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">space</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">value</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">space</span><span class="p">,</span> <span class="n">gym</span><span class="o">.</span><span class="n">Space</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;All spaces must derived from `gym.Space`, including tuple and &quot;</span>
            <span class="s2">&quot;dict containers.&quot;</span><span class="p">)</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
        <span class="sa">f</span><span class="s2">&quot;Space of type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">space</span><span class="p">)</span><span class="si">}</span><span class="s2"> is not supported.&quot;</span><span class="p">)</span></div>



<div class="viewcode-block" id="fill">
<a class="viewcode-back" href="../../../../api/gym_jiminy/common/utils/spaces.html#gym_jiminy.common.utils.spaces.fill">[docs]</a>
<span class="k">def</span> <span class="nf">fill</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="n">DataNested</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">number</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Set every element of &#39;data&#39; from `gym.Space` to scalar &#39;fill_value&#39;.</span>

<span class="sd">    :param data: Data structure to update.</span>
<span class="sd">    :param fill_value: Value used to fill any scalar from the leaves.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">value</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="n">fill_value</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">AttributeError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Leaves of &#39;data&#39; structure must have type `np.ndarray`.&quot;</span>
                <span class="p">)</span> <span class="kn">from</span> <span class="nn">e</span></div>



<div class="viewcode-block" id="copyto">
<a class="viewcode-back" href="../../../../api/gym_jiminy/common/utils/spaces.html#gym_jiminy.common.utils.spaces.copyto">[docs]</a>
<span class="k">def</span> <span class="nf">copyto</span><span class="p">(</span><span class="n">dst</span><span class="p">:</span> <span class="n">DataNested</span><span class="p">,</span> <span class="n">src</span><span class="p">:</span> <span class="n">DataNested</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Copy arbitrarily nested data structure of &#39;np.ndarray&#39; to a given</span>
<span class="sd">    pre-allocated destination.</span>

<span class="sd">    It avoids memory allocation completely, so that memory pointers of &#39;data&#39;</span>
<span class="sd">    remains unchanged. As direct consequences, it is necessary to preallocate</span>
<span class="sd">    memory beforehand, and it only supports arrays of fixed shape.</span>

<span class="sd">    .. note::</span>
<span class="sd">        Unlike the function returned by &#39;build_copyto&#39;, only the flattened data</span>
<span class="sd">        structure needs to match, not the original one. This means that the</span>
<span class="sd">        source and/or destination can be flattened already when provided.</span>
<span class="sd">        Beware values must be sorted by keys in case of nested dict.</span>

<span class="sd">    :param dst: Hierarchical data structure to update, possibly flattened.</span>
<span class="sd">    :param value: Hierarchical data to copy, possibly flattened.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">multi_array_copyto</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">dst</span><span class="p">),</span> <span class="n">tree</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">src</span><span class="p">))</span></div>



<span class="nd">@overload</span>
<span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="n">DataNestedT</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataNestedT</span><span class="p">:</span>
    <span class="o">...</span>


<span class="nd">@overload</span>
<span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="n">gym</span><span class="o">.</span><span class="n">Space</span><span class="p">[</span><span class="n">DataNestedT</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">gym</span><span class="o">.</span><span class="n">Space</span><span class="p">[</span><span class="n">DataNestedT</span><span class="p">]:</span>
    <span class="o">...</span>


<div class="viewcode-block" id="copy">
<a class="viewcode-back" href="../../../../api/gym_jiminy/common/utils/spaces.html#gym_jiminy.common.utils.spaces.copy">[docs]</a>
<span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">DataNestedT</span><span class="p">,</span> <span class="n">gym</span><span class="o">.</span><span class="n">Space</span><span class="p">[</span><span class="n">DataNestedT</span><span class="p">]]</span>
         <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">DataNestedT</span><span class="p">,</span> <span class="n">gym</span><span class="o">.</span><span class="n">Space</span><span class="p">[</span><span class="n">DataNestedT</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Shallow copy recursively &#39;data&#39; from `gym.Space`, so that only leaves</span>
<span class="sd">    are still references.</span>

<span class="sd">    :param data: Hierarchical data structure to copy without allocation.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">tree</span><span class="o">.</span><span class="n">unflatten_as</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">tree</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">data</span><span class="p">))</span></div>



<div class="viewcode-block" id="clip">
<a class="viewcode-back" href="../../../../api/gym_jiminy/common/utils/spaces.html#gym_jiminy.common.utils.spaces.clip">[docs]</a>
<span class="nd">@no_type_check</span>
<span class="k">def</span> <span class="nf">clip</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="n">DataNested</span><span class="p">,</span> <span class="n">space</span><span class="p">:</span> <span class="n">gym</span><span class="o">.</span><span class="n">Space</span><span class="p">[</span><span class="n">DataNested</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">DataNested</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Clip data from `gym.Space` to make sure it is within bounds.</span>

<span class="sd">    .. note:</span>
<span class="sd">        None of the leaves of the returned data structured is sharing memory</span>
<span class="sd">        with the original one, even if clipping had no effect. This alleviate</span>
<span class="sd">        the need of calling &#39;deepcopy&#39; afterward.</span>

<span class="sd">    :param data: Data to clip.</span>
<span class="sd">    :param space: `gym.Space` on which to operate.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">data_type</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">tree</span><span class="o">.</span><span class="n">issubclass_mapping</span><span class="p">(</span><span class="n">data_type</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">data_type</span><span class="p">({</span>
            <span class="n">field</span><span class="p">:</span> <span class="n">clip</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">field</span><span class="p">],</span> <span class="n">subspace</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">field</span><span class="p">,</span> <span class="n">subspace</span> <span class="ow">in</span> <span class="n">space</span><span class="o">.</span><span class="n">items</span><span class="p">()})</span>
    <span class="k">if</span> <span class="n">tree</span><span class="o">.</span><span class="n">issubclass_sequence</span><span class="p">(</span><span class="n">data_type</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">data_type</span><span class="p">([</span>
            <span class="n">clip</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">subspace</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">subspace</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">space</span><span class="p">)])</span>
    <span class="k">return</span> <span class="n">_array_clip</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="o">*</span><span class="n">get_bounds</span><span class="p">(</span><span class="n">space</span><span class="p">))</span></div>



<div class="viewcode-block" id="contains">
<a class="viewcode-back" href="../../../../api/gym_jiminy/common/utils/spaces.html#gym_jiminy.common.utils.spaces.contains">[docs]</a>
<span class="nd">@no_type_check</span>
<span class="k">def</span> <span class="nf">contains</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="n">DataNested</span><span class="p">,</span>
             <span class="n">space</span><span class="p">:</span> <span class="n">gym</span><span class="o">.</span><span class="n">Space</span><span class="p">[</span><span class="n">DataNested</span><span class="p">],</span>
             <span class="n">tol_abs</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
             <span class="n">tol_rel</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Check if all leaves of a nested data structure are within bounds of</span>
<span class="sd">    their respective `gym.Space`, up to some tolerance threshold. If both</span>
<span class="sd">    absolute and relative tolerances are provided, then satisfying only one of</span>
<span class="sd">    the two criteria is considered sufficient.</span>

<span class="sd">    By design, it is always `True` for all spaces but `gym.spaces.Box`,</span>
<span class="sd">    `gym.spaces.Discrete` and `gym.spaces.MultiDiscrete`.</span>

<span class="sd">    :param data: Data structure to check.</span>
<span class="sd">    :param space: `gym.Space` on which to operate.</span>
<span class="sd">    :param tol_abs: Absolute tolerance.</span>
<span class="sd">    :param tol_rel: Relative tolerance.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">data_type</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">tree</span><span class="o">.</span><span class="n">issubclass_mapping</span><span class="p">(</span><span class="n">data_type</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">all</span><span class="p">(</span><span class="n">contains</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">field</span><span class="p">],</span> <span class="n">subspace</span><span class="p">,</span> <span class="n">tol_abs</span><span class="p">,</span> <span class="n">tol_rel</span><span class="p">)</span>
                   <span class="k">for</span> <span class="n">field</span><span class="p">,</span> <span class="n">subspace</span> <span class="ow">in</span> <span class="n">space</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
    <span class="k">if</span> <span class="n">tree</span><span class="o">.</span><span class="n">issubclass_sequence</span><span class="p">(</span><span class="n">data_type</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">all</span><span class="p">(</span><span class="n">contains</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">subspace</span><span class="p">,</span> <span class="n">tol_abs</span><span class="p">,</span> <span class="n">tol_rel</span><span class="p">)</span>
                   <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">subspace</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">space</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">_array_contains</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="o">*</span><span class="n">get_bounds</span><span class="p">(</span><span class="n">space</span><span class="p">,</span> <span class="n">tol_abs</span><span class="p">,</span> <span class="n">tol_rel</span><span class="p">))</span></div>



<div class="viewcode-block" id="build_reduce">
<a class="viewcode-back" href="../../../../api/gym_jiminy/common/utils/spaces.html#gym_jiminy.common.utils.spaces.build_reduce">[docs]</a>
<span class="nd">@no_type_check</span>
<span class="k">def</span> <span class="nf">build_reduce</span><span class="p">(</span><span class="n">fn</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">ValueInT</span><span class="p">],</span>
                 <span class="n">op</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Callable</span><span class="p">[[</span><span class="n">ValueOutT</span><span class="p">,</span> <span class="n">ValueInT</span><span class="p">],</span> <span class="n">ValueOutT</span><span class="p">]],</span>
                 <span class="n">dataset</span><span class="p">:</span> <span class="n">SequenceT</span><span class="p">[</span><span class="n">DataNested</span><span class="p">],</span>
                 <span class="n">space</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">gym</span><span class="o">.</span><span class="n">Space</span><span class="p">[</span><span class="n">DataNested</span><span class="p">]],</span>
                 <span class="n">arity</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Literal</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]],</span>
                 <span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span>
                 <span class="n">initializer</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Callable</span><span class="p">[[],</span> <span class="n">ValueOutT</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">forward_bounds</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                 <span class="n">tol_abs</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
                 <span class="n">tol_rel</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">ValueOutT</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Generate specialized callable applying transform and reduction on all</span>
<span class="sd">    leaves of given nested space.</span>

<span class="sd">    .. note::</span>
<span class="sd">        Original ordering of the leaves is preserved. More precisely, both</span>
<span class="sd">        transform and reduction will be applied recursively in keys order.</span>

<span class="sd">    .. warning::</span>
<span class="sd">        It is assumed without checking that all nested data structures are</span>
<span class="sd">        consistent together and with the space if provided. It holds true both</span>
<span class="sd">        data known at generation-time or runtime. It is only required for data</span>
<span class="sd">        that may be provided at runtime to include the original data structure,</span>
<span class="sd">        so it may contain additional branches which will be ignored.</span>

<span class="sd">    .. warning::</span>
<span class="sd">        Providing additional data at runtime is supported but impede</span>
<span class="sd">        performance. Arity larger than 1 is not supported because the code path</span>
<span class="sd">        could not be fully specialized, causing dramatic slowdown.</span>

<span class="sd">    .. warning::</span>
<span class="sd">        There is no built-in &#39;short-circuit&#39; mechanism, which means that it</span>
<span class="sd">        will go through all leaves systematically unless the reduction operator</span>
<span class="sd">        itself raises an exception.</span>

<span class="sd">    :param fn: Transform applied to every leaves of the nested data structures</span>
<span class="sd">               before performing the actual reduction. This function can</span>
<span class="sd">               perform in-place or out-of-place operations without restriction.</span>
<span class="sd">               `None` is not supported because it would be irrelevant. Note</span>
<span class="sd">               that if tracking the hierarchy during reduction is not</span>
<span class="sd">               necessary, then it would be way more efficient to first flatten</span>
<span class="sd">               the pre-allocated nested data structure once for all, and then</span>
<span class="sd">               perform reduction on this flattened view using the standard</span>
<span class="sd">               &#39;functools.reduce&#39; method. Still, flattening at runtime using</span>
<span class="sd">               &#39;flatten&#39; would still much slower than a specialized nested</span>
<span class="sd">               reduction.</span>
<span class="sd">    :param op: Optional reduction operator applied cumulatively on all leaves</span>
<span class="sd">               after transform. See &#39;functools.reduce&#39; documentation for</span>
<span class="sd">               details. `None` to only apply transform on all leaves without</span>
<span class="sd">               reduction. This is useful when apply in-place transform.</span>
<span class="sd">    :param dataset: Pre-allocated nested data structure. Optional if the space</span>
<span class="sd">                    is provided.</span>
<span class="sd">    :param space: Container space on which to operate (eg `gym.spaces.Dict` or</span>
<span class="sd">                  `gym.spaces.Tuple`). Optional iif the nested data structure</span>
<span class="sd">                  is provided.</span>
<span class="sd">    :param arity: Arity of the generated callable. `None` to indicate that it</span>
<span class="sd">                  must be determined at runtime, which is slower. Either way,</span>
<span class="sd">                  only 0 or 1 arity is supported for now.</span>
<span class="sd">    :param args: Extra arguments to systematically forward as transform input</span>
<span class="sd">                 for all leaves. Note that, as for Python built-ins methods,</span>
<span class="sd">                 keywords are not supported for the sake of efficiency.</span>
<span class="sd">    :param initializer: Function used to compute the initial value before</span>
<span class="sd">                        starting reduction. Optional if the reduction operator</span>
<span class="sd">                        has same input and output types. If `None`, then the</span>
<span class="sd">                        value corresponding to the first leaf after transform</span>
<span class="sd">                        will be used instead.</span>
<span class="sd">    :param forward_bounds: Whether to forward the lower and upper bounds of the</span>
<span class="sd">                           `gym.Space` associated with each leaf as transform</span>
<span class="sd">                           input. In this case, they will be added after the</span>
<span class="sd">                           data structure provided at runtime but before other</span>
<span class="sd">                           extra arguments if any. It is up to the user to make</span>
<span class="sd">                           sure all leaves have bounds, otherwise it will raise</span>
<span class="sd">                           an exception at generation-time. This argument is</span>
<span class="sd">                           ignored if not space is specified.</span>
<span class="sd">    :param tol_abs: Absolute tolerance added to the lower and upper bounds of</span>
<span class="sd">                    the `gym.Space` associated with each leaf.</span>
<span class="sd">                    Optional: 0.0 by default.</span>
<span class="sd">    :param tol_rel: Relative tolerance added to the lower and upper bounds of</span>
<span class="sd">                    the `gym.Space` associated with each leaf.</span>
<span class="sd">                    Optional: 0.0 by default.</span>

<span class="sd">    :returns: Fully-specialized reduction callable.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># pylint: disable=unused-argument</span>

    <span class="k">def</span> <span class="nf">_build_reduce</span><span class="p">(</span>
            <span class="n">arity</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
            <span class="n">is_initialized</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
            <span class="n">fn_1</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">ValueInT</span><span class="p">],</span> <span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">ValueOutT</span><span class="p">]],</span>
            <span class="n">field_1</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span>
            <span class="n">fn_2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">ValueInT</span><span class="p">],</span> <span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">ValueOutT</span><span class="p">]],</span>
            <span class="n">field_2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span>
            <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">ValueOutT</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Internal method generating a specialized callable performing a</span>
<span class="sd">        single reduction operation on either leaf transform and/or already</span>
<span class="sd">        branch reduction.</span>

<span class="sd">        :param arity: Arity of the generated callable.</span>
<span class="sd">        :param is_initialized: Whether the output has already been initialized</span>
<span class="sd">                               at this point. The first reduction is the only</span>
<span class="sd">                               one to initialize the output, either by calling</span>
<span class="sd">                               the initializer if provided or passing directly</span>
<span class="sd">                               the output of first transform call otherwise.</span>
<span class="sd">        :param fn_1: Leaf transform or branch reduction to call last.</span>
<span class="sd">        :param field_1: Pass the value corresponding this key as input argument</span>
<span class="sd">                        for nested data structure provided at runtime if any</span>
<span class="sd">                        iif callable &#39;fn_1&#39; is a leaf transform.</span>
<span class="sd">        :param is_out_1: Whether callable &#39;fn_1&#39; is already a branch reduction.</span>
<span class="sd">        :param fn_2: Leaf transform or branch reduction to call first.</span>
<span class="sd">        :param field_2: Same as &#39;field_1&#39; for callable &#39;fn_2&#39;.</span>
<span class="sd">        :param is_out_2: Same as &#39;is_out_1&#39; for callable &#39;fn_2&#39;.</span>

<span class="sd">        :returns: Specialized branch reduction callable requiring passing the</span>
<span class="sd">                  current reduction output as input if some reduction operator</span>
<span class="sd">                  has been specified.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Extract extra arguments from functor if necessary to preserve order</span>
        <span class="n">has_args</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">is_out_1</span><span class="p">,</span> <span class="n">is_out_2</span> <span class="o">=</span> <span class="n">fn_1</span><span class="o">.</span><span class="n">func</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">fn</span><span class="p">,</span> <span class="n">fn_2</span><span class="o">.</span><span class="n">func</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">fn</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_out_1</span><span class="p">:</span>
            <span class="n">fn_1</span><span class="p">,</span> <span class="n">dataset</span><span class="p">,</span> <span class="n">args_1</span> <span class="o">=</span> <span class="n">fn_1</span><span class="o">.</span><span class="n">func</span><span class="p">,</span> <span class="n">fn_1</span><span class="o">.</span><span class="n">args</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">fn_1</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">has_args</span> <span class="o">|=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">args_1</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">arity</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">fn_1</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">fn_1</span><span class="p">,</span> <span class="o">*</span><span class="n">dataset</span><span class="p">,</span> <span class="o">*</span><span class="n">args_1</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">dataset</span><span class="p">:</span>
                <span class="n">fn_1</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">fn_1</span><span class="p">,</span> <span class="o">*</span><span class="n">dataset</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_out_2</span><span class="p">:</span>
            <span class="n">fn_2</span><span class="p">,</span> <span class="n">dataset</span><span class="p">,</span> <span class="n">args_2</span> <span class="o">=</span> <span class="n">fn_2</span><span class="o">.</span><span class="n">func</span><span class="p">,</span> <span class="n">fn_2</span><span class="o">.</span><span class="n">args</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">fn_2</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">has_args</span> <span class="o">|=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">args_2</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">arity</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">fn_2</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">fn_2</span><span class="p">,</span> <span class="o">*</span><span class="n">dataset</span><span class="p">,</span> <span class="o">*</span><span class="n">args_2</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">dataset</span><span class="p">:</span>
                <span class="n">fn_2</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">fn_2</span><span class="p">,</span> <span class="o">*</span><span class="n">dataset</span><span class="p">)</span>

        <span class="c1"># Specialization if no op is specified</span>
        <span class="k">if</span> <span class="n">op</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">arity</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">def</span> <span class="nf">_reduce</span><span class="p">(</span><span class="n">fn_1</span><span class="p">,</span> <span class="n">fn_2</span><span class="p">):</span>
                    <span class="n">fn_2</span><span class="p">()</span>
                    <span class="n">fn_1</span><span class="p">()</span>
                <span class="k">return</span> <span class="n">partial</span><span class="p">(</span><span class="n">_reduce</span><span class="p">,</span> <span class="n">fn_1</span><span class="p">,</span> <span class="n">fn_2</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">is_out_1</span> <span class="ow">and</span> <span class="n">is_out_2</span><span class="p">:</span>
                <span class="k">def</span> <span class="nf">_reduce</span><span class="p">(</span><span class="n">fn_1</span><span class="p">,</span> <span class="n">fn_2</span><span class="p">,</span> <span class="n">delayed</span><span class="p">):</span>
                    <span class="n">fn_2</span><span class="p">(</span><span class="n">delayed</span><span class="p">)</span>
                    <span class="n">fn_1</span><span class="p">(</span><span class="n">delayed</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">partial</span><span class="p">(</span><span class="n">_reduce</span><span class="p">,</span> <span class="n">fn_1</span><span class="p">,</span> <span class="n">fn_2</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">is_out_1</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">is_out_2</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">has_args</span><span class="p">:</span>
                    <span class="k">def</span> <span class="nf">_reduce</span><span class="p">(</span><span class="n">fn_1</span><span class="p">,</span> <span class="n">fn_2</span><span class="p">,</span> <span class="n">field_2</span><span class="p">,</span> <span class="n">args_2</span><span class="p">,</span> <span class="n">delayed</span><span class="p">):</span>
                        <span class="n">fn_2</span><span class="p">(</span><span class="n">delayed</span><span class="p">[</span><span class="n">field_2</span><span class="p">],</span> <span class="o">*</span><span class="n">args_2</span><span class="p">)</span>
                        <span class="n">fn_1</span><span class="p">(</span><span class="n">delayed</span><span class="p">)</span>
                    <span class="k">return</span> <span class="n">partial</span><span class="p">(</span><span class="n">_reduce</span><span class="p">,</span> <span class="n">fn_1</span><span class="p">,</span> <span class="n">fn_2</span><span class="p">,</span> <span class="n">field_2</span><span class="p">,</span> <span class="n">args_2</span><span class="p">)</span>

                <span class="k">def</span> <span class="nf">_reduce</span><span class="p">(</span><span class="n">fn_1</span><span class="p">,</span> <span class="n">fn_2</span><span class="p">,</span> <span class="n">field_2</span><span class="p">,</span> <span class="n">delayed</span><span class="p">):</span>
                    <span class="n">fn_2</span><span class="p">(</span><span class="n">delayed</span><span class="p">[</span><span class="n">field_2</span><span class="p">])</span>
                    <span class="n">fn_1</span><span class="p">(</span><span class="n">delayed</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">partial</span><span class="p">(</span><span class="n">_reduce</span><span class="p">,</span> <span class="n">fn_1</span><span class="p">,</span> <span class="n">fn_2</span><span class="p">,</span> <span class="n">field_2</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">is_out_1</span> <span class="ow">and</span> <span class="n">is_out_2</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">has_args</span><span class="p">:</span>
                    <span class="k">def</span> <span class="nf">_reduce</span><span class="p">(</span><span class="n">fn_1</span><span class="p">,</span> <span class="n">field_1</span><span class="p">,</span> <span class="n">args_1</span><span class="p">,</span> <span class="n">fn_2</span><span class="p">,</span> <span class="n">delayed</span><span class="p">):</span>
                        <span class="n">fn_2</span><span class="p">(</span><span class="n">delayed</span><span class="p">)</span>
                        <span class="n">fn_1</span><span class="p">(</span><span class="n">delayed</span><span class="p">[</span><span class="n">field_1</span><span class="p">],</span> <span class="o">*</span><span class="n">args_1</span><span class="p">)</span>
                    <span class="k">return</span> <span class="n">partial</span><span class="p">(</span><span class="n">_reduce</span><span class="p">,</span> <span class="n">fn_1</span><span class="p">,</span> <span class="n">field_1</span><span class="p">,</span> <span class="n">args_1</span><span class="p">,</span> <span class="n">fn_2</span><span class="p">)</span>

                <span class="k">def</span> <span class="nf">_reduce</span><span class="p">(</span><span class="n">fn_1</span><span class="p">,</span> <span class="n">field_1</span><span class="p">,</span> <span class="n">fn_2</span><span class="p">,</span> <span class="n">delayed</span><span class="p">):</span>
                    <span class="n">fn_2</span><span class="p">(</span><span class="n">delayed</span><span class="p">)</span>
                    <span class="n">fn_1</span><span class="p">(</span><span class="n">delayed</span><span class="p">[</span><span class="n">field_1</span><span class="p">])</span>
                <span class="k">return</span> <span class="n">partial</span><span class="p">(</span><span class="n">_reduce</span><span class="p">,</span> <span class="n">fn_1</span><span class="p">,</span> <span class="n">field_1</span><span class="p">,</span> <span class="n">fn_2</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">has_args</span><span class="p">:</span>
                <span class="k">def</span> <span class="nf">_reduce</span><span class="p">(</span>
                        <span class="n">fn_1</span><span class="p">,</span> <span class="n">field_1</span><span class="p">,</span> <span class="n">args_1</span><span class="p">,</span> <span class="n">fn_2</span><span class="p">,</span> <span class="n">field_2</span><span class="p">,</span> <span class="n">args_2</span><span class="p">,</span> <span class="n">delayed</span><span class="p">):</span>
                    <span class="n">fn_2</span><span class="p">(</span><span class="n">delayed</span><span class="p">[</span><span class="n">field_2</span><span class="p">],</span> <span class="o">*</span><span class="n">args_2</span><span class="p">)</span>
                    <span class="n">fn_1</span><span class="p">(</span><span class="n">delayed</span><span class="p">[</span><span class="n">field_1</span><span class="p">],</span> <span class="o">*</span><span class="n">args_1</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">partial</span><span class="p">(</span>
                    <span class="n">_reduce</span><span class="p">,</span> <span class="n">fn_1</span><span class="p">,</span> <span class="n">field_1</span><span class="p">,</span> <span class="n">args_1</span><span class="p">,</span> <span class="n">fn_2</span><span class="p">,</span> <span class="n">field_2</span><span class="p">,</span> <span class="n">args_2</span><span class="p">)</span>

            <span class="k">def</span> <span class="nf">_reduce</span><span class="p">(</span><span class="n">fn_1</span><span class="p">,</span> <span class="n">field_1</span><span class="p">,</span> <span class="n">fn_2</span><span class="p">,</span> <span class="n">field_2</span><span class="p">,</span> <span class="n">delayed</span><span class="p">):</span>
                <span class="n">fn_2</span><span class="p">(</span><span class="n">delayed</span><span class="p">[</span><span class="n">field_2</span><span class="p">])</span>
                <span class="n">fn_1</span><span class="p">(</span><span class="n">delayed</span><span class="p">[</span><span class="n">field_1</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">partial</span><span class="p">(</span><span class="n">_reduce</span><span class="p">,</span> <span class="n">fn_1</span><span class="p">,</span> <span class="n">field_1</span><span class="p">,</span> <span class="n">fn_2</span><span class="p">,</span> <span class="n">field_2</span><span class="p">)</span>

        <span class="c1"># Specialization if op is specified</span>
        <span class="k">if</span> <span class="n">arity</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">is_initialized</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">is_out_1</span> <span class="ow">and</span> <span class="n">is_out_2</span><span class="p">:</span>
                    <span class="k">def</span> <span class="nf">_reduce</span><span class="p">(</span><span class="n">fn_1</span><span class="p">,</span> <span class="n">fn_2</span><span class="p">,</span> <span class="n">out</span><span class="p">):</span>
                        <span class="k">return</span> <span class="n">fn_1</span><span class="p">(</span><span class="n">fn_2</span><span class="p">(</span><span class="n">out</span><span class="p">))</span>
                    <span class="k">return</span> <span class="n">partial</span><span class="p">(</span><span class="n">_reduce</span><span class="p">,</span> <span class="n">fn_1</span><span class="p">,</span> <span class="n">fn_2</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">is_out_1</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">is_out_2</span><span class="p">:</span>
                    <span class="k">def</span> <span class="nf">_reduce</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">fn_1</span><span class="p">,</span> <span class="n">fn_2</span><span class="p">,</span> <span class="n">out</span><span class="p">):</span>
                        <span class="k">return</span> <span class="n">fn_1</span><span class="p">(</span><span class="n">op</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">fn_2</span><span class="p">()))</span>
                <span class="k">elif</span> <span class="ow">not</span> <span class="n">is_out_1</span> <span class="ow">and</span> <span class="n">is_out_2</span><span class="p">:</span>
                    <span class="k">def</span> <span class="nf">_reduce</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">fn_1</span><span class="p">,</span> <span class="n">fn_2</span><span class="p">,</span> <span class="n">out</span><span class="p">):</span>
                        <span class="k">return</span> <span class="n">op</span><span class="p">(</span><span class="n">fn_2</span><span class="p">(</span><span class="n">out</span><span class="p">),</span> <span class="n">fn_1</span><span class="p">())</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">def</span> <span class="nf">_reduce</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">fn_1</span><span class="p">,</span> <span class="n">fn_2</span><span class="p">,</span> <span class="n">out</span><span class="p">):</span>
                        <span class="k">return</span> <span class="n">op</span><span class="p">(</span><span class="n">op</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">fn_2</span><span class="p">()),</span> <span class="n">fn_1</span><span class="p">())</span>
                <span class="k">return</span> <span class="n">partial</span><span class="p">(</span><span class="n">_reduce</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">fn_1</span><span class="p">,</span> <span class="n">fn_2</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">is_out_1</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">is_out_2</span><span class="p">:</span>
                <span class="k">def</span> <span class="nf">_reduce</span><span class="p">(</span><span class="n">fn_1</span><span class="p">,</span> <span class="n">fn_2</span><span class="p">,</span> <span class="n">out</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">fn_1</span><span class="p">(</span><span class="n">fn_2</span><span class="p">())</span>
                <span class="k">return</span> <span class="n">partial</span><span class="p">(</span><span class="n">_reduce</span><span class="p">,</span> <span class="n">fn_1</span><span class="p">,</span> <span class="n">fn_2</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">is_out_1</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">is_out_2</span><span class="p">:</span>
                <span class="k">def</span> <span class="nf">_reduce</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">fn_1</span><span class="p">,</span> <span class="n">fn_2</span><span class="p">,</span> <span class="n">out</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">op</span><span class="p">(</span><span class="n">fn_2</span><span class="p">(),</span> <span class="n">fn_1</span><span class="p">())</span>
            <span class="k">return</span> <span class="n">partial</span><span class="p">(</span><span class="n">_reduce</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">fn_1</span><span class="p">,</span> <span class="n">fn_2</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">is_initialized</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">is_out_1</span> <span class="ow">and</span> <span class="n">is_out_2</span><span class="p">:</span>
                <span class="k">def</span> <span class="nf">_reduce</span><span class="p">(</span><span class="n">fn_1</span><span class="p">,</span> <span class="n">fn_2</span><span class="p">,</span> <span class="n">out</span><span class="p">,</span> <span class="n">delayed</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">fn_1</span><span class="p">(</span><span class="n">fn_2</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">delayed</span><span class="p">),</span> <span class="n">delayed</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">partial</span><span class="p">(</span><span class="n">_reduce</span><span class="p">,</span> <span class="n">fn_1</span><span class="p">,</span> <span class="n">fn_2</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">is_out_1</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">is_out_2</span><span class="p">:</span>
                <span class="k">def</span> <span class="nf">_reduce</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">fn_1</span><span class="p">,</span> <span class="n">fn_2</span><span class="p">,</span> <span class="n">field_2</span><span class="p">,</span> <span class="n">args_2</span><span class="p">,</span> <span class="n">out</span><span class="p">,</span> <span class="n">delayed</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">fn_1</span><span class="p">(</span>
                        <span class="n">op</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">fn_2</span><span class="p">(</span><span class="n">delayed</span><span class="p">[</span><span class="n">field_2</span><span class="p">],</span> <span class="o">*</span><span class="n">args_2</span><span class="p">)),</span> <span class="n">delayed</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">partial</span><span class="p">(</span><span class="n">_reduce</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">fn_1</span><span class="p">,</span> <span class="n">fn_2</span><span class="p">,</span> <span class="n">field_2</span><span class="p">,</span> <span class="n">args_2</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">is_out_1</span> <span class="ow">and</span> <span class="n">is_out_2</span><span class="p">:</span>
                <span class="k">def</span> <span class="nf">_reduce</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">fn_1</span><span class="p">,</span> <span class="n">field_1</span><span class="p">,</span> <span class="n">args_1</span><span class="p">,</span> <span class="n">fn_2</span><span class="p">,</span> <span class="n">out</span><span class="p">,</span> <span class="n">delayed</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">op</span><span class="p">(</span>
                        <span class="n">fn_2</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">delayed</span><span class="p">),</span> <span class="n">fn_1</span><span class="p">(</span><span class="n">delayed</span><span class="p">[</span><span class="n">field_1</span><span class="p">],</span> <span class="o">*</span><span class="n">args_1</span><span class="p">))</span>
                <span class="k">return</span> <span class="n">partial</span><span class="p">(</span><span class="n">_reduce</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">fn_1</span><span class="p">,</span> <span class="n">field_1</span><span class="p">,</span> <span class="n">args_1</span><span class="p">,</span> <span class="n">fn_2</span><span class="p">)</span>

            <span class="k">def</span> <span class="nf">_reduce</span><span class="p">(</span>
                    <span class="n">op</span><span class="p">,</span> <span class="n">fn_1</span><span class="p">,</span> <span class="n">field_1</span><span class="p">,</span> <span class="n">args_1</span><span class="p">,</span> <span class="n">fn_2</span><span class="p">,</span> <span class="n">field_2</span><span class="p">,</span> <span class="n">args_2</span><span class="p">,</span> <span class="n">out</span><span class="p">,</span>
                    <span class="n">delayed</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">op</span><span class="p">(</span><span class="n">op</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">fn_2</span><span class="p">(</span><span class="n">delayed</span><span class="p">[</span><span class="n">field_2</span><span class="p">],</span> <span class="o">*</span><span class="n">args_2</span><span class="p">)),</span>
                          <span class="n">fn_1</span><span class="p">(</span><span class="n">delayed</span><span class="p">[</span><span class="n">field_1</span><span class="p">],</span> <span class="o">*</span><span class="n">args_1</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">partial</span><span class="p">(</span>
                <span class="n">_reduce</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">fn_1</span><span class="p">,</span> <span class="n">field_1</span><span class="p">,</span> <span class="n">args_1</span><span class="p">,</span> <span class="n">fn_2</span><span class="p">,</span> <span class="n">field_2</span><span class="p">,</span> <span class="n">args_2</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">is_out_1</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">is_out_2</span><span class="p">:</span>
            <span class="k">def</span> <span class="nf">_reduce</span><span class="p">(</span><span class="n">fn_1</span><span class="p">,</span> <span class="n">fn_2</span><span class="p">,</span> <span class="n">field_2</span><span class="p">,</span> <span class="n">args_2</span><span class="p">,</span> <span class="n">out</span><span class="p">,</span> <span class="n">delayed</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">fn_1</span><span class="p">(</span><span class="n">fn_2</span><span class="p">(</span><span class="n">delayed</span><span class="p">[</span><span class="n">field_2</span><span class="p">],</span> <span class="o">*</span><span class="n">args_2</span><span class="p">),</span> <span class="n">delayed</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">partial</span><span class="p">(</span><span class="n">_reduce</span><span class="p">,</span> <span class="n">fn_1</span><span class="p">,</span> <span class="n">fn_2</span><span class="p">,</span> <span class="n">field_2</span><span class="p">,</span> <span class="n">args_2</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">_reduce</span><span class="p">(</span>  <span class="c1"># type: ignore[no-redef]</span>
                <span class="n">op</span><span class="p">,</span> <span class="n">fn_1</span><span class="p">,</span> <span class="n">field_1</span><span class="p">,</span> <span class="n">args_1</span><span class="p">,</span> <span class="n">fn_2</span><span class="p">,</span> <span class="n">field_2</span><span class="p">,</span> <span class="n">args_2</span><span class="p">,</span> <span class="n">out</span><span class="p">,</span>
                <span class="n">delayed</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">op</span><span class="p">(</span><span class="n">fn_2</span><span class="p">(</span><span class="n">delayed</span><span class="p">[</span><span class="n">field_2</span><span class="p">],</span> <span class="o">*</span><span class="n">args_2</span><span class="p">),</span>
                      <span class="n">fn_1</span><span class="p">(</span><span class="n">delayed</span><span class="p">[</span><span class="n">field_1</span><span class="p">],</span> <span class="o">*</span><span class="n">args_1</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">partial</span><span class="p">(</span>
            <span class="n">_reduce</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">fn_1</span><span class="p">,</span> <span class="n">field_1</span><span class="p">,</span> <span class="n">args_1</span><span class="p">,</span> <span class="n">fn_2</span><span class="p">,</span> <span class="n">field_2</span><span class="p">,</span> <span class="n">args_2</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_build_forward</span><span class="p">(</span>
            <span class="n">arity</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
            <span class="n">parent</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]],</span>
            <span class="n">is_initialized</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
            <span class="n">post_fn</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">ValueInT</span><span class="p">],</span> <span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">ValueOutT</span><span class="p">]],</span>
            <span class="n">field</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]],</span>
            <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">ValueInT</span><span class="p">],</span> <span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">ValueOutT</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Internal method generating a specialized callable forwarding the</span>
<span class="sd">        value associated with a given key for nested data structure provided at</span>
<span class="sd">        runtime if any as input argument of some leaf transform or branch</span>
<span class="sd">        reduction callable.</span>

<span class="sd">        The callable is not a reduction at this point, so doing it here since</span>
<span class="sd">        it is the very last moment before main entry-point returns.</span>

<span class="sd">        :param arity: Arity of the generated callable.</span>
<span class="sd">        :param is_initialized: Whether the output has already been initialized.</span>
<span class="sd">        :param parent: Parent key to forward.</span>
<span class="sd">        :param post_fn: Leaf transform or branch reduction.</span>

<span class="sd">        :returns: Specialized key-forwarding callable.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">is_out</span> <span class="o">=</span> <span class="n">post_fn</span><span class="o">.</span><span class="n">func</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">fn</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_out</span><span class="p">:</span>
            <span class="c1"># Extract extra arguments from functor to preserve arguments order</span>
            <span class="n">dataset</span><span class="p">,</span> <span class="n">args</span> <span class="o">=</span> <span class="n">post_fn</span><span class="o">.</span><span class="n">args</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">post_fn</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">post_fn</span> <span class="o">=</span> <span class="n">post_fn</span><span class="o">.</span><span class="n">func</span>
            <span class="n">has_args</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">arity</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">post_fn</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">post_fn</span><span class="p">,</span> <span class="o">*</span><span class="n">dataset</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">dataset</span><span class="p">:</span>
                <span class="n">post_fn</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">post_fn</span><span class="p">,</span> <span class="o">*</span><span class="n">dataset</span><span class="p">)</span>

            <span class="c1"># Specialization if no op is specified</span>
            <span class="k">if</span> <span class="n">op</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">arity</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">def</span> <span class="nf">_forward</span><span class="p">(</span><span class="n">post_fn</span><span class="p">):</span>
                        <span class="n">post_fn</span><span class="p">()</span>
                    <span class="k">return</span> <span class="n">partial</span><span class="p">(</span><span class="n">_forward</span><span class="p">,</span> <span class="n">post_fn</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">has_args</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">parent</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">field</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="k">def</span> <span class="nf">_forward</span><span class="p">(</span><span class="n">post_fn</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">delayed</span><span class="p">):</span>
                            <span class="n">post_fn</span><span class="p">(</span><span class="n">delayed</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
                        <span class="k">return</span> <span class="n">partial</span><span class="p">(</span><span class="n">_forward</span><span class="p">,</span> <span class="n">post_fn</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">parent</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="o">^</span> <span class="p">(</span><span class="n">field</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
                        <span class="k">def</span> <span class="nf">_forward</span><span class="p">(</span><span class="n">post_fn</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">delayed</span><span class="p">):</span>
                            <span class="n">post_fn</span><span class="p">(</span><span class="n">delayed</span><span class="p">[</span><span class="n">field</span><span class="p">],</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
                        <span class="k">return</span> <span class="n">partial</span><span class="p">(</span>
                            <span class="n">_forward</span><span class="p">,</span> <span class="n">post_fn</span><span class="p">,</span> <span class="n">parent</span> <span class="ow">or</span> <span class="n">field</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span>

                    <span class="k">def</span> <span class="nf">_forward</span><span class="p">(</span><span class="n">post_fn</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">delayed</span><span class="p">):</span>
                        <span class="n">post_fn</span><span class="p">(</span><span class="n">delayed</span><span class="p">[</span><span class="n">parent</span><span class="p">][</span><span class="n">field</span><span class="p">],</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
                    <span class="k">return</span> <span class="n">partial</span><span class="p">(</span><span class="n">_forward</span><span class="p">,</span> <span class="n">post_fn</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">parent</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">field</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">def</span> <span class="nf">_forward</span><span class="p">(</span><span class="n">post_fn</span><span class="p">,</span> <span class="n">delayed</span><span class="p">):</span>
                        <span class="n">post_fn</span><span class="p">(</span><span class="n">delayed</span><span class="p">)</span>
                    <span class="k">return</span> <span class="n">partial</span><span class="p">(</span><span class="n">_forward</span><span class="p">,</span> <span class="n">post_fn</span><span class="p">)</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">parent</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="o">^</span> <span class="p">(</span><span class="n">field</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
                    <span class="k">def</span> <span class="nf">_forward</span><span class="p">(</span><span class="n">post_fn</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">delayed</span><span class="p">):</span>
                        <span class="n">post_fn</span><span class="p">(</span><span class="n">delayed</span><span class="p">[</span><span class="n">field</span><span class="p">])</span>
                    <span class="k">return</span> <span class="n">partial</span><span class="p">(</span><span class="n">_forward</span><span class="p">,</span> <span class="n">post_fn</span><span class="p">,</span> <span class="n">parent</span> <span class="ow">or</span> <span class="n">field</span><span class="p">)</span>

                <span class="k">def</span> <span class="nf">_forward</span><span class="p">(</span><span class="n">post_fn</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">delayed</span><span class="p">):</span>
                    <span class="n">post_fn</span><span class="p">(</span><span class="n">delayed</span><span class="p">[</span><span class="n">parent</span><span class="p">][</span><span class="n">field</span><span class="p">])</span>
                <span class="k">return</span> <span class="n">partial</span><span class="p">(</span><span class="n">_forward</span><span class="p">,</span> <span class="n">post_fn</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">field</span><span class="p">)</span>

            <span class="c1"># Specialization if op is specified</span>
            <span class="k">if</span> <span class="n">arity</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">is_initialized</span><span class="p">:</span>
                    <span class="k">def</span> <span class="nf">_forward</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">post_fn</span><span class="p">,</span> <span class="n">out</span><span class="p">):</span>
                        <span class="k">return</span> <span class="n">op</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">post_fn</span><span class="p">())</span>
                    <span class="k">return</span> <span class="n">partial</span><span class="p">(</span><span class="n">_forward</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">post_fn</span><span class="p">)</span>

                <span class="k">def</span> <span class="nf">_forward</span><span class="p">(</span><span class="n">post_fn</span><span class="p">,</span> <span class="n">out</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">post_fn</span><span class="p">()</span>
                <span class="k">return</span> <span class="n">partial</span><span class="p">(</span><span class="n">_forward</span><span class="p">,</span> <span class="n">post_fn</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">is_initialized</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">parent</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">field</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">def</span> <span class="nf">_forward</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">post_fn</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">out</span><span class="p">,</span> <span class="n">delayed</span><span class="p">):</span>
                        <span class="k">return</span> <span class="n">op</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">post_fn</span><span class="p">(</span><span class="n">delayed</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">))</span>
                    <span class="k">return</span> <span class="n">partial</span><span class="p">(</span><span class="n">_forward</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">post_fn</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">parent</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="o">^</span> <span class="p">(</span><span class="n">field</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
                    <span class="k">def</span> <span class="nf">_forward</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">post_fn</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">out</span><span class="p">,</span> <span class="n">delayed</span><span class="p">):</span>
                        <span class="k">return</span> <span class="n">op</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">post_fn</span><span class="p">(</span><span class="n">delayed</span><span class="p">[</span><span class="n">field</span><span class="p">],</span> <span class="o">*</span><span class="n">args</span><span class="p">))</span>
                    <span class="k">return</span> <span class="n">partial</span><span class="p">(</span>
                        <span class="n">_forward</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">post_fn</span><span class="p">,</span> <span class="n">parent</span> <span class="ow">or</span> <span class="n">field</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span>

                <span class="k">def</span> <span class="nf">_forward</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">post_fn</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">out</span><span class="p">,</span> <span class="n">delayed</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">op</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">post_fn</span><span class="p">(</span><span class="n">delayed</span><span class="p">[</span><span class="n">parent</span><span class="p">][</span><span class="n">field</span><span class="p">],</span> <span class="o">*</span><span class="n">args</span><span class="p">))</span>
                <span class="k">return</span> <span class="n">partial</span><span class="p">(</span><span class="n">_forward</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">post_fn</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">parent</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">field</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">def</span> <span class="nf">_forward</span><span class="p">(</span><span class="n">post_fn</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">out</span><span class="p">,</span> <span class="n">delayed</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">post_fn</span><span class="p">(</span><span class="n">delayed</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">partial</span><span class="p">(</span><span class="n">_forward</span><span class="p">,</span> <span class="n">post_fn</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">parent</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="o">^</span> <span class="p">(</span><span class="n">field</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
                <span class="k">def</span> <span class="nf">_forward</span><span class="p">(</span><span class="n">post_fn</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">out</span><span class="p">,</span> <span class="n">delayed</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">post_fn</span><span class="p">(</span><span class="n">delayed</span><span class="p">[</span><span class="n">field</span><span class="p">],</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">partial</span><span class="p">(</span><span class="n">_forward</span><span class="p">,</span> <span class="n">post_fn</span><span class="p">,</span> <span class="n">parent</span> <span class="ow">or</span> <span class="n">field</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span>

            <span class="k">def</span> <span class="nf">_forward</span><span class="p">(</span><span class="n">post_fn</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">out</span><span class="p">,</span> <span class="n">delayed</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">post_fn</span><span class="p">(</span><span class="n">delayed</span><span class="p">[</span><span class="n">parent</span><span class="p">][</span><span class="n">field</span><span class="p">],</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">partial</span><span class="p">(</span><span class="n">_forward</span><span class="p">,</span> <span class="n">post_fn</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span>

        <span class="c1"># No key to forward for main entry-point of zero arity</span>
        <span class="k">if</span> <span class="n">parent</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">arity</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">post_fn</span>

        <span class="c1"># Forward key in all other cases</span>
        <span class="k">if</span> <span class="n">op</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">def</span> <span class="nf">_forward</span><span class="p">(</span><span class="n">post_fn</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">delayed</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">post_fn</span><span class="p">(</span><span class="n">delayed</span><span class="p">[</span><span class="n">field</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">def</span> <span class="nf">_forward</span><span class="p">(</span><span class="n">post_fn</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">out</span><span class="p">,</span> <span class="n">delayed</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">post_fn</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">delayed</span><span class="p">[</span><span class="n">field</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">partial</span><span class="p">(</span><span class="n">_forward</span><span class="p">,</span> <span class="n">post_fn</span><span class="p">,</span> <span class="n">parent</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_build_transform_and_reduce</span><span class="p">(</span>
            <span class="n">arity</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
            <span class="n">parent</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]],</span>
            <span class="n">is_initialized</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
            <span class="n">dataset</span><span class="p">:</span> <span class="n">SequenceT</span><span class="p">[</span><span class="n">DataNested</span><span class="p">],</span>
            <span class="n">space</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">gym</span><span class="o">.</span><span class="n">Space</span><span class="p">[</span><span class="n">DataNested</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span>
                <span class="n">Union</span><span class="p">[</span><span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">ValueInT</span><span class="p">],</span> <span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">ValueOutT</span><span class="p">]]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Internal method for generating specialized callable applying</span>
<span class="sd">        transform and reduction on all leaves of a nested space recursively.</span>

<span class="sd">        :param arity: Arity of the generated callable.</span>
<span class="sd">        :param parent: Key of parent space mapping to space if any, `None`</span>
<span class="sd">                       otherwise.</span>
<span class="sd">        :param is_initialized: Whether the output has already been initialized</span>
<span class="sd">                               at this point. See `_build_reduce` for details.</span>
<span class="sd">        :param data: Possibly nested pre-allocated data.</span>
<span class="sd">        :param space: Possibly nested space on which to operate.</span>

<span class="sd">        :returns: Specialized transform if the space is a actually a leaf,</span>
<span class="sd">                  otherwise a specialized transform and reduction callable</span>
<span class="sd">                  still requiring passing the current reduction output as input</span>
<span class="sd">                  if some reduction operator has been specified. `None` if</span>
<span class="sd">                  nested data structure if empty.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Determine top-level keys if nested data structure</span>
        <span class="n">keys</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">SequenceT</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">SequenceT</span><span class="p">[</span><span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">space_or_data</span> <span class="o">=</span> <span class="n">space</span>
        <span class="k">if</span> <span class="n">space_or_data</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">dataset</span><span class="p">:</span>
            <span class="n">space_or_data</span> <span class="o">=</span> <span class="n">dataset</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">space_or_data</span><span class="p">,</span> <span class="n">Mapping</span><span class="p">):</span>
            <span class="n">keys</span> <span class="o">=</span> <span class="n">space_or_data</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">space_or_data</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">):</span>
            <span class="n">keys</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">space_or_data</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">space_or_data</span><span class="p">,</span> <span class="p">(</span><span class="n">gym</span><span class="o">.</span><span class="n">Space</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">))</span>

        <span class="c1"># Return specialized transform if leaf</span>
        <span class="k">if</span> <span class="n">keys</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">post_fn</span> <span class="o">=</span> <span class="n">fn</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">dataset</span> <span class="k">else</span> <span class="n">partial</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">dataset</span><span class="p">)</span>
            <span class="n">post_args</span> <span class="o">=</span> <span class="n">args</span>
            <span class="k">if</span> <span class="n">forward_bounds</span> <span class="ow">and</span> <span class="n">space</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">post_args</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="o">*</span><span class="n">get_bounds</span><span class="p">(</span><span class="n">space</span><span class="p">,</span> <span class="n">tol_abs</span><span class="p">,</span> <span class="n">tol_rel</span><span class="p">),</span> <span class="o">*</span><span class="n">post_args</span><span class="p">)</span>
            <span class="n">post_fn</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">post_fn</span><span class="p">,</span> <span class="n">post_args</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">parent</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">post_fn</span> <span class="o">=</span> <span class="n">_build_forward</span><span class="p">(</span>
                    <span class="n">arity</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">is_initialized</span><span class="p">,</span> <span class="n">post_fn</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">post_fn</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">keys</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="c1"># Generate transform and reduce method if branch</span>
        <span class="n">field_prev</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">out_fn</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">field</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">:</span>
            <span class="n">values</span> <span class="o">=</span> <span class="p">[</span><span class="n">data</span><span class="p">[</span><span class="n">field</span><span class="p">]</span> <span class="k">for</span> <span class="n">data</span> <span class="ow">in</span> <span class="n">dataset</span><span class="p">]</span>
            <span class="n">subspace</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">space</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">space</span><span class="p">[</span><span class="n">field</span><span class="p">]</span>
            <span class="n">must_initialize</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">is_initialized</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">keys</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
            <span class="n">post_fn</span> <span class="o">=</span> <span class="n">_build_transform_and_reduce</span><span class="p">(</span>
                <span class="n">arity</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="ow">not</span> <span class="n">must_initialize</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">subspace</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">post_fn</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="n">out_fn</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">out_fn</span> <span class="o">=</span> <span class="n">post_fn</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">out_fn</span> <span class="o">=</span> <span class="n">_build_reduce</span><span class="p">(</span>
                    <span class="n">arity</span><span class="p">,</span> <span class="n">is_initialized</span><span class="p">,</span> <span class="n">post_fn</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">out_fn</span><span class="p">,</span> <span class="n">field_prev</span><span class="p">)</span>
                <span class="n">is_initialized</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">field_prev</span> <span class="o">=</span> <span class="n">field</span>
        <span class="k">if</span> <span class="n">out_fn</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">_build_forward</span><span class="p">(</span><span class="n">arity</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">is_initialized</span><span class="p">,</span> <span class="n">out_fn</span><span class="p">,</span> <span class="n">field</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_dispatch</span><span class="p">(</span>
            <span class="n">post_fn_0</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[],</span> <span class="n">ValueOutT</span><span class="p">],</span>
            <span class="n">post_fn_1</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">DataNested</span><span class="p">],</span> <span class="n">ValueOutT</span><span class="p">],</span>
            <span class="o">*</span><span class="n">delayed</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">DataNested</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">ValueOutT</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Internal method for handling unknown arity at generation-time.</span>

<span class="sd">        :param post_fn_0: Nullary specialized transform and reduce callable.</span>
<span class="sd">        :param post_fn_1: Unary specialized transform and reduce callable.</span>
<span class="sd">        :param delayed: Optional nested data structure any provided at runtime.</span>

<span class="sd">        :returns: Specialized transform and reduce callable of dynamic arity.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">delayed</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">post_fn_0</span><span class="p">()</span>
        <span class="p">(</span><span class="n">arg</span><span class="p">,)</span> <span class="o">=</span> <span class="n">delayed</span>
        <span class="k">return</span> <span class="n">post_fn_1</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_build_init</span><span class="p">(</span>
            <span class="n">arity</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
            <span class="n">post_fn</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">ValueOutT</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">ValueOutT</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Internal method generating a specialized callable initializing the</span>
<span class="sd">        output if a reduction operator and a dedicated initializer has been</span>
<span class="sd">        specified.</span>

<span class="sd">        :param post_fn: Specialized transform and reduce callable.</span>

<span class="sd">        :returns: Specialized transform and reduce callable only taking nested</span>
<span class="sd">                  data structures as input.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">post_fn</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">initializer</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="k">lambda</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="kc">None</span>
            <span class="k">return</span> <span class="n">initializer</span>
        <span class="k">if</span> <span class="n">op</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">post_fn</span>
        <span class="k">if</span> <span class="n">initializer</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">partial</span><span class="p">(</span><span class="n">post_fn</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">arity</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">def</span> <span class="nf">_initialize</span><span class="p">(</span><span class="n">post_fn</span><span class="p">,</span> <span class="n">initializer</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">post_fn</span><span class="p">(</span><span class="n">initializer</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">def</span> <span class="nf">_initialize</span><span class="p">(</span><span class="n">post_fn</span><span class="p">,</span> <span class="n">initializer</span><span class="p">,</span> <span class="n">delayed</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">post_fn</span><span class="p">(</span><span class="n">initializer</span><span class="p">(),</span> <span class="n">delayed</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">partial</span><span class="p">(</span><span class="n">_initialize</span><span class="p">,</span> <span class="n">post_fn</span><span class="p">,</span> <span class="n">initializer</span><span class="p">)</span>

    <span class="c1"># Check that the combination of input arguments are valid</span>
    <span class="k">if</span> <span class="n">space</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">dataset</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;At least one dataset or the space must be specified.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">arity</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="kc">None</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Arity must be either 0, 1 or `None`.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="n">partial</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Transform function cannot be &#39;partial&#39; instance.&quot;</span><span class="p">)</span>

    <span class="c1"># Generate transform and reduce callable of various arity if necessary</span>
    <span class="n">all_fn</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">arity</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">arity</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="n">is_initialized</span> <span class="o">=</span> <span class="n">op</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">initializer</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="n">all_fn</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">_build_init</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">_build_transform_and_reduce</span><span class="p">(</span>
            <span class="n">i</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">is_initialized</span><span class="p">,</span> <span class="n">dataset</span><span class="p">,</span> <span class="n">space</span><span class="p">))</span>

    <span class="c1"># Return callable of requested arity if specified, dynamic dispatch if not</span>
    <span class="k">if</span> <span class="n">arity</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">partial</span><span class="p">(</span><span class="n">_dispatch</span><span class="p">,</span> <span class="o">*</span><span class="n">all_fn</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">all_fn</span><span class="p">[</span><span class="n">arity</span><span class="p">]</span></div>



<div class="viewcode-block" id="build_map">
<a class="viewcode-back" href="../../../../api/gym_jiminy/common/utils/spaces.html#gym_jiminy.common.utils.spaces.build_map">[docs]</a>
<span class="nd">@no_type_check</span>
<span class="k">def</span> <span class="nf">build_map</span><span class="p">(</span><span class="n">fn</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">ValueT</span><span class="p">],</span>
              <span class="n">data</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">DataNested</span><span class="p">],</span>
              <span class="n">space</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">gym</span><span class="o">.</span><span class="n">Space</span><span class="p">[</span><span class="n">DataNested</span><span class="p">]],</span>
              <span class="n">arity</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Literal</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]],</span>
              <span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span>
              <span class="n">forward_bounds</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
              <span class="n">tol_abs</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
              <span class="n">tol_rel</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Callable</span><span class="p">[[],</span> <span class="n">StructNested</span><span class="p">[</span><span class="n">ValueT</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Generate specialized callable returning applying out-of-place transform</span>
<span class="sd">    to all leaves of given nested space.</span>

<span class="sd">    .. warning::</span>
<span class="sd">        This method systematically allocates memory to store the resulting</span>
<span class="sd">        nested data structure, which is costly. If pre-allocation is possible,</span>
<span class="sd">        it would more efficient to use `build_reduce` without operator instead.</span>

<span class="sd">    .. warning::</span>
<span class="sd">        Providing additional data at runtime is supported but impede</span>
<span class="sd">        performance. Arity larger than 1 is not supported because the code path</span>
<span class="sd">        could not be fully specialized, causing dramatic slowdown.</span>

<span class="sd">    .. warning::</span>
<span class="sd">        It is assumed without check that all nested data structures are</span>
<span class="sd">        consistent together and with the space if provided. It holds true both</span>
<span class="sd">        data known at generation-time or runtime. Yet, it is only required for</span>
<span class="sd">        data provided at runtime if any to include the original data structure,</span>
<span class="sd">        so it may contain additional branches which will be ignored.</span>

<span class="sd">    :param fn: Transform applied to every leaves of the nested data structures.</span>
<span class="sd">               This function is supposed to allocate its own memory while</span>
<span class="sd">               performing some out-of-place operations then return the outcome.</span>
<span class="sd">    :param data: Pre-allocated nested data structure. Optional iif the space is</span>
<span class="sd">                 provided. This enables generating specialized random sampling</span>
<span class="sd">                 methods for instance.</span>
<span class="sd">    :param space: `gym.spaces.Dict` on which to operate. Optional iif the</span>
<span class="sd">                  nested data structure is provided.</span>
<span class="sd">    :param arity: Arity of the generated callable. `None` to indicate that it</span>
<span class="sd">                  must be determined at runtime, which is slower. Either way,</span>
<span class="sd">                  only 0 or 1 arity is supported for now.</span>
<span class="sd">    :param args: Extra arguments to systematically forward as transform input</span>
<span class="sd">                 for all leaves. Note that, as for Python built-ins methods,</span>
<span class="sd">                 keywords are not supported for the sake of efficiency.</span>
<span class="sd">    :param forward_bounds: Whether to forward the lower and upper bounds of the</span>
<span class="sd">                           `gym.Space` associated with each leaf as transform</span>
<span class="sd">                           input. In this case, they will be added after the</span>
<span class="sd">                           data structure provided at runtime but before other</span>
<span class="sd">                           extra arguments if any. It is up to the user to make</span>
<span class="sd">                           sure all leaves have bounds, otherwise it will raise</span>
<span class="sd">                           an exception at generation-time. This argument is</span>
<span class="sd">                           ignored if not space is specified.</span>
<span class="sd">                           Optional: `True` by default.</span>
<span class="sd">    :param tol_abs: Absolute tolerance added to the lower and upper bounds of</span>
<span class="sd">                    the `gym.Space` associated with each leaf.</span>
<span class="sd">                    Optional: 0.0 by default.</span>
<span class="sd">    :param tol_rel: Relative tolerance added to the lower and upper bounds of</span>
<span class="sd">                    the `gym.Space` associated with each leaf.</span>
<span class="sd">                    Optional: 0.0 by default.</span>

<span class="sd">    :returns: Fully-specialized mapping callable.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">_build_setitem</span><span class="p">(</span>
            <span class="n">arity</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
            <span class="n">self_fn</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">StructNested</span><span class="p">[</span><span class="n">ValueT</span><span class="p">]]]],</span>
            <span class="n">value_fn</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">StructNested</span><span class="p">[</span><span class="n">ValueT</span><span class="p">]],</span>
            <span class="n">key</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span>
            <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">StructNested</span><span class="p">[</span><span class="n">ValueT</span><span class="p">]]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Internal method generating a specialized item assignment callable</span>
<span class="sd">        responsible for populating a parent transformed nested data structure</span>
<span class="sd">        with either some child branch already transformed or some leaf to be</span>
<span class="sd">        transformed.</span>

<span class="sd">        This method aims to be composed with itself for recursively creating</span>
<span class="sd">        the whole transformed nested data structure.</span>

<span class="sd">        :param arity: Arity of the generated callable.</span>
<span class="sd">        :param self_fn: Parent branch transform.</span>
<span class="sd">        :param value_fn: Child leaf or branch transform.</span>
<span class="sd">        :param key: Field of the parent transformed nested data structure that</span>
<span class="sd">                    must be populated with the output of the child transform.</span>

<span class="sd">        :returns: Specialized item assignment callable.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Extract extra arguments from functor if necessary to preserve order</span>
        <span class="n">is_out</span><span class="p">,</span> <span class="n">has_args</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value_fn</span><span class="p">,</span> <span class="n">partial</span><span class="p">):</span>
            <span class="n">is_out</span> <span class="o">=</span> <span class="n">value_fn</span><span class="o">.</span><span class="n">func</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">fn</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">is_out</span><span class="p">:</span>
                <span class="n">dataset</span><span class="p">,</span> <span class="n">args</span> <span class="o">=</span> <span class="n">value_fn</span><span class="o">.</span><span class="n">args</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">value_fn</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">value_fn</span> <span class="o">=</span> <span class="n">value_fn</span><span class="o">.</span><span class="n">func</span>
                <span class="n">has_args</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">arity</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">value_fn</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">value_fn</span><span class="p">,</span> <span class="o">*</span><span class="n">dataset</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">dataset</span><span class="p">:</span>
                    <span class="n">value_fn</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">value_fn</span><span class="p">,</span> <span class="o">*</span><span class="n">dataset</span><span class="p">)</span>

        <span class="n">is_mapping</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">arity</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">value_fn</span>
            <span class="k">if</span> <span class="n">is_mapping</span><span class="p">:</span>
                <span class="k">def</span> <span class="nf">_setitem</span><span class="p">(</span><span class="n">self_fn</span><span class="p">,</span> <span class="n">value_fn</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
                    <span class="bp">self</span> <span class="o">=</span> <span class="n">self_fn</span><span class="p">()</span>
                    <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value_fn</span><span class="p">()</span>
                    <span class="k">return</span> <span class="bp">self</span>
                <span class="k">return</span> <span class="n">partial</span><span class="p">(</span><span class="n">_setitem</span><span class="p">,</span> <span class="n">self_fn</span><span class="p">,</span> <span class="n">value_fn</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>

            <span class="k">def</span> <span class="nf">_setitem</span><span class="p">(</span><span class="n">self_fn</span><span class="p">,</span> <span class="n">value_fn</span><span class="p">):</span>
                <span class="bp">self</span> <span class="o">=</span> <span class="n">self_fn</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">value_fn</span><span class="p">())</span>
                <span class="k">return</span> <span class="bp">self</span>
            <span class="k">return</span> <span class="n">partial</span><span class="p">(</span><span class="n">_setitem</span><span class="p">,</span> <span class="n">self_fn</span><span class="p">,</span> <span class="n">value_fn</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">has_args</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">def</span> <span class="nf">_setitem</span><span class="p">(</span><span class="n">value_fn</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">delayed</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">value_fn</span><span class="p">(</span><span class="n">delayed</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">partial</span><span class="p">(</span><span class="n">_setitem</span><span class="p">,</span> <span class="n">value_fn</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">is_mapping</span><span class="p">:</span>
                <span class="k">def</span> <span class="nf">_setitem</span><span class="p">(</span><span class="n">self_fn</span><span class="p">,</span> <span class="n">value_fn</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">delayed</span><span class="p">):</span>
                    <span class="bp">self</span> <span class="o">=</span> <span class="n">self_fn</span><span class="p">(</span><span class="n">delayed</span><span class="p">)</span>
                    <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value_fn</span><span class="p">(</span><span class="n">delayed</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
                    <span class="k">return</span> <span class="bp">self</span>
                <span class="k">return</span> <span class="n">partial</span><span class="p">(</span><span class="n">_setitem</span><span class="p">,</span> <span class="n">self_fn</span><span class="p">,</span> <span class="n">value_fn</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span>

            <span class="k">def</span> <span class="nf">_setitem</span><span class="p">(</span><span class="n">self_fn</span><span class="p">,</span> <span class="n">value_fn</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">delayed</span><span class="p">):</span>
                <span class="bp">self</span> <span class="o">=</span> <span class="n">self_fn</span><span class="p">(</span><span class="n">delayed</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">value_fn</span><span class="p">(</span><span class="n">delayed</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="o">*</span><span class="n">args</span><span class="p">))</span>
                <span class="k">return</span> <span class="bp">self</span>
            <span class="k">return</span> <span class="n">partial</span><span class="p">(</span><span class="n">_setitem</span><span class="p">,</span> <span class="n">self_fn</span><span class="p">,</span> <span class="n">value_fn</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">value_fn</span>
        <span class="k">if</span> <span class="n">is_mapping</span><span class="p">:</span>
            <span class="k">def</span> <span class="nf">_setitem</span><span class="p">(</span><span class="n">self_fn</span><span class="p">,</span> <span class="n">value_fn</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">delayed</span><span class="p">):</span>
                <span class="bp">self</span> <span class="o">=</span> <span class="n">self_fn</span><span class="p">(</span><span class="n">delayed</span><span class="p">)</span>
                <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value_fn</span><span class="p">(</span><span class="n">delayed</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>
                <span class="k">return</span> <span class="bp">self</span>
            <span class="k">return</span> <span class="n">partial</span><span class="p">(</span><span class="n">_setitem</span><span class="p">,</span> <span class="n">self_fn</span><span class="p">,</span> <span class="n">value_fn</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">_setitem</span><span class="p">(</span>  <span class="c1"># type: ignore[no-redef]</span>
                <span class="n">self_fn</span><span class="p">,</span> <span class="n">value_fn</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">delayed</span><span class="p">):</span>
            <span class="bp">self</span> <span class="o">=</span> <span class="n">self_fn</span><span class="p">(</span><span class="n">delayed</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">value_fn</span><span class="p">(</span><span class="n">delayed</span><span class="p">[</span><span class="n">key</span><span class="p">]))</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">return</span> <span class="n">partial</span><span class="p">(</span><span class="n">_setitem</span><span class="p">,</span> <span class="n">self_fn</span><span class="p">,</span> <span class="n">value_fn</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_build_map</span><span class="p">(</span>
            <span class="n">arity</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
            <span class="n">parent</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
            <span class="n">data</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">DataNested</span><span class="p">],</span>
            <span class="n">space</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">gym</span><span class="o">.</span><span class="n">Space</span><span class="p">[</span><span class="n">DataNested</span><span class="p">]]</span>
            <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">StructNested</span><span class="p">[</span><span class="n">ValueT</span><span class="p">]]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Internal method for generating specialized callable applying</span>
<span class="sd">        out-of-place transform to all leaves of given nested space.</span>

<span class="sd">        :param arity: Arity of the generated callable.</span>
<span class="sd">        :param parent: Key of parent space mapping to space if any, `None`</span>
<span class="sd">                       otherwise.</span>
<span class="sd">        :param data: Possibly nested pre-allocated data.</span>
<span class="sd">        :param space: Possibly nested space on which to operate.</span>

<span class="sd">        :returns: Specialized leaf or branch transform.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Determine top-level keys if nested data structure</span>
        <span class="n">keys</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">SequenceT</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">SequenceT</span><span class="p">[</span><span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">space_or_data</span> <span class="o">=</span> <span class="n">data</span> <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">space</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">space_or_data</span><span class="p">,</span> <span class="n">Mapping</span><span class="p">):</span>
            <span class="n">keys</span> <span class="o">=</span> <span class="n">space_or_data</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">space_or_data</span><span class="p">,</span> <span class="n">gym</span><span class="o">.</span><span class="n">spaces</span><span class="o">.</span><span class="n">Dict</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">container_cls</span> <span class="o">=</span> <span class="n">OrderedDict</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">container_cls</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">space_or_data</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">space_or_data</span><span class="p">,</span> <span class="n">MutableMapping</span><span class="p">):</span>
                <span class="n">container_cls</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">space_or_data</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">container_cls</span> <span class="o">=</span> <span class="nb">dict</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">space_or_data</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">):</span>
            <span class="n">keys</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">space_or_data</span><span class="p">))</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">space_or_data</span><span class="p">,</span> <span class="n">gym</span><span class="o">.</span><span class="n">spaces</span><span class="o">.</span><span class="n">Tuple</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">container_cls</span> <span class="o">=</span> <span class="nb">list</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">container_cls</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">space_or_data</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">space_or_data</span><span class="p">,</span> <span class="n">MutableSequence</span><span class="p">):</span>
                <span class="n">container_cls</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">space_or_data</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">container_cls</span> <span class="o">=</span> <span class="nb">list</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">space_or_data</span><span class="p">,</span> <span class="p">(</span><span class="n">gym</span><span class="o">.</span><span class="n">Space</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">))</span>

        <span class="c1"># Return specialized transform if leaf</span>
        <span class="k">if</span> <span class="n">keys</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">post_fn</span> <span class="o">=</span> <span class="n">fn</span> <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">partial</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
            <span class="n">post_args</span> <span class="o">=</span> <span class="n">args</span>
            <span class="k">if</span> <span class="n">forward_bounds</span> <span class="ow">and</span> <span class="n">space</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">post_args</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="o">*</span><span class="n">get_bounds</span><span class="p">(</span><span class="n">space</span><span class="p">,</span> <span class="n">tol_abs</span><span class="p">,</span> <span class="n">tol_rel</span><span class="p">),</span> <span class="o">*</span><span class="n">post_args</span><span class="p">)</span>
            <span class="n">post_fn</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">post_fn</span><span class="p">,</span> <span class="n">post_args</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">parent</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">post_fn</span> <span class="o">=</span> <span class="n">_build_setitem</span><span class="p">(</span><span class="n">arity</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">post_fn</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">post_fn</span>

        <span class="c1"># Create new empty container to all transformed values.</span>
        <span class="c1"># FIXME: Immutable containers should be instantiated at the end.</span>
        <span class="k">def</span> <span class="nf">_create</span><span class="p">(</span><span class="bp">cls</span><span class="p">:</span> <span class="n">Type</span><span class="p">[</span><span class="n">ValueT</span><span class="p">],</span> <span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ValueT</span><span class="p">:</span>
            <span class="c1"># pylint: disable=unused-argument</span>
            <span class="k">return</span> <span class="bp">cls</span><span class="p">()</span>
        <span class="n">out_fn</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">_create</span><span class="p">,</span> <span class="n">container_cls</span><span class="p">)</span>

        <span class="c1"># Apply map recursively while preserving order using monadic operations</span>
        <span class="k">for</span> <span class="n">field</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">data</span><span class="p">[</span><span class="n">field</span><span class="p">]</span>
            <span class="n">subspace</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">space</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">space</span><span class="p">[</span><span class="n">field</span><span class="p">]</span>
            <span class="n">post_fn</span> <span class="o">=</span> <span class="n">_build_map</span><span class="p">(</span><span class="n">arity</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">subspace</span><span class="p">)</span>
            <span class="n">out_fn</span> <span class="o">=</span> <span class="n">_build_setitem</span><span class="p">(</span><span class="n">arity</span><span class="p">,</span> <span class="n">out_fn</span><span class="p">,</span> <span class="n">post_fn</span><span class="p">,</span> <span class="n">field</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">out_fn</span>

    <span class="k">def</span> <span class="nf">_dispatch</span><span class="p">(</span>
            <span class="n">post_fn_0</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">StructNested</span><span class="p">[</span><span class="n">ValueT</span><span class="p">]]],</span>
            <span class="n">post_fn_1</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[</span>
                <span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">DataNested</span><span class="p">]],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">StructNested</span><span class="p">[</span><span class="n">ValueT</span><span class="p">]]],</span>
            <span class="o">*</span><span class="n">delayed</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">DataNested</span><span class="p">]]</span>
            <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">StructNested</span><span class="p">[</span><span class="n">ValueT</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Internal method for handling unknown arity at generation-time.</span>

<span class="sd">        :param post_fn_0: Nullary specialized map callable.</span>
<span class="sd">        :param post_fn_1: Unary specialized map callable.</span>
<span class="sd">        :param delayed: Optional nested data structure any provided at runtime.</span>

<span class="sd">        :returns: Specialized map callable of dynamic arity.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">delayed</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">post_fn_0</span><span class="p">()</span>
        <span class="p">(</span><span class="n">arg</span><span class="p">,)</span> <span class="o">=</span> <span class="n">delayed</span>
        <span class="k">return</span> <span class="n">post_fn_1</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>

    <span class="c1"># Check that the combination of input arguments are valid</span>
    <span class="k">if</span> <span class="n">space</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;At least data or space must be specified.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">arity</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="kc">None</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Arity must be either 0, 1 or `None`.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="n">partial</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Transform function cannot be &#39;partial&#39; instance.&quot;</span><span class="p">)</span>

    <span class="c1"># Generate transform and reduce callable of various arity if necessary</span>
    <span class="n">all_fn</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">arity</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">arity</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="n">all_fn</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">_build_map</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">space</span><span class="p">)</span>

    <span class="c1"># Return callable of requested arity if specified, dynamic dispatch if not</span>
    <span class="k">if</span> <span class="n">arity</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">partial</span><span class="p">(</span><span class="n">_dispatch</span><span class="p">,</span> <span class="o">*</span><span class="n">all_fn</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">all_fn</span><span class="p">[</span><span class="n">arity</span><span class="p">]</span></div>



<div class="viewcode-block" id="build_copyto">
<a class="viewcode-back" href="../../../../api/gym_jiminy/common/utils/spaces.html#gym_jiminy.common.utils.spaces.build_copyto">[docs]</a>
<span class="k">def</span> <span class="nf">build_copyto</span><span class="p">(</span><span class="n">dst</span><span class="p">:</span> <span class="n">DataNested</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">DataNested</span><span class="p">],</span> <span class="kc">None</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Generate specialized `copyto` method for a given pre-allocated</span>
<span class="sd">    destination.</span>

<span class="sd">    Note that the key ordering of source and destination data structures do NOT</span>
<span class="sd">    have to match, only the hierarchy has to be the same. Beside, additional</span>
<span class="sd">    subtrees of the output data structure will be ignored if any.</span>

<span class="sd">    :param dst: Nested data structure to be updated.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Special case if parent is not a container</span>
    <span class="n">dst_type</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">dst</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">issubclass_mapping</span><span class="p">(</span><span class="n">dst_type</span><span class="p">)</span> <span class="ow">or</span>
            <span class="n">tree</span><span class="o">.</span><span class="n">issubclass_sequence</span><span class="p">(</span><span class="n">dst_type</span><span class="p">)):</span>
        <span class="k">return</span> <span class="n">partial</span><span class="p">(</span><span class="n">array_copyto</span><span class="p">,</span> <span class="n">dst</span><span class="p">)</span>

    <span class="c1"># Build specialized flattening method, appending all leaves in a buffer</span>
    <span class="n">src_flat</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">flatten</span> <span class="o">=</span> <span class="n">build_reduce</span><span class="p">(</span>
        <span class="n">src_flat</span><span class="o">.</span><span class="n">append</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="p">(),</span> <span class="n">dst</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">forward_bounds</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="c1"># Flatten the nested data structure to update on-the-spot for efficiency</span>
    <span class="n">dst_flat</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">dst</span><span class="p">)</span>

    <span class="c1"># Define helper that gathers all operations</span>
    <span class="k">def</span> <span class="nf">_flatten_and_copyto</span><span class="p">(</span><span class="n">src_flat</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span>
                            <span class="n">flatten</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">DataNested</span><span class="p">],</span> <span class="kc">None</span><span class="p">],</span>
                            <span class="n">dst_flat</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span>
                            <span class="n">src</span><span class="p">:</span> <span class="n">DataNested</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Internal method that flattens the input data structure before</span>
<span class="sd">        copying data from source to destination all at once.</span>

<span class="sd">        :param src_flat: Buffer storing the result of the specialized</span>
<span class="sd">                         flattening operator.</span>
<span class="sd">        :param flatten: Flattening operator specialized for a given output data</span>
<span class="sd">                        structure.</span>
<span class="sd">        :param src_flat: Pre-computed flattened output data structure.</span>
<span class="sd">        :param src: Nested input data structure whose output data structure is</span>
<span class="sd">                    a subtree.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Populate buffer with flattened input data structure</span>
        <span class="n">src_flat</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="n">flatten</span><span class="p">(</span><span class="n">src</span><span class="p">)</span>

        <span class="c1"># Copy from source to destination all arrays at once</span>
        <span class="n">multi_array_copyto</span><span class="p">(</span><span class="n">dst_flat</span><span class="p">,</span> <span class="n">src_flat</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">partial</span><span class="p">(</span><span class="n">_flatten_and_copyto</span><span class="p">,</span> <span class="n">src_flat</span><span class="p">,</span> <span class="n">flatten</span><span class="p">,</span> <span class="n">dst_flat</span><span class="p">)</span></div>



<div class="viewcode-block" id="build_clip">
<a class="viewcode-back" href="../../../../api/gym_jiminy/common/utils/spaces.html#gym_jiminy.common.utils.spaces.build_clip">[docs]</a>
<span class="k">def</span> <span class="nf">build_clip</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="n">DataNested</span><span class="p">,</span>
               <span class="n">space</span><span class="p">:</span> <span class="n">gym</span><span class="o">.</span><span class="n">Space</span><span class="p">[</span><span class="n">DataNested</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Callable</span><span class="p">[[],</span> <span class="n">DataNested</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Generate specialized `clip` method for some pre-allocated nested data</span>
<span class="sd">    structure and corresponding space.</span>

<span class="sd">    :param data: Nested data structure whose leaves must be clipped.</span>
<span class="sd">    :param space: `gym.Space` on which to operate.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">build_map</span><span class="p">(</span><span class="n">_array_clip</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">space</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span></div>



<div class="viewcode-block" id="build_contains">
<a class="viewcode-back" href="../../../../api/gym_jiminy/common/utils/spaces.html#gym_jiminy.common.utils.spaces.build_contains">[docs]</a>
<span class="k">def</span> <span class="nf">build_contains</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="n">DataNested</span><span class="p">,</span>
                   <span class="n">space</span><span class="p">:</span> <span class="n">gym</span><span class="o">.</span><span class="n">Space</span><span class="p">[</span><span class="n">DataNested</span><span class="p">],</span>
                   <span class="n">tol_abs</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
                   <span class="n">tol_rel</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Callable</span><span class="p">[[],</span> <span class="nb">bool</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Generate specialized `contains` method for some pre-allocated nested</span>
<span class="sd">    data structure and corresponding space.</span>

<span class="sd">    :param data: Pre-allocated nested data structure whose leaves must be</span>
<span class="sd">                 within bounds if defined and ignored otherwise.</span>
<span class="sd">    :param space: `gym.Space` on which to operate.</span>
<span class="sd">    :param tol_abs: Absolute tolerance for floating point equality check.</span>
<span class="sd">                    Optional: `0.0` by default.</span>
<span class="sd">    :param tol_rel: Relative tolerance for floating point aprox equality check.</span>
<span class="sd">                    Optional: `0.0` by default.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Define a special exception involved in short-circuit mechanism</span>
    <span class="k">class</span> <span class="nc">ShortCircuitContains</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Internal exception involved in short-circuit mechanism.</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="nd">@nb</span><span class="o">.</span><span class="n">jit</span><span class="p">(</span><span class="n">nopython</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">_contains_or_raises</span><span class="p">(</span><span class="n">value</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                            <span class="n">low</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ArrayOrScalar</span><span class="p">],</span>
                            <span class="n">high</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ArrayOrScalar</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Thin wrapper around original `_array_contains` method to raise</span>
<span class="sd">        an exception if the test fails. It enables short-circuit mechanism</span>
<span class="sd">        to abort checking remaining leaves if any.</span>

<span class="sd">        Short-circuit mechanism not only speeds-up scenarios where at least one</span>
<span class="sd">        leaf does not met requirements and also the other scenarios where all</span>
<span class="sd">        tests passes since it is no longer necessary to specify the reduction</span>
<span class="sd">        operator &#39;operator.and&#39; to keep track of the result.</span>

<span class="sd">        :param value: Array holding values to check.</span>
<span class="sd">        :param low: Lower bound.</span>
<span class="sd">        :param high: Upper bound.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">_array_contains</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">low</span><span class="p">,</span> <span class="n">high</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">ShortCircuitContains</span><span class="p">(</span><span class="s2">&quot;Short-circuit exception.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">_exception_handling</span><span class="p">(</span><span class="n">out_fn</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[],</span> <span class="nb">bool</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Internal method for short-circuit exception handling.</span>

<span class="sd">        :param out_fn: specialized contain callable raising short-circuit</span>
<span class="sd">                        exception as soon as one leaf fails the test.</span>

<span class="sd">        :returns: `True` if all leaves are within bounds of their</span>
<span class="sd">                    respective space, `False` otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">out_fn</span><span class="p">()</span>
        <span class="k">except</span> <span class="n">ShortCircuitContains</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">return</span> <span class="n">partial</span><span class="p">(</span><span class="n">_exception_handling</span><span class="p">,</span> <span class="n">build_reduce</span><span class="p">(</span>
        <span class="n">_contains_or_raises</span><span class="p">,</span>
        <span class="kc">None</span><span class="p">,</span>
        <span class="p">(</span><span class="n">data</span><span class="p">,),</span>
        <span class="n">space</span><span class="p">,</span>
        <span class="n">arity</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="n">forward_bounds</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">tol_abs</span><span class="o">=</span><span class="n">tol_abs</span><span class="p">,</span>
        <span class="n">tol_rel</span><span class="o">=</span><span class="n">tol_rel</span><span class="p">))</span></div>



<div class="viewcode-block" id="build_normalize">
<a class="viewcode-back" href="../../../../api/gym_jiminy/common/utils/spaces.html#gym_jiminy.common.utils.spaces.build_normalize">[docs]</a>
<span class="k">def</span> <span class="nf">build_normalize</span><span class="p">(</span><span class="n">space</span><span class="p">:</span> <span class="n">gym</span><span class="o">.</span><span class="n">Space</span><span class="p">[</span><span class="n">DataNested</span><span class="p">],</span>
                    <span class="n">dst</span><span class="p">:</span> <span class="n">DataNested</span><span class="p">,</span>
                    <span class="n">src</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">DataNested</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                    <span class="o">*</span><span class="p">,</span>
                    <span class="n">ignore_unbounded</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                    <span class="n">is_reversed</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Generate a normalization or de-normalization method specialized for a</span>
<span class="sd">    given pre-allocated destination.</span>

<span class="sd">    .. note::</span>
<span class="sd">        The generated method applies element-wise de-normalization to all</span>
<span class="sd">        elements of the leaf spaces having finite bounds. For those that does</span>
<span class="sd">        not, it simply copies the value from &#39;src&#39; to &#39;dst&#39;.</span>

<span class="sd">    .. warning::</span>
<span class="sd">        This method requires all leaf spaces to have type `gym.spaces.Box`</span>
<span class="sd">        with dtype &#39;np.floating&#39;.</span>

<span class="sd">    :param dst: Nested data structure to updated.</span>
<span class="sd">    :param space: Original (de-normalized) `gym.Space` on which to operate.</span>
<span class="sd">    :param src: Normalized nested data if &#39;is_reversed&#39; is True, original data</span>
<span class="sd">                (de-normalized) otherwise. `None` to pass it at runtime.</span>
<span class="sd">                Optional: `None` by default.</span>
<span class="sd">    :param is_reversed: True to de-normalize, False to normalize.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nd">@nb</span><span class="o">.</span><span class="n">jit</span><span class="p">(</span><span class="n">nopython</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">_array_normalize</span><span class="p">(</span><span class="n">dst</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                         <span class="n">src</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                         <span class="n">low</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                         <span class="n">high</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                         <span class="n">is_reversed</span><span class="p">:</span> <span class="nb">bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Element-wise normalization or de-normalization of array.</span>

<span class="sd">        :param dst: Pre-allocated array into which the result must be stored.</span>
<span class="sd">        :param src: Input array.</span>
<span class="sd">        :param low: Lower bound.</span>
<span class="sd">        :param high: Upper bound.</span>
<span class="sd">        :param is_reversed: True to de-normalize, False to normalize.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">lo</span><span class="p">,</span> <span class="n">hi</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">low</span><span class="o">.</span><span class="n">flat</span><span class="p">,</span> <span class="n">high</span><span class="o">.</span><span class="n">flat</span><span class="p">,</span> <span class="n">src</span><span class="o">.</span><span class="n">flat</span><span class="p">)):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">lo</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">hi</span><span class="p">):</span>
                <span class="n">dst</span><span class="o">.</span><span class="n">flat</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
            <span class="k">elif</span> <span class="n">is_reversed</span><span class="p">:</span>
                <span class="n">dst</span><span class="o">.</span><span class="n">flat</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">lo</span> <span class="o">+</span> <span class="n">hi</span> <span class="o">-</span> <span class="n">val</span> <span class="o">*</span> <span class="p">(</span><span class="n">lo</span> <span class="o">-</span> <span class="n">hi</span><span class="p">))</span> <span class="o">/</span> <span class="mi">2</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">dst</span><span class="o">.</span><span class="n">flat</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">lo</span> <span class="o">+</span> <span class="n">hi</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">val</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">lo</span> <span class="o">-</span> <span class="n">hi</span><span class="p">)</span>

    <span class="c1"># Make sure that all leaves are `gym.space.Box` with `floating` dtype</span>
    <span class="k">for</span> <span class="n">subspace</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">space</span><span class="p">):</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">subspace</span><span class="p">,</span> <span class="n">gym</span><span class="o">.</span><span class="n">spaces</span><span class="o">.</span><span class="n">Box</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">subspace</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">floating</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">ignore_unbounded</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">subspace</span><span class="o">.</span><span class="n">is_bounded</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                <span class="s2">&quot;All leaf spaces must be bounded if `ignore_unbounded=False`.&quot;</span><span class="p">)</span>

    <span class="n">dataset</span> <span class="o">=</span> <span class="p">[</span><span class="n">dst</span><span class="p">,]</span>
    <span class="k">if</span> <span class="n">src</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">dataset</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">src</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">build_reduce</span><span class="p">(</span>
        <span class="n">_array_normalize</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">dataset</span><span class="p">,</span> <span class="n">space</span><span class="p">,</span> <span class="mi">2</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">dataset</span><span class="p">),</span> <span class="n">is_reversed</span><span class="p">)</span></div>



<div class="viewcode-block" id="build_flatten">
<a class="viewcode-back" href="../../../../api/gym_jiminy/common/utils/spaces.html#gym_jiminy.common.utils.spaces.build_flatten">[docs]</a>
<span class="k">def</span> <span class="nf">build_flatten</span><span class="p">(</span><span class="n">data_nested</span><span class="p">:</span> <span class="n">DataNested</span><span class="p">,</span>
                  <span class="n">data_flat</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">DataNested</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                  <span class="o">*</span><span class="p">,</span>
                  <span class="n">order</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;F&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;C&#39;</span><span class="p">,</span>
                  <span class="n">is_reversed</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
                  <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Generate a flattening or un-flattening method specialized for some</span>
<span class="sd">    pre-allocated nested data.</span>

<span class="sd">    .. note::</span>
<span class="sd">        Multi-dimensional leaf spaces are supported. Values will be flattened</span>
<span class="sd">        in 1D vectors using &#39;C&#39; order (row-major). It ignores the actual memory</span>
<span class="sd">        layout the leaves of &#39;data_nested&#39; and they are not required to have</span>
<span class="sd">        the same dtype as &#39;data_flat&#39;.</span>

<span class="sd">    :param data_nested: Nested data structure.</span>
<span class="sd">    :param data_flat: Flat array consistent with the nested data structure.</span>
<span class="sd">                      Optional iif `is_reversed` is `True`.</span>
<span class="sd">                      Optional: `None` by default.</span>
<span class="sd">    :param order: Order in which the elements of multi-dimensional arrays are</span>
<span class="sd">                  sorted into the flattened vector. See &#39;numpy.ravel&#39;</span>
<span class="sd">                  documentation for details. Only &#39;C&#39; and &#39;F&#39; are supported.</span>
<span class="sd">                  Optiona: &#39;C&#39; by default.</span>
<span class="sd">    :param is_reversed: True to update &#39;data_flat&#39; (flattening), &#39;data_nested&#39;</span>
<span class="sd">                        otherwise (un-flattening).</span>
<span class="sd">                        Optional: True if &#39;data_flat&#39; is specified, False</span>
<span class="sd">                        otherwise.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Make sure that the input arguments are valid</span>
    <span class="k">if</span> <span class="n">is_reversed</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">is_reversed</span> <span class="o">=</span> <span class="n">data_flat</span> <span class="ow">is</span> <span class="kc">None</span>
    <span class="k">assert</span> <span class="n">is_reversed</span> <span class="ow">or</span> <span class="n">data_flat</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">order</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;F&#39;</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Order must be &#39;C&#39; or &#39;F&#39;.&quot;</span><span class="p">)</span>

    <span class="c1"># Flatten nested data while preserving leaves ordering</span>
    <span class="n">data_leaves</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">data_nested</span><span class="p">)</span>

    <span class="c1"># Compute slices to split destination in accordance with nested data.</span>
    <span class="c1"># It will be passed to `build_reduce` as an input dataset. It is kind of</span>
    <span class="c1"># hacky since only passing `DataNested` instances is officially supported,</span>
    <span class="c1"># but it is currently the easiest way to keep track of some internal state</span>
    <span class="c1"># and specify leaf-specific constants.</span>
    <span class="n">start_indices</span><span class="p">,</span> <span class="n">stop_indices</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
    <span class="n">idx_start</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">data</span> <span class="ow">in</span> <span class="n">data_leaves</span><span class="p">:</span>
        <span class="n">idx_end</span> <span class="o">=</span> <span class="n">idx_start</span> <span class="o">+</span> <span class="nb">max</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">start_indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">idx_start</span><span class="p">)</span>
        <span class="n">stop_indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">idx_end</span><span class="p">)</span>
        <span class="n">idx_start</span> <span class="o">=</span> <span class="n">idx_end</span>

    <span class="nd">@nb</span><span class="o">.</span><span class="n">jit</span><span class="p">(</span><span class="n">nopython</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">fastmath</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">_flatten_nd</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                    <span class="n">idx_start</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
                    <span class="n">data_flat</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                    <span class="n">is_fortran</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
                    <span class="n">is_reversed</span><span class="p">:</span> <span class="nb">bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Synchronize the flatten and un-flatten representation of the data</span>
<span class="sd">        associated with the same leaf space.</span>

<span class="sd">        Generic implementation flattening multi-dimensional arrays by copying</span>
<span class="sd">        from source to destination element-by-element without vectorization.</span>

<span class="sd">        :param data: Multi-dimensional array that will be either updated or</span>
<span class="sd">                     copied as a whole depending on &#39;is_reversed&#39;.</span>
<span class="sd">        :param idx_start: First index of the slice of &#39;data_flat&#39; to</span>
<span class="sd">                          synchronized with &#39;data&#39;.</span>
<span class="sd">        :param data_flat: 1D array from which to extract that will be either</span>
<span class="sd">                          updated or copied depending on &#39;is_reversed&#39;.</span>
<span class="sd">        :param is_fortran: Order in which the elements of multi-dimensional</span>
<span class="sd">                           arrays are sorted into the flattened vector.</span>
<span class="sd">        :param is_reversed: True to update the multi-dimensional array &#39;data&#39;</span>
<span class="sd">                            by copying the value from slice &#39;flat_slice&#39; of</span>
<span class="sd">                            vector &#39;data_flat&#39;, False for doing the contrary.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Note that passing string or slices as input argument is very slow</span>
        <span class="c1"># in numba. Moreover, assignment does not appear to be vectorized, so</span>
        <span class="c1"># looping element-by-element should be equally fast than directly</span>
        <span class="c1"># assigning the whole flattened view of ND-array whenever possible.</span>
        <span class="k">if</span> <span class="n">is_reversed</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">is_fortran</span><span class="p">:</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="n">idx_start</span>
                <span class="k">for</span> <span class="n">multi_index</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">ndindex</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">shape</span><span class="p">):</span>
                    <span class="n">data</span><span class="p">[</span><span class="n">multi_index</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">data_flat</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
                    <span class="n">idx</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="n">idx_start</span>
                <span class="k">for</span> <span class="n">multi_index</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">ndindex</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">):</span>
                    <span class="n">data</span><span class="p">[</span><span class="n">multi_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">data_flat</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
                    <span class="n">idx</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">is_fortran</span><span class="p">:</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="n">idx_start</span>
                <span class="k">for</span> <span class="n">multi_index</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">ndindex</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">shape</span><span class="p">):</span>
                    <span class="n">data_flat</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">multi_index</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
                    <span class="n">idx</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="n">idx_start</span>
                <span class="k">for</span> <span class="n">multi_index</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">ndindex</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">):</span>
                    <span class="n">data_flat</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">multi_index</span><span class="p">]</span>
                    <span class="n">idx</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">_flatten</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                 <span class="n">idx_start</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
                 <span class="n">idx_end</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
                 <span class="n">data_flat</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                 <span class="n">is_fortran</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
                 <span class="n">is_reversed</span><span class="p">:</span> <span class="nb">bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Synchronize the flatten and un-flatten representation of the data</span>
<span class="sd">        associated with the same leaf space.</span>

<span class="sd">        In practice, it assigns the value of a 1D array slice to some multi-</span>
<span class="sd">        dimensional array, or the other way around.</span>

<span class="sd">        :param data: Multi-dimensional array that will be either updated or</span>
<span class="sd">                     copied as a whole depending on &#39;is_reversed&#39;.</span>
<span class="sd">        :param idx_start: First index of the slice of &#39;data_flat&#39; to</span>
<span class="sd">                          synchronized with &#39;data&#39;.</span>
<span class="sd">        :param idx_end: One-after-last index of the slice of &#39;data_flat&#39; to</span>
<span class="sd">                        synchronized with &#39;data&#39;.</span>
<span class="sd">        :param data_flat: 1D array from which to extract that will be either</span>
<span class="sd">                          updated or copied depending on &#39;is_reversed&#39;.</span>
<span class="sd">        :param is_fortran: Order in which the elements of multi-dimensional</span>
<span class="sd">                           arrays are sorted into the flattened vector.</span>
<span class="sd">        :param is_reversed: True to update the multi-dimensional array &#39;data&#39;</span>
<span class="sd">                            by copying the value from slice &#39;flat_slice&#39; of</span>
<span class="sd">                            vector &#39;data_flat&#39;, False for doing the contrary.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Deal with special cases allowing fast vectorized implementation</span>
        <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">is_reversed</span><span class="p">:</span>
                <span class="n">array_copyto</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">data_flat</span><span class="p">[</span><span class="n">idx_start</span><span class="p">:</span><span class="n">idx_end</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">array_copyto</span><span class="p">(</span><span class="n">data_flat</span><span class="p">[</span><span class="n">idx_start</span><span class="p">:</span><span class="n">idx_end</span><span class="p">],</span> <span class="n">data</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="c1"># General case looping over each element individually</span>
        <span class="n">_flatten_nd</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">idx_start</span><span class="p">,</span> <span class="n">data_flat</span><span class="p">,</span> <span class="n">is_fortran</span><span class="p">,</span> <span class="n">is_reversed</span><span class="p">)</span>

    <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="n">order</span> <span class="o">==</span> <span class="s1">&#39;F&#39;</span><span class="p">,</span> <span class="n">is_reversed</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">data_flat</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="n">data_flat</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>  <span class="c1"># type: ignore[assignment]</span>
    <span class="n">arity</span> <span class="o">=</span> <span class="mi">3</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
    <span class="n">out_fn</span> <span class="o">=</span> <span class="n">build_reduce</span><span class="p">(</span><span class="n">_flatten</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="p">(</span>
        <span class="n">data_leaves</span><span class="p">,</span> <span class="n">start_indices</span><span class="p">,</span> <span class="n">stop_indices</span><span class="p">),</span> <span class="kc">None</span><span class="p">,</span> <span class="n">arity</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">data_flat</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">_repeat</span><span class="p">(</span><span class="n">out_fn</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">DataNested</span><span class="p">],</span> <span class="kc">None</span><span class="p">],</span>
                    <span class="n">n_leaves</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
                    <span class="n">delayed</span><span class="p">:</span> <span class="n">DataNested</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;Dispatch flattened data provided at runtime to each transform</span>
<span class="sd">            &#39;_flatten&#39; specialized for all leaves of the original nested space.</span>

<span class="sd">            In practice, it simply repeats the flattened data as many times as</span>
<span class="sd">            the number of leaves of the original nested space before passing</span>
<span class="sd">            them altogether in a tuple as input argument of a function.</span>

<span class="sd">            :param out_fn: Flattening or un-flattening method already</span>
<span class="sd">                           specialized for a given pre-allocated nested data.</span>
<span class="sd">            :param n_leaves: Total number of leaves in original nested space.</span>
<span class="sd">            :param delayed: Flattened data provided at runtime.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">out_fn</span><span class="p">((</span><span class="n">delayed</span><span class="p">,)</span> <span class="o">*</span> <span class="n">n_leaves</span><span class="p">)</span>

        <span class="n">out_fn</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">_repeat</span><span class="p">,</span> <span class="n">out_fn</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">data_leaves</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">out_fn</span></div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2020, Alexis Duburcq - MIT licence.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>