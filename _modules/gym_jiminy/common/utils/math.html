

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>gym_jiminy.common.utils.math &mdash; jiminy 1.8.12 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../../../../_static/css/theme.css?v=e59714d7" />

  
      <script src="../../../../_static/documentation_options.js?v=32cf9813"></script>
      <script src="../../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../../index.html" class="icon icon-home">
            jiminy
              <img src="../../../../_static/jiminy_logo.svg" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">README</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../README.html">Key features</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../README.html#gym-jiminy">Gym Jiminy</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../README.html#demo">Demo</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../README.html#getting-started">Getting started</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">INSTALLATION</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../INSTALL.html">Easy-install on Ubuntu 18+</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../INSTALL.html#building-from-source">Building from source</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">TUTORIALS</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../tutorial.html">An introduction to Jiminy</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">API DOC</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/jiminy/index.html">Jiminy C++ API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/jiminy_py/index.html">Jiminy Python API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/gym_jiminy/common/index.html">Gym Jiminy API</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Technical Specifications</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../spec/src/tlmc_format_specification.html">HDF5 telemetry log format (TLMC)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../spec/pdf/index.html">Downloadable PDF</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../index.html">jiminy</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">gym_jiminy.common.utils.math</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for gym_jiminy.common.utils.math</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Mathematic utilities heavily optimized for speed.</span>

<span class="sd">They combine batch-processing with Just-In-Time (JIT) compiling via Numba when</span>
<span class="sd">possible for optimal performance. Most of them are dealing with rotations (SO3)</span>
<span class="sd">to perform transformations or convert from one representation to another.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Literal</span><span class="p">,</span> <span class="n">no_type_check</span><span class="p">,</span> <span class="n">overload</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">numba</span> <span class="k">as</span> <span class="nn">nb</span>

<span class="kn">from</span> <span class="nn">.spaces</span> <span class="kn">import</span> <span class="n">ArrayOrScalar</span>


<span class="n">TWIST_SWING_SINGULAR_THR</span> <span class="o">=</span> <span class="mf">1e-5</span>


<span class="nd">@nb</span><span class="o">.</span><span class="n">jit</span><span class="p">(</span><span class="n">nopython</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">fastmath</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">inline</span><span class="o">=</span><span class="s1">&#39;always&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_mean</span><span class="p">(</span><span class="n">array</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute the arithmetic mean over flattened array.</span>

<span class="sd">    :param array: Input array.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>


<span class="nd">@nb</span><span class="o">.</span><span class="n">jit</span><span class="p">(</span><span class="n">nopython</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">fastmath</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">inline</span><span class="o">=</span><span class="s1">&#39;always&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_mean_axis</span><span class="p">(</span><span class="n">array</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute the arithmetic mean along a given axis.</span>

<span class="sd">    :param array: Input array.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span> <span class="o">/</span> <span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>


<span class="nd">@overload</span>
<span class="k">def</span> <span class="nf">mean</span><span class="p">(</span><span class="n">array</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="o">...</span>


<span class="nd">@overload</span>
<span class="k">def</span> <span class="nf">mean</span><span class="p">(</span><span class="n">array</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="o">...</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
    <span class="o">...</span>


<div class="viewcode-block" id="mean">
<a class="viewcode-back" href="../../../../api/gym_jiminy/common/utils/math.html#gym_jiminy.common.utils.math.mean">[docs]</a>
<span class="k">def</span> <span class="nf">mean</span><span class="p">(</span><span class="n">array</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
         <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute the arithmetic mean along the specified axis if specified, over</span>
<span class="sd">    the flattened array otherwise.</span>

<span class="sd">    :param array: Input array.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_mean</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_mean_axis</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span></div>



<span class="nd">@overload</span>
<span class="k">def</span> <span class="nf">matrix_to_yaw</span><span class="p">(</span><span class="n">mat</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="o">...</span>


<span class="nd">@overload</span>
<span class="k">def</span> <span class="nf">matrix_to_yaw</span><span class="p">(</span><span class="n">mat</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="o">...</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="o">...</span>


<div class="viewcode-block" id="matrix_to_yaw">
<a class="viewcode-back" href="../../../../api/gym_jiminy/common/utils/math.html#gym_jiminy.common.utils.math.matrix_to_yaw">[docs]</a>
<span class="nd">@nb</span><span class="o">.</span><span class="n">jit</span><span class="p">(</span><span class="n">nopython</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">matrix_to_yaw</span><span class="p">(</span><span class="n">mat</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                  <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute the yaw from Yaw-Pitch-Roll Euler angles representation of a</span>
<span class="sd">    rotation matrix in 3D Euclidean space.</span>

<span class="sd">    :param mat: N-dimensional array whose first and second dimensions gathers</span>
<span class="sd">                the 3-by-3 rotation matrix elements.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="n">mat</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;=</span> <span class="mi">2</span>

    <span class="c1"># Allocate memory for the output array</span>
    <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">out_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">mat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">:])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">out</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">mat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span>
        <span class="n">out_</span> <span class="o">=</span> <span class="n">out</span>
    <span class="n">out1d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">out_</span><span class="p">)</span>

    <span class="n">out1d</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">mat</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">mat</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>

    <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">out_</span>
    <span class="k">return</span> <span class="kc">None</span></div>



<div class="viewcode-block" id="quat_to_yaw_cos_sin">
<a class="viewcode-back" href="../../../../api/gym_jiminy/common/utils/math.html#gym_jiminy.common.utils.math.quat_to_yaw_cos_sin">[docs]</a>
<span class="nd">@nb</span><span class="o">.</span><span class="n">jit</span><span class="p">(</span><span class="n">nopython</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">inline</span><span class="o">=</span><span class="s1">&#39;always&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">quat_to_yaw_cos_sin</span><span class="p">(</span><span class="n">quat</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute cosine and sine of the yaw from Yaw-Pitch-Roll Euler angles</span>
<span class="sd">    representation of a single or a batch of quaternions.</span>

<span class="sd">    :param quat: N-dimensional array whose first dimension gathers the 4</span>
<span class="sd">                 quaternion coordinates (qx, qy, qz, qw).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="n">quat</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;=</span> <span class="mi">1</span>
    <span class="p">(</span><span class="n">q_xy</span><span class="p">,</span> <span class="n">q_yy</span><span class="p">),</span> <span class="p">(</span><span class="n">q_zz</span><span class="p">,</span> <span class="n">q_zw</span><span class="p">)</span> <span class="o">=</span> <span class="n">quat</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">]</span> <span class="o">*</span> <span class="n">quat</span><span class="p">[</span><span class="o">-</span><span class="mi">4</span><span class="p">:</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span> <span class="n">quat</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">quat</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:]</span>
    <span class="n">cos_yaw</span><span class="p">,</span> <span class="n">sin_yaw</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">q_yy</span> <span class="o">+</span> <span class="n">q_zz</span><span class="p">),</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">q_xy</span> <span class="o">+</span> <span class="n">q_zw</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">cos_yaw</span><span class="p">,</span> <span class="n">sin_yaw</span></div>



<span class="nd">@overload</span>
<span class="k">def</span> <span class="nf">quat_to_yaw</span><span class="p">(</span><span class="n">quat</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="o">...</span>


<span class="nd">@overload</span>
<span class="k">def</span> <span class="nf">quat_to_yaw</span><span class="p">(</span><span class="n">quat</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="o">...</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="o">...</span>


<div class="viewcode-block" id="quat_to_yaw">
<a class="viewcode-back" href="../../../../api/gym_jiminy/common/utils/math.html#gym_jiminy.common.utils.math.quat_to_yaw">[docs]</a>
<span class="nd">@nb</span><span class="o">.</span><span class="n">jit</span><span class="p">(</span><span class="n">nopython</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">quat_to_yaw</span><span class="p">(</span><span class="n">quat</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute the yaw from Yaw-Pitch-Roll Euler angles representation of a</span>
<span class="sd">    single or a batch of quaternions.</span>

<span class="sd">    :param quat: N-dimensional array whose first dimension gathers the 4</span>
<span class="sd">                 quaternion coordinates (qx, qy, qz, qw).</span>
<span class="sd">    :param out: Pre-allocated array in which to store the result. If not</span>
<span class="sd">                provided, a new array is freshly-allocated and returned, which</span>
<span class="sd">                is slower.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="n">quat</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;=</span> <span class="mi">1</span>

    <span class="c1"># Allocate memory for the output array</span>
    <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">out_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">quat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">out</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">quat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="n">out_</span> <span class="o">=</span> <span class="n">out</span>
    <span class="n">out1d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">out_</span><span class="p">)</span>

    <span class="n">cos_yaw</span><span class="p">,</span> <span class="n">sin_yaw</span> <span class="o">=</span> <span class="n">quat_to_yaw_cos_sin</span><span class="p">(</span><span class="n">quat</span><span class="p">)</span>
    <span class="n">out1d</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">sin_yaw</span><span class="p">,</span> <span class="n">cos_yaw</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">out_</span>
    <span class="k">return</span> <span class="kc">None</span></div>



<span class="nd">@overload</span>
<span class="k">def</span> <span class="nf">quat_to_rpy</span><span class="p">(</span><span class="n">quat</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="o">...</span>


<span class="nd">@overload</span>
<span class="k">def</span> <span class="nf">quat_to_rpy</span><span class="p">(</span><span class="n">quat</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="o">...</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="o">...</span>


<div class="viewcode-block" id="quat_to_rpy">
<a class="viewcode-back" href="../../../../api/gym_jiminy/common/utils/math.html#gym_jiminy.common.utils.math.quat_to_rpy">[docs]</a>
<span class="nd">@nb</span><span class="o">.</span><span class="n">jit</span><span class="p">(</span><span class="n">nopython</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">quat_to_rpy</span><span class="p">(</span><span class="n">quat</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute the Yaw-Pitch-Roll Euler angles representation of a single or a</span>
<span class="sd">    batch of quaternions.</span>

<span class="sd">    The Roll, Pitch and Yaw angles are guaranteed to be within range [-pi,pi],</span>
<span class="sd">    [-pi/2,pi/2], [-pi,pi], respectively.</span>

<span class="sd">    :param quat: N-dimensional array whose first dimension gathers the 4</span>
<span class="sd">                 quaternion coordinates (qx, qy, qz, qw).</span>
<span class="sd">    :param out: Pre-allocated array in which to store the result. If not</span>
<span class="sd">                provided, a new array is freshly-allocated and returned, which</span>
<span class="sd">                is slower.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Allocate memory for the output array</span>
    <span class="k">assert</span> <span class="n">quat</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;=</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">out_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="o">*</span><span class="n">quat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">out</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="o">*</span><span class="n">quat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
        <span class="n">out_</span> <span class="o">=</span> <span class="n">out</span>

    <span class="c1"># Compute some intermediary quantities</span>
    <span class="n">q_xx</span><span class="p">,</span> <span class="n">q_xy</span><span class="p">,</span> <span class="n">q_xz</span><span class="p">,</span> <span class="n">q_xw</span> <span class="o">=</span> <span class="n">quat</span><span class="p">[</span><span class="o">-</span><span class="mi">4</span><span class="p">]</span> <span class="o">*</span> <span class="n">quat</span><span class="p">[</span><span class="o">-</span><span class="mi">4</span><span class="p">:]</span>
    <span class="n">q_yy</span><span class="p">,</span> <span class="n">q_yz</span><span class="p">,</span> <span class="n">q_yw</span> <span class="o">=</span> <span class="n">quat</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">]</span> <span class="o">*</span> <span class="n">quat</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">:]</span>
    <span class="n">q_zz</span><span class="p">,</span> <span class="n">q_zw</span> <span class="o">=</span> <span class="n">quat</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">quat</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:]</span>
    <span class="n">q_ww</span> <span class="o">=</span> <span class="n">quat</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">quat</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="c1"># First-order normalization (by copy) to avoid numerical instabilities</span>
    <span class="n">norm_2_inv</span> <span class="o">=</span> <span class="p">((</span><span class="mf">3.0</span> <span class="o">-</span> <span class="p">(</span><span class="n">q_xx</span> <span class="o">+</span> <span class="n">q_yy</span> <span class="o">+</span> <span class="n">q_zz</span> <span class="o">+</span> <span class="n">q_ww</span><span class="p">))</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">q_yw</span> <span class="o">*=</span> <span class="n">norm_2_inv</span>
    <span class="n">q_xz</span> <span class="o">*=</span> <span class="n">norm_2_inv</span>

    <span class="c1"># Compute Roll, Pitch and Yaw separately</span>
    <span class="c1"># roll, pitch, yaw = out_</span>
    <span class="n">out_</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">q_xw</span> <span class="o">+</span> <span class="n">q_yz</span><span class="p">),</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">q_xx</span> <span class="o">+</span> <span class="n">q_yy</span><span class="p">))</span>
    <span class="n">out_</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">q_yw</span> <span class="o">-</span> <span class="n">q_xz</span><span class="p">)),</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">q_yw</span> <span class="o">-</span> <span class="n">q_xz</span><span class="p">)))</span>
    <span class="n">out_</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">q_zw</span> <span class="o">+</span> <span class="n">q_xy</span><span class="p">),</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">q_yy</span> <span class="o">+</span> <span class="n">q_zz</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">out_</span>
    <span class="k">return</span> <span class="kc">None</span></div>



<span class="nd">@overload</span>
<span class="k">def</span> <span class="nf">quat_to_matrix</span><span class="p">(</span><span class="n">quat</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="o">...</span>


<span class="nd">@overload</span>
<span class="k">def</span> <span class="nf">quat_to_matrix</span><span class="p">(</span><span class="n">quat</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="o">...</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="o">...</span>


<div class="viewcode-block" id="quat_to_matrix">
<a class="viewcode-back" href="../../../../api/gym_jiminy/common/utils/math.html#gym_jiminy.common.utils.math.quat_to_matrix">[docs]</a>
<span class="nd">@nb</span><span class="o">.</span><span class="n">jit</span><span class="p">(</span><span class="n">nopython</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">quat_to_matrix</span><span class="p">(</span><span class="n">quat</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                   <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute the Rotation Matrix representation of a single or a</span>
<span class="sd">    batch of quaternions.</span>

<span class="sd">    :param quat: N-dimensional array whose first dimension gathers the 4</span>
<span class="sd">                 quaternion coordinates (qx, qy, qz, qw).</span>
<span class="sd">    :param out: Pre-allocated array in which to store the result. If not</span>
<span class="sd">                provided, a new array is freshly-allocated and returned, which</span>
<span class="sd">                is slower.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="n">quat</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;=</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">out_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="o">*</span><span class="n">quat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">out</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="o">*</span><span class="n">quat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
        <span class="n">out_</span> <span class="o">=</span> <span class="n">out</span>

    <span class="n">q_xx</span><span class="p">,</span> <span class="n">q_xy</span><span class="p">,</span> <span class="n">q_xz</span><span class="p">,</span> <span class="n">q_xw</span> <span class="o">=</span> <span class="n">quat</span><span class="p">[</span><span class="o">-</span><span class="mi">4</span><span class="p">]</span> <span class="o">*</span> <span class="n">quat</span><span class="p">[</span><span class="o">-</span><span class="mi">4</span><span class="p">:]</span>
    <span class="n">q_yy</span><span class="p">,</span> <span class="n">q_yz</span><span class="p">,</span> <span class="n">q_yw</span> <span class="o">=</span> <span class="n">quat</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">]</span> <span class="o">*</span> <span class="n">quat</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">:]</span>
    <span class="n">q_zz</span><span class="p">,</span> <span class="n">q_zw</span> <span class="o">=</span> <span class="n">quat</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">quat</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:]</span>
    <span class="n">out_</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">q_yy</span> <span class="o">+</span> <span class="n">q_zz</span><span class="p">)</span>
    <span class="n">out_</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">q_xy</span> <span class="o">-</span> <span class="n">q_zw</span><span class="p">)</span>
    <span class="n">out_</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">q_xz</span> <span class="o">+</span> <span class="n">q_yw</span><span class="p">)</span>
    <span class="n">out_</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">q_xy</span> <span class="o">+</span> <span class="n">q_zw</span><span class="p">)</span>
    <span class="n">out_</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">q_xx</span> <span class="o">+</span> <span class="n">q_zz</span><span class="p">)</span>
    <span class="n">out_</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">q_yz</span> <span class="o">-</span> <span class="n">q_xw</span><span class="p">)</span>
    <span class="n">out_</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">q_xz</span> <span class="o">-</span> <span class="n">q_yw</span><span class="p">)</span>
    <span class="n">out_</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">q_yz</span> <span class="o">+</span> <span class="n">q_xw</span><span class="p">)</span>
    <span class="n">out_</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">q_xx</span> <span class="o">+</span> <span class="n">q_yy</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">out_</span>
    <span class="k">return</span> <span class="kc">None</span></div>



<span class="nd">@overload</span>
<span class="k">def</span> <span class="nf">matrix_to_quat</span><span class="p">(</span><span class="n">mat</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="o">...</span>


<span class="nd">@overload</span>
<span class="k">def</span> <span class="nf">matrix_to_quat</span><span class="p">(</span><span class="n">mat</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="o">...</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="o">...</span>


<div class="viewcode-block" id="matrix_to_quat">
<a class="viewcode-back" href="../../../../api/gym_jiminy/common/utils/math.html#gym_jiminy.common.utils.math.matrix_to_quat">[docs]</a>
<span class="nd">@nb</span><span class="o">.</span><span class="n">jit</span><span class="p">(</span><span class="n">nopython</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">matrix_to_quat</span><span class="p">(</span><span class="n">mat</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                   <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute the (qx, qy, qz, qw) Quaternion representation of a single or a</span>
<span class="sd">    batch of rotation matrices.</span>

<span class="sd">    :param mat: N-dimensional array whose first and second dimensions gathers</span>
<span class="sd">                the 3-by-3 rotation matrix elements.</span>
<span class="sd">    :param out: Pre-allocated array in which to store the result. If not</span>
<span class="sd">                provided, a new array is freshly-allocated and returned, which</span>
<span class="sd">                is slower.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="n">mat</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;=</span> <span class="mi">2</span>
    <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">out_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span> <span class="o">*</span><span class="n">mat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">:]))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">out</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="o">*</span><span class="n">mat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">:])</span>
        <span class="n">out_</span> <span class="o">=</span> <span class="n">out</span>

    <span class="c1"># q_x, q_y, q_z, q_w = out_</span>
    <span class="n">out_</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">mat</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">mat</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
    <span class="n">out_</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">mat</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">mat</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">out_</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">mat</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">mat</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
    <span class="n">out_</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">+</span> <span class="n">mat</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">mat</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">mat</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
    <span class="n">out_</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">out_</span><span class="p">),</span> <span class="mi">0</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">out_</span>
    <span class="k">return</span> <span class="kc">None</span></div>



<span class="nd">@overload</span>
<span class="k">def</span> <span class="nf">matrices_to_quat</span><span class="p">(</span><span class="n">mat_list</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span>
                     <span class="n">out</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="o">...</span>


<span class="nd">@overload</span>
<span class="k">def</span> <span class="nf">matrices_to_quat</span><span class="p">(</span><span class="n">mat_list</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span>
                     <span class="n">out</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="o">...</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="o">...</span>


<span class="c1"># TODO: Merge this method with `matrix_to_quat` by leverage compile-time</span>
<span class="c1"># implementation dispatching via `nb.generated_jit` or `nb.overload`.</span>
<div class="viewcode-block" id="matrices_to_quat">
<a class="viewcode-back" href="../../../../api/gym_jiminy/common/utils/math.html#gym_jiminy.common.utils.math.matrices_to_quat">[docs]</a>
<span class="nd">@nb</span><span class="o">.</span><span class="n">jit</span><span class="p">(</span><span class="n">nopython</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">matrices_to_quat</span><span class="p">(</span><span class="n">mat_list</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span>
                     <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute the (qx, qy, qz, qw) Quaternion representation of multiple</span>
<span class="sd">    rotation matrices.</span>

<span class="sd">    .. seealso::</span>
<span class="sd">        See https://math.stackexchange.com/a/3183435.</span>

<span class="sd">    :param mat: Tuple of N arrays corresponding to independent 3D rotation</span>
<span class="sd">                matrices.</span>
<span class="sd">    :param out: Pre-allocated array in which to store the result. If not</span>
<span class="sd">                provided, a new array is freshly-allocated and returned, which</span>
<span class="sd">                is slower.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">out_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">mat_list</span><span class="p">)))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">out</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">mat_list</span><span class="p">))</span>
        <span class="n">out_</span> <span class="o">=</span> <span class="n">out</span>

    <span class="c1"># q_x, q_y, q_z, q_w = out_</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">mat_list</span><span class="p">),))</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">mat</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">mat_list</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">mat</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">mat</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">mat</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]:</span>
                <span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">mat</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">mat</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">mat</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
                <span class="n">out_</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">out_</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">mat</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">mat</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
                <span class="n">out_</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">mat</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">mat</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
                <span class="n">out_</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">mat</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">mat</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">mat</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">mat</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">mat</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
                <span class="n">out_</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">mat</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">mat</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
                <span class="n">out_</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">out_</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">mat</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">mat</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
                <span class="n">out_</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">mat</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">mat</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">mat</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">mat</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]:</span>
                <span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">mat</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">mat</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">mat</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
                <span class="n">out_</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">mat</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">mat</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
                <span class="n">out_</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">mat</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">mat</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
                <span class="n">out_</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">out_</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">mat</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">mat</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">mat</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">mat</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">mat</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
                <span class="n">out_</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">mat</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">mat</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
                <span class="n">out_</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">mat</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">mat</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
                <span class="n">out_</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">mat</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">mat</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
                <span class="n">out_</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="n">out_</span> <span class="o">/=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">out_</span>
    <span class="k">return</span> <span class="kc">None</span></div>



<span class="nd">@overload</span>
<span class="k">def</span> <span class="nf">transforms_to_xyzquat</span><span class="p">(</span>
        <span class="n">transform_list</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> <span class="o">...</span><span class="p">],</span>
        <span class="n">out</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="o">...</span>


<span class="nd">@overload</span>
<span class="k">def</span> <span class="nf">transforms_to_xyzquat</span><span class="p">(</span>
        <span class="n">transform_list</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> <span class="o">...</span><span class="p">],</span>
        <span class="n">out</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="o">...</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="o">...</span>


<div class="viewcode-block" id="transforms_to_xyzquat">
<a class="viewcode-back" href="../../../../api/gym_jiminy/common/utils/math.html#gym_jiminy.common.utils.math.transforms_to_xyzquat">[docs]</a>
<span class="nd">@nb</span><span class="o">.</span><span class="n">jit</span><span class="p">(</span><span class="n">nopython</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">transforms_to_xyzquat</span><span class="p">(</span>
        <span class="n">transform_list</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> <span class="o">...</span><span class="p">],</span>
        <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Stack the translation vector (x, y, z) and the quaternion representation</span>
<span class="sd">    (qx, qy, qz, qw) of the orientation of multiple transform tuples.</span>

<span class="sd">    .. note::</span>
<span class="sd">        Internally, it copies the translation unaffected and convert rotation</span>
<span class="sd">        matrices to quaternions using `matrices_to_quat`.</span>

<span class="sd">    :param transform_list: Tuple of N transforms, each of which represented as</span>
<span class="sd">                           pairs gathering the translation as a vector and the</span>
<span class="sd">                           orientation as a 3D rotation matrix.</span>
<span class="sd">    :param out: Pre-allocated array in which to store the result. If not</span>
<span class="sd">                provided, a new array is freshly-allocated and returned, which</span>
<span class="sd">                is slower.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Allocate memory if necessart</span>
    <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">out_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">7</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">transform_list</span><span class="p">)))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">out2d</span> <span class="o">=</span> <span class="n">out</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="k">if</span> <span class="n">out</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">out</span>
        <span class="k">assert</span> <span class="n">out2d</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">transform_list</span><span class="p">))</span>
        <span class="n">out_</span> <span class="o">=</span> <span class="n">out2d</span>

    <span class="c1"># Simply copy the translation</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">translation</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">transform_list</span><span class="p">):</span>
        <span class="n">out_</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">translation</span>

    <span class="c1"># Convert all rotation matrices to quaternions at once</span>
    <span class="n">rotation_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">rotation</span> <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">rotation</span> <span class="ow">in</span> <span class="n">transform_list</span><span class="p">]</span>
    <span class="n">matrices_to_quat</span><span class="p">(</span><span class="n">rotation_list</span><span class="p">,</span> <span class="n">out_</span><span class="p">[</span><span class="o">-</span><span class="mi">4</span><span class="p">:])</span>  <span class="c1"># type: ignore[call-overload]</span>

    <span class="c1"># Ravel extra dimension before returning if not present initially</span>
    <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">out_</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="n">out</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">out_</span>
    <span class="k">return</span> <span class="kc">None</span></div>



<span class="nd">@overload</span>
<span class="k">def</span> <span class="nf">rpy_to_matrix</span><span class="p">(</span><span class="n">rpy</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="o">...</span>


<span class="nd">@overload</span>
<span class="k">def</span> <span class="nf">rpy_to_matrix</span><span class="p">(</span><span class="n">rpy</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="o">...</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="o">...</span>


<div class="viewcode-block" id="rpy_to_matrix">
<a class="viewcode-back" href="../../../../api/gym_jiminy/common/utils/math.html#gym_jiminy.common.utils.math.rpy_to_matrix">[docs]</a>
<span class="nd">@nb</span><span class="o">.</span><span class="n">jit</span><span class="p">(</span><span class="n">nopython</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">rpy_to_matrix</span><span class="p">(</span><span class="n">rpy</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                  <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute the Rotation Matrix representation of a single or a</span>
<span class="sd">    batch of Yaw-Pitch-Roll Euler angles.</span>

<span class="sd">    :param rpy: N-dimensional array whose first dimension gathers the 3</span>
<span class="sd">                Yaw-Pitch-Roll Euler angles [Roll, Pitch, Yaw].</span>
<span class="sd">    :param out: Pre-allocated array in which to store the result. If not</span>
<span class="sd">                provided, a new array is freshly-allocated and returned, which</span>
<span class="sd">                is slower.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="n">rpy</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;=</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">out_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="o">*</span><span class="n">rpy</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">out</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="o">*</span><span class="n">rpy</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
        <span class="n">out_</span> <span class="o">=</span> <span class="n">out</span>

    <span class="n">cos_roll</span><span class="p">,</span> <span class="n">cos_pitch</span><span class="p">,</span> <span class="n">cos_yaw</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">rpy</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">:])</span>
    <span class="n">sin_roll</span><span class="p">,</span> <span class="n">sin_pitch</span><span class="p">,</span> <span class="n">sin_yaw</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">rpy</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">:])</span>
    <span class="n">out_</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">cos_pitch</span> <span class="o">*</span> <span class="n">cos_yaw</span>
    <span class="n">out_</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span> <span class="n">cos_roll</span> <span class="o">*</span> <span class="n">sin_yaw</span> <span class="o">+</span> <span class="n">sin_roll</span> <span class="o">*</span> <span class="n">sin_pitch</span> <span class="o">*</span> <span class="n">cos_yaw</span>
    <span class="n">out_</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">sin_roll</span> <span class="o">*</span> <span class="n">sin_yaw</span> <span class="o">+</span> <span class="n">cos_roll</span> <span class="o">*</span> <span class="n">sin_pitch</span> <span class="o">*</span> <span class="n">cos_yaw</span>
    <span class="n">out_</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">cos_pitch</span> <span class="o">*</span> <span class="n">sin_yaw</span>
    <span class="n">out_</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">cos_roll</span> <span class="o">*</span> <span class="n">cos_yaw</span> <span class="o">+</span> <span class="n">sin_roll</span> <span class="o">*</span> <span class="n">sin_pitch</span> <span class="o">*</span> <span class="n">sin_yaw</span>
    <span class="n">out_</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span> <span class="n">sin_roll</span> <span class="o">*</span> <span class="n">cos_yaw</span> <span class="o">+</span> <span class="n">cos_roll</span> <span class="o">*</span> <span class="n">sin_pitch</span> <span class="o">*</span> <span class="n">sin_yaw</span>
    <span class="n">out_</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span> <span class="n">sin_pitch</span>
    <span class="n">out_</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">sin_roll</span> <span class="o">*</span> <span class="n">cos_pitch</span>
    <span class="n">out_</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">cos_roll</span> <span class="o">*</span> <span class="n">cos_pitch</span>

    <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">out_</span>
    <span class="k">return</span> <span class="kc">None</span></div>



<span class="nd">@overload</span>
<span class="k">def</span> <span class="nf">matrix_to_rpy</span><span class="p">(</span><span class="n">mat</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="o">...</span>


<span class="nd">@overload</span>
<span class="k">def</span> <span class="nf">matrix_to_rpy</span><span class="p">(</span><span class="n">mat</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="o">...</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="o">...</span>


<div class="viewcode-block" id="matrix_to_rpy">
<a class="viewcode-back" href="../../../../api/gym_jiminy/common/utils/math.html#gym_jiminy.common.utils.math.matrix_to_rpy">[docs]</a>
<span class="nd">@nb</span><span class="o">.</span><span class="n">jit</span><span class="p">(</span><span class="n">nopython</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">matrix_to_rpy</span><span class="p">(</span><span class="n">mat</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                  <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute the Yaw-Pitch-Roll Euler angles representation of a single or a</span>
<span class="sd">    batch of rotation matrices.</span>

<span class="sd">    :param mat: N-dimensional array whose first and second dimensions gathers</span>
<span class="sd">                the 3-by-3 rotation matrix elements.</span>
<span class="sd">    :param out: Pre-allocated array in which to store the result. If not</span>
<span class="sd">                provided, a new array is freshly-allocated and returned, which</span>
<span class="sd">                is slower.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="n">mat</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;=</span> <span class="mi">2</span>
    <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">out_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="o">*</span><span class="n">mat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">:]))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">out</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="o">*</span><span class="n">mat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">:])</span>
        <span class="n">out_</span> <span class="o">=</span> <span class="n">out</span>

    <span class="c1"># Direct translation of Eigen: `R.eulerAngles(2, 1, 0).reverse()`</span>
    <span class="c1"># roll, pitch, yaw = out_</span>
    <span class="n">cos_pitch</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">mat</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">mat</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">out_</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="o">-</span> <span class="n">mat</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">cos_pitch</span><span class="p">)</span>
    <span class="n">out_</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">mat</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">mat</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
    <span class="n">sin_yaw</span><span class="p">,</span> <span class="n">cos_yaw</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">out_</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">out_</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
    <span class="n">out_</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span>
        <span class="n">sin_yaw</span> <span class="o">*</span> <span class="n">mat</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">cos_yaw</span> <span class="o">*</span> <span class="n">mat</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
        <span class="n">cos_yaw</span> <span class="o">*</span> <span class="n">mat</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">sin_yaw</span> <span class="o">*</span> <span class="n">mat</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>

    <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">out_</span>
    <span class="k">return</span> <span class="kc">None</span></div>



<span class="nd">@overload</span>
<span class="k">def</span> <span class="nf">rpy_to_quat</span><span class="p">(</span><span class="n">rpy</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="o">...</span>


<span class="nd">@overload</span>
<span class="k">def</span> <span class="nf">rpy_to_quat</span><span class="p">(</span><span class="n">rpy</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="o">...</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="o">...</span>


<div class="viewcode-block" id="rpy_to_quat">
<a class="viewcode-back" href="../../../../api/gym_jiminy/common/utils/math.html#gym_jiminy.common.utils.math.rpy_to_quat">[docs]</a>
<span class="nd">@nb</span><span class="o">.</span><span class="n">jit</span><span class="p">(</span><span class="n">nopython</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">rpy_to_quat</span><span class="p">(</span><span class="n">rpy</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute the (qx, qy, qz, qw) Quaternion representation of a single or a</span>
<span class="sd">    batch of Yaw-Pitch-Roll Euler angles.</span>

<span class="sd">    :param rpy: N-dimensional array whose first dimension gathers the 3</span>
<span class="sd">                Yaw-Pitch-Roll Euler angles [Roll, Pitch, Yaw].</span>
<span class="sd">    :param out: Pre-allocated array in which to store the result. If not</span>
<span class="sd">                provided, a new array is freshly-allocated and returned, which</span>
<span class="sd">                is slower.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="n">rpy</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;=</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">out_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span> <span class="o">*</span><span class="n">rpy</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">out</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="o">*</span><span class="n">rpy</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
        <span class="n">out_</span> <span class="o">=</span> <span class="n">out</span>

    <span class="n">roll</span><span class="p">,</span> <span class="n">pitch</span><span class="p">,</span> <span class="n">yaw</span> <span class="o">=</span> <span class="n">rpy</span>
    <span class="n">cos_roll</span><span class="p">,</span> <span class="n">sin_roll</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">roll</span> <span class="o">/</span> <span class="mi">2</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">roll</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">cos_pitch</span><span class="p">,</span> <span class="n">sin_pitch</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">pitch</span> <span class="o">/</span> <span class="mi">2</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">pitch</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">cos_yaw</span><span class="p">,</span> <span class="n">sin_yaw</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">yaw</span> <span class="o">/</span> <span class="mi">2</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">yaw</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>

    <span class="c1"># q_x, q_y, q_z, q_w = out_</span>
    <span class="n">out_</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">sin_roll</span> <span class="o">*</span> <span class="n">cos_pitch</span> <span class="o">*</span> <span class="n">cos_yaw</span> <span class="o">-</span> <span class="n">cos_roll</span> <span class="o">*</span> <span class="n">sin_pitch</span> <span class="o">*</span> <span class="n">sin_yaw</span>
    <span class="n">out_</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">cos_roll</span> <span class="o">*</span> <span class="n">sin_pitch</span> <span class="o">*</span> <span class="n">cos_yaw</span> <span class="o">+</span> <span class="n">sin_roll</span> <span class="o">*</span> <span class="n">cos_pitch</span> <span class="o">*</span> <span class="n">sin_yaw</span>
    <span class="n">out_</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">cos_roll</span> <span class="o">*</span> <span class="n">cos_pitch</span> <span class="o">*</span> <span class="n">sin_yaw</span> <span class="o">-</span> <span class="n">sin_roll</span> <span class="o">*</span> <span class="n">sin_pitch</span> <span class="o">*</span> <span class="n">cos_yaw</span>
    <span class="n">out_</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">cos_roll</span> <span class="o">*</span> <span class="n">cos_pitch</span> <span class="o">*</span> <span class="n">cos_yaw</span> <span class="o">+</span> <span class="n">sin_roll</span> <span class="o">*</span> <span class="n">sin_pitch</span> <span class="o">*</span> <span class="n">sin_yaw</span>

    <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">out_</span>
    <span class="k">return</span> <span class="kc">None</span></div>



<span class="nd">@overload</span>
<span class="k">def</span> <span class="nf">quat_multiply</span><span class="p">(</span><span class="n">quat_left</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                  <span class="n">quat_right</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                  <span class="n">out</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                  <span class="n">is_left_conjugate</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                  <span class="n">is_right_conjugate</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="o">...</span>


<span class="nd">@overload</span>
<span class="k">def</span> <span class="nf">quat_multiply</span><span class="p">(</span><span class="n">quat_left</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                  <span class="n">quat_right</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                  <span class="n">out</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
                  <span class="n">is_left_conjugate</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                  <span class="n">is_right_conjugate</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="o">...</span>


<div class="viewcode-block" id="quat_multiply">
<a class="viewcode-back" href="../../../../api/gym_jiminy/common/utils/math.html#gym_jiminy.common.utils.math.quat_multiply">[docs]</a>
<span class="nd">@nb</span><span class="o">.</span><span class="n">jit</span><span class="p">(</span><span class="n">nopython</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">quat_multiply</span><span class="p">(</span><span class="n">quat_left</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                  <span class="n">quat_right</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                  <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                  <span class="n">is_left_conjugate</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                  <span class="n">is_right_conjugate</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute the composition of rotations as pair-wise product of two single</span>
<span class="sd">    or batches of quaternions (qx, qy, qz, qw), ie `quat_left * quat_right`.</span>

<span class="sd">    .. warning::</span>
<span class="sd">        Beware the argument order is important because the composition of</span>
<span class="sd">        rotations is not commutative.</span>

<span class="sd">    .. seealso::</span>
<span class="sd">        See https://en.wikipedia.org/wiki/Quaternions_and_spatial_rotation for</span>
<span class="sd">        mathematical details.</span>

<span class="sd">    :param quat_left: Left-hand side of the quaternion product, as a</span>
<span class="sd">                      N-dimensional array whose first dimension gathers the 4</span>
<span class="sd">                      quaternion coordinates (qx, qy, qz, qw).</span>
<span class="sd">    :param quat_right: Right-hand side of the quaternion product, as a</span>
<span class="sd">                       N-dimensional array whose first dimension gathers the 4</span>
<span class="sd">                       quaternion coordinates (qx, qy, qz, qw).</span>
<span class="sd">    :param out: Pre-allocated array in which to store the result. If not</span>
<span class="sd">                provided, a new array is freshly-allocated and returned, which</span>
<span class="sd">                is slower.</span>
<span class="sd">    :param is_left_conjugate: Whether to conjugate the left-hand side</span>
<span class="sd">                              quaternion before computing the product.</span>
<span class="sd">                              Optional: False by default.</span>
<span class="sd">    :param is_right_conjugate: Whether to conjugate the right-hand side</span>
<span class="sd">                               quaternion before computing the product.</span>
<span class="sd">                               Optional: False by default.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="n">quat_left</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;=</span> <span class="mi">1</span>
    <span class="n">out_shape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_shapes</span><span class="p">(</span><span class="n">quat_left</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">quat_right</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">out_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">out_shape</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">out</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">out_shape</span>
        <span class="n">out_</span> <span class="o">=</span> <span class="n">out</span>

    <span class="p">(</span><span class="n">qx_l</span><span class="p">,</span> <span class="n">qy_l</span><span class="p">,</span> <span class="n">qz_l</span><span class="p">,</span> <span class="n">qw_l</span><span class="p">),</span> <span class="p">(</span><span class="n">qx_r</span><span class="p">,</span> <span class="n">qy_r</span><span class="p">,</span> <span class="n">qz_r</span><span class="p">,</span> <span class="n">qw_r</span><span class="p">)</span> <span class="o">=</span> <span class="n">quat_left</span><span class="p">,</span> <span class="n">quat_right</span>
    <span class="n">s_l</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="k">if</span> <span class="n">is_left_conjugate</span> <span class="k">else</span> <span class="mi">1</span>
    <span class="n">s_r</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="k">if</span> <span class="n">is_right_conjugate</span> <span class="k">else</span> <span class="mi">1</span>

    <span class="c1"># Note that we assign all components at once to allow multiply in-place</span>
    <span class="c1"># qx_out, qy_out, qz_out, qw_out = out_</span>
    <span class="n">out_</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">out_</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">out_</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">out_</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">s_l</span> <span class="o">*</span> <span class="n">qw_l</span> <span class="o">*</span> <span class="n">qx_r</span> <span class="o">+</span> <span class="n">qx_l</span> <span class="o">*</span> <span class="n">s_r</span> <span class="o">*</span> <span class="n">qw_r</span> <span class="o">+</span> <span class="n">qy_l</span> <span class="o">*</span> <span class="n">qz_r</span> <span class="o">-</span> <span class="n">qz_l</span> <span class="o">*</span> <span class="n">qy_r</span><span class="p">,</span>
        <span class="n">s_l</span> <span class="o">*</span> <span class="n">qw_l</span> <span class="o">*</span> <span class="n">qy_r</span> <span class="o">-</span> <span class="n">qx_l</span> <span class="o">*</span> <span class="n">qz_r</span> <span class="o">+</span> <span class="n">qy_l</span> <span class="o">*</span> <span class="n">s_r</span> <span class="o">*</span> <span class="n">qw_r</span> <span class="o">+</span> <span class="n">qz_l</span> <span class="o">*</span> <span class="n">qx_r</span><span class="p">,</span>
        <span class="n">s_l</span> <span class="o">*</span> <span class="n">qw_l</span> <span class="o">*</span> <span class="n">qz_r</span> <span class="o">+</span> <span class="n">qx_l</span> <span class="o">*</span> <span class="n">qy_r</span> <span class="o">-</span> <span class="n">qy_l</span> <span class="o">*</span> <span class="n">qx_r</span> <span class="o">+</span> <span class="n">qz_l</span> <span class="o">*</span> <span class="n">s_r</span> <span class="o">*</span> <span class="n">qw_r</span><span class="p">,</span>
        <span class="n">s_l</span> <span class="o">*</span> <span class="n">qw_l</span> <span class="o">*</span> <span class="n">s_r</span> <span class="o">*</span> <span class="n">qw_r</span> <span class="o">-</span> <span class="n">qx_l</span> <span class="o">*</span> <span class="n">qx_r</span> <span class="o">-</span> <span class="n">qy_l</span> <span class="o">*</span> <span class="n">qy_r</span> <span class="o">-</span> <span class="n">qz_l</span> <span class="o">*</span> <span class="n">qz_r</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">out_</span>
    <span class="k">return</span> <span class="kc">None</span></div>



<span class="nd">@overload</span>
<span class="k">def</span> <span class="nf">quat_apply</span><span class="p">(</span><span class="n">quat</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
               <span class="n">vec</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
               <span class="n">out</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
               <span class="n">is_conjugate</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="o">...</span>


<span class="nd">@overload</span>
<span class="k">def</span> <span class="nf">quat_apply</span><span class="p">(</span><span class="n">quat</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
               <span class="n">vec</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
               <span class="n">out</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
               <span class="n">is_conjugate</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="o">...</span>


<div class="viewcode-block" id="quat_apply">
<a class="viewcode-back" href="../../../../api/gym_jiminy/common/utils/math.html#gym_jiminy.common.utils.math.quat_apply">[docs]</a>
<span class="nd">@nb</span><span class="o">.</span><span class="n">jit</span><span class="p">(</span><span class="n">nopython</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">quat_apply</span><span class="p">(</span><span class="n">quat</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
               <span class="n">vec</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
               <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
               <span class="n">is_conjugate</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Apply rotations to position vectors as pair-wise transform of a single</span>
<span class="sd">    or batch of position vectors (x, y, z) by a single or batch of quaternions</span>
<span class="sd">    (qx, qy, qz, qw), ie `quat * (vec, 0) * quat.conjugate()`.</span>

<span class="sd">    .. seealso::</span>
<span class="sd">        See https://en.wikipedia.org/wiki/Quaternions_and_spatial_rotation for</span>
<span class="sd">        mathematical details.</span>

<span class="sd">    .. warning::</span>
<span class="sd">        Applying rotation to position vectors using quaternions is much slower</span>
<span class="sd">        than using rotation matrices. In case where the same rotation must be</span>
<span class="sd">        applied to a batch of position vectors, it is faster to first convert</span>
<span class="sd">        the quaternion to a rotation matrix and use batched matrix product.</span>
<span class="sd">        However, if a different rotation must be applied to each position</span>
<span class="sd">        vector, then it is faster to apply batched quaternion transformation</span>
<span class="sd">        directly, because the cost of converting all quaternions to rotation</span>
<span class="sd">        matrices exceeds its benefit overall. This holds true even for a single</span>
<span class="sd">        pair quaternion-position.</span>

<span class="sd">    :param quat: N-dimensional array whose first dimension gathers the 4</span>
<span class="sd">                 quaternion coordinates (qx, qy, qz, qw).</span>
<span class="sd">    :param vec: N-dimensional array whose first dimension gathers the 3</span>
<span class="sd">                position coordinates (x, y, z).</span>
<span class="sd">    :param out: Pre-allocated array in which to store the result. If not</span>
<span class="sd">                provided, a new array is freshly-allocated and returned, which</span>
<span class="sd">                is slower.</span>
<span class="sd">    :param is_conjugate: Whether to conjugate the quaternion before applying</span>
<span class="sd">                         the rotation.</span>
<span class="sd">                         Optional: False by default.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="n">quat</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;=</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">vec</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;=</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">out_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">vec</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">out</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">vec</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">out_</span> <span class="o">=</span> <span class="n">out</span>

    <span class="n">q_xx</span><span class="p">,</span> <span class="n">q_xy</span><span class="p">,</span> <span class="n">q_xz</span><span class="p">,</span> <span class="n">q_xw</span> <span class="o">=</span> <span class="n">quat</span><span class="p">[</span><span class="o">-</span><span class="mi">4</span><span class="p">]</span> <span class="o">*</span> <span class="n">quat</span><span class="p">[</span><span class="o">-</span><span class="mi">4</span><span class="p">:]</span>
    <span class="n">q_yy</span><span class="p">,</span> <span class="n">q_yz</span><span class="p">,</span> <span class="n">q_yw</span> <span class="o">=</span> <span class="n">quat</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">]</span> <span class="o">*</span> <span class="n">quat</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">:]</span>
    <span class="n">q_zz</span><span class="p">,</span> <span class="n">q_zw</span> <span class="o">=</span> <span class="n">quat</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">quat</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:]</span>
    <span class="n">q_ww</span> <span class="o">=</span> <span class="n">quat</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">quat</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">vec</span>
    <span class="n">s</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="k">if</span> <span class="n">is_conjugate</span> <span class="k">else</span> <span class="mi">1</span>

    <span class="c1"># Note that we assign all components at once to allow rotation in-place</span>
    <span class="c1"># px, py, pz = out_</span>
    <span class="p">(</span><span class="n">out_</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">out_</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">out_</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">x</span> <span class="o">*</span> <span class="p">(</span><span class="n">q_xx</span> <span class="o">+</span> <span class="n">q_ww</span> <span class="o">-</span> <span class="n">q_yy</span> <span class="o">-</span> <span class="n">q_zz</span><span class="p">)</span> <span class="o">+</span>
        <span class="n">y</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">q_xy</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">s</span> <span class="o">*</span> <span class="n">q_zw</span><span class="p">)</span> <span class="o">+</span>
        <span class="n">z</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">q_xz</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">s</span> <span class="o">*</span> <span class="n">q_yw</span><span class="p">),</span>
        <span class="n">x</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">s</span> <span class="o">*</span> <span class="n">q_zw</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">q_xy</span><span class="p">)</span> <span class="o">+</span>
        <span class="n">y</span> <span class="o">*</span> <span class="p">(</span><span class="n">q_ww</span> <span class="o">-</span> <span class="n">q_xx</span> <span class="o">+</span> <span class="n">q_yy</span> <span class="o">-</span> <span class="n">q_zz</span><span class="p">)</span> <span class="o">+</span>
        <span class="n">z</span> <span class="o">*</span> <span class="p">(</span><span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">s</span> <span class="o">*</span> <span class="n">q_xw</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">q_yz</span><span class="p">),</span>
        <span class="n">x</span> <span class="o">*</span> <span class="p">(</span><span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">s</span> <span class="o">*</span> <span class="n">q_yw</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">q_xz</span><span class="p">)</span> <span class="o">+</span>
        <span class="n">y</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">s</span> <span class="o">*</span> <span class="n">q_xw</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">q_yz</span><span class="p">)</span> <span class="o">+</span>
        <span class="n">z</span> <span class="o">*</span> <span class="p">(</span><span class="n">q_ww</span> <span class="o">-</span> <span class="n">q_xx</span> <span class="o">-</span> <span class="n">q_yy</span> <span class="o">+</span> <span class="n">q_zz</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">out_</span>
    <span class="k">return</span> <span class="kc">None</span></div>



<span class="nd">@overload</span>
<span class="k">def</span> <span class="nf">log3</span><span class="p">(</span><span class="n">quat</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">theta</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="o">...</span>


<span class="nd">@overload</span>
<span class="k">def</span> <span class="nf">log3</span><span class="p">(</span><span class="n">quat</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
         <span class="n">out</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
         <span class="n">theta</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="o">...</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="o">...</span>


<div class="viewcode-block" id="log3">
<a class="viewcode-back" href="../../../../api/gym_jiminy/common/utils/math.html#gym_jiminy.common.utils.math.log3">[docs]</a>
<span class="nd">@nb</span><span class="o">.</span><span class="n">jit</span><span class="p">(</span><span class="n">nopython</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">log3</span><span class="p">(</span><span class="n">quat</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
         <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
         <span class="n">theta</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute the angle-axis representation theta * (ax, ay, az) of a single</span>
<span class="sd">    or a batch of quaternions (qx, qy, qz, qz).</span>

<span class="sd">    As a reminder, any element of the Lie Group of rotation group SO(3) can be</span>
<span class="sd">    mapped to an element of its Lie Algebra so(3) ⊂ R3 at identity, which</span>
<span class="sd">    identifies to its tangent space, through the pseudo-inverse of the</span>
<span class="sd">    exponential map. See `pinocchio.log3` documentation for technical details.</span>

<span class="sd">    :param quat: N-dimensional array whose first dimension gathers the 4</span>
<span class="sd">                 quaternion coordinates (qx, qy, qz, qw).</span>
<span class="sd">    :param out: Pre-allocated array into which to store the result. If not</span>
<span class="sd">                provided, a new array is freshly-allocated and returned, which</span>
<span class="sd">                is slower.</span>
<span class="sd">    :param theta: Pre-allocated array into which to store the angle. This is</span>
<span class="sd">                  useful to avoid redundant computations in some cases.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="n">quat</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;=</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">out_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="o">*</span><span class="n">quat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">out</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="o">*</span><span class="n">quat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
        <span class="n">out_</span> <span class="o">=</span> <span class="n">out</span>
    <span class="k">if</span> <span class="n">theta</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">theta_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">quat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">theta</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">quat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="n">theta_</span> <span class="o">=</span> <span class="n">theta</span>
    <span class="n">theta1d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">theta_</span><span class="p">)</span>

    <span class="c1"># Split real (qx, qy, qz) and imaginary (qw,) quaternion parts</span>
    <span class="n">q_vec</span><span class="p">,</span> <span class="n">q_w</span> <span class="o">=</span> <span class="n">quat</span><span class="p">[:</span><span class="mi">3</span><span class="p">],</span> <span class="n">quat</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>

    <span class="c1"># Compute the angle-axis representation of the relative rotation.</span>
    <span class="c1"># Note that one must deal with undefined behavior asymptotically.</span>
    <span class="c1"># FIXME: Ideally, a taylor expansion should be used to handle theta ~ 0,</span>
    <span class="c1"># but it is tricky to implement without having to compute both branches</span>
    <span class="c1"># systematically. In practice, float64 computations are precise enough not</span>
    <span class="c1"># to have to worry too much about it.</span>
    <span class="n">eps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span><span class="o">.</span><span class="n">tiny</span>
    <span class="n">theta_sin_2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">q_vec</span><span class="p">),</span> <span class="mi">0</span><span class="p">))</span>
    <span class="n">theta1d</span><span class="p">[:]</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">theta_sin_2</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">q_w</span><span class="p">))</span>
    <span class="n">inv_sinc</span> <span class="o">=</span> <span class="n">theta_</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">theta_sin_2</span><span class="p">,</span> <span class="n">eps</span><span class="p">)</span>
    <span class="n">out_</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">inv_sinc</span> <span class="o">*</span> <span class="n">q_vec</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">q_w</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">out_</span>
    <span class="k">return</span> <span class="kc">None</span></div>



<span class="n">quat_to_angle_axis</span> <span class="o">=</span> <span class="n">log3</span>


<span class="nd">@overload</span>
<span class="k">def</span> <span class="nf">exp3</span><span class="p">(</span><span class="n">angle_axis</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="o">...</span>


<span class="nd">@overload</span>
<span class="k">def</span> <span class="nf">exp3</span><span class="p">(</span><span class="n">angle_axis</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="o">...</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="o">...</span>


<div class="viewcode-block" id="exp3">
<a class="viewcode-back" href="../../../../api/gym_jiminy/common/utils/math.html#gym_jiminy.common.utils.math.exp3">[docs]</a>
<span class="nd">@nb</span><span class="o">.</span><span class="n">jit</span><span class="p">(</span><span class="n">nopython</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">exp3</span><span class="p">(</span><span class="n">angle_axis</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
         <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute the quaternion representation (qx, qy, qz, qz) of a single</span>
<span class="sd">    or a batch of angle-axis vectors theta * (ax, ay, az).</span>

<span class="sd">    As a reminder, it also corresponds to the inverse exponential map from the</span>
<span class="sd">    rotation Lie Group SO3 to its Lie Algebra so3.</span>

<span class="sd">    :param angle_axis: N-dimensional array whose first dimension gathers the 3</span>
<span class="sd">                       angle-axis components theta * (ax, ay, az).</span>
<span class="sd">    :param out: Pre-allocated array into which to store the result. If not</span>
<span class="sd">                provided, a new array is freshly-allocated and returned, which</span>
<span class="sd">                is slower.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="n">angle_axis</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;=</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">out_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span> <span class="o">*</span><span class="n">angle_axis</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">out</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="o">*</span><span class="n">angle_axis</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
        <span class="n">out_</span> <span class="o">=</span> <span class="n">out</span>

    <span class="c1"># Compute unit axis and positive angle separately</span>
    <span class="c1"># Note that one must deal with undefined behavior asymptotically.</span>
    <span class="c1"># FIXME: Taylor expansion should be used to handle theta ~ 0.</span>
    <span class="n">eps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span><span class="o">.</span><span class="n">tiny</span>
    <span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">angle_axis</span><span class="p">),</span> <span class="mi">0</span><span class="p">))</span>
    <span class="n">axis</span> <span class="o">=</span> <span class="n">angle_axis</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">eps</span><span class="p">)</span>

    <span class="c1"># Compute the quaternion representation</span>
    <span class="n">out_</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">theta</span><span class="p">)</span> <span class="o">*</span> <span class="n">axis</span>
    <span class="n">out_</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">theta</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">out_</span>
    <span class="k">return</span> <span class="kc">None</span></div>



<span class="n">angle_axis_to_quat</span> <span class="o">=</span> <span class="n">exp3</span>


<span class="nd">@overload</span>
<span class="k">def</span> <span class="nf">log6</span><span class="p">(</span><span class="n">xyzquat</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="o">...</span>


<span class="nd">@overload</span>
<span class="k">def</span> <span class="nf">log6</span><span class="p">(</span><span class="n">xyzquat</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="o">...</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="o">...</span>


<div class="viewcode-block" id="log6">
<a class="viewcode-back" href="../../../../api/gym_jiminy/common/utils/math.html#gym_jiminy.common.utils.math.log6">[docs]</a>
<span class="nd">@nb</span><span class="o">.</span><span class="n">jit</span><span class="p">(</span><span class="n">nopython</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">log6</span><span class="p">(</span><span class="n">xyzquat</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
         <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Apply SE3 to se3 inverse exponential map on a single or a batch of</span>
<span class="sd">    transform vectors (x, y, z, qx, qy, qz, qw) defining the pose (position</span>
<span class="sd">    plus orientation) of a frame in 3D space.</span>

<span class="sd">    As a reminder, the resulting vector is homogeneous to a spatial velocity</span>
<span class="sd">    vector, aka. a motion vector.</span>

<span class="sd">    :param xyzquat: N-dimensional array whose first dimension gathers the 7</span>
<span class="sd">                    position and quaternion coordinates (x, y, z),</span>
<span class="sd">                    (qx, qy, qz, qw) respectively.</span>
<span class="sd">    :param out: Pre-allocated array into which to store the result. If not</span>
<span class="sd">                provided, a new array is freshly-allocated and returned, which</span>
<span class="sd">                is slower.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="n">xyzquat</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;=</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">out_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">6</span><span class="p">,</span> <span class="o">*</span><span class="n">xyzquat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">out</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="o">*</span><span class="n">xyzquat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
        <span class="n">out_</span> <span class="o">=</span> <span class="n">out</span>

    <span class="c1"># Split linear and angular parts for input and output representations</span>
    <span class="n">v_lin</span><span class="p">,</span> <span class="n">v_ang</span> <span class="o">=</span> <span class="n">out_</span><span class="p">[:</span><span class="mi">3</span><span class="p">],</span> <span class="n">out_</span><span class="p">[</span><span class="mi">3</span><span class="p">:]</span>
    <span class="n">pos</span><span class="p">,</span> <span class="n">quat</span> <span class="o">=</span> <span class="n">xyzquat</span><span class="p">[:</span><span class="mi">3</span><span class="p">],</span> <span class="n">xyzquat</span><span class="p">[</span><span class="mi">3</span><span class="p">:]</span>
    <span class="n">qvec</span><span class="p">,</span> <span class="n">qw</span> <span class="o">=</span> <span class="n">quat</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">quat</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="c1"># Compute the angular part</span>
    <span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">xyzquat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
    <span class="n">log3</span><span class="p">(</span><span class="n">quat</span><span class="p">,</span> <span class="n">v_ang</span><span class="p">,</span> <span class="n">theta</span><span class="p">)</span>

    <span class="c1"># Compute the linear part.</span>
    <span class="c1"># FIXME: Taylor expansion should be used to handle theta ~ 0.</span>
    <span class="n">eps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span><span class="o">.</span><span class="n">tiny</span> <span class="o">**</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">theta_cos_2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">qw</span><span class="p">)</span>
    <span class="n">theta_sin_2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">qvec</span><span class="p">),</span> <span class="mi">0</span><span class="p">)),</span> <span class="n">eps</span><span class="p">)</span>
    <span class="n">theta_cot_2</span> <span class="o">=</span> <span class="n">theta_cos_2</span> <span class="o">/</span> <span class="n">theta_sin_2</span>
    <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">eps</span><span class="p">,</span> <span class="n">theta</span><span class="p">)</span>
    <span class="n">beta</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">theta_cot_2</span> <span class="o">/</span> <span class="n">theta</span>
    <span class="n">wxv_x</span> <span class="o">=</span> <span class="n">v_ang</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">pos</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">v_ang</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">pos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">wxv_y</span> <span class="o">=</span> <span class="n">v_ang</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">pos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">v_ang</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">pos</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">wxv_z</span> <span class="o">=</span> <span class="n">v_ang</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">pos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">v_ang</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">pos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">w2xv_x</span> <span class="o">=</span> <span class="n">v_ang</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">wxv_z</span> <span class="o">-</span> <span class="n">v_ang</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">wxv_y</span>
    <span class="n">w2xv_y</span> <span class="o">=</span> <span class="n">v_ang</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">wxv_x</span> <span class="o">-</span> <span class="n">v_ang</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">wxv_z</span>
    <span class="n">w2xv_z</span> <span class="o">=</span> <span class="n">v_ang</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">wxv_y</span> <span class="o">-</span> <span class="n">v_ang</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">wxv_x</span>
    <span class="n">v_lin</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">pos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">wxv_x</span> <span class="o">+</span> <span class="n">beta</span> <span class="o">*</span> <span class="n">w2xv_x</span>
    <span class="n">v_lin</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">pos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">wxv_y</span> <span class="o">+</span> <span class="n">beta</span> <span class="o">*</span> <span class="n">w2xv_y</span>
    <span class="n">v_lin</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">pos</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">wxv_z</span> <span class="o">+</span> <span class="n">beta</span> <span class="o">*</span> <span class="n">w2xv_z</span>

    <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">out_</span>
    <span class="k">return</span> <span class="kc">None</span></div>



<span class="nd">@overload</span>
<span class="k">def</span> <span class="nf">exp6</span><span class="p">(</span><span class="n">v_spatial</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="o">...</span>


<span class="nd">@overload</span>
<span class="k">def</span> <span class="nf">exp6</span><span class="p">(</span><span class="n">v_spatial</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="o">...</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="o">...</span>


<div class="viewcode-block" id="exp6">
<a class="viewcode-back" href="../../../../api/gym_jiminy/common/utils/math.html#gym_jiminy.common.utils.math.exp6">[docs]</a>
<span class="nd">@nb</span><span class="o">.</span><span class="n">jit</span><span class="p">(</span><span class="n">nopython</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">exp6</span><span class="p">(</span><span class="n">v_spatial</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
         <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Apply se3 to SE3 exponential map on a single or a batch of spatial</span>
<span class="sd">    velocity vectors (vx, vy, vz, wx, wy, wz), also called motion vectors,</span>
<span class="sd">    using quaternions (qx, qy, qz, qw) to represent the rotation.</span>

<span class="sd">    :param v_spatial: N-dimensional array whose first dimension gathers the 6</span>
<span class="sd">                      linear and angular velocity components (vx, vy, vz),</span>
<span class="sd">                      (wx, wy, wz) respectively.</span>
<span class="sd">    :param out: Pre-allocated array into which to store the result. If not</span>
<span class="sd">                provided, a new array is freshly-allocated and returned, which</span>
<span class="sd">                is slower.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="n">v_spatial</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;=</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">out_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">7</span><span class="p">,</span> <span class="o">*</span><span class="n">v_spatial</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">out</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="o">*</span><span class="n">v_spatial</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
        <span class="n">out_</span> <span class="o">=</span> <span class="n">out</span>

    <span class="c1"># Split linear and angular velocity for convenience</span>
    <span class="n">v_lin</span><span class="p">,</span> <span class="n">v_ang</span> <span class="o">=</span> <span class="n">v_spatial</span><span class="p">[:</span><span class="mi">3</span><span class="p">],</span> <span class="n">v_spatial</span><span class="p">[</span><span class="mi">3</span><span class="p">:]</span>

    <span class="c1"># Compute the linear part.</span>
    <span class="c1"># FIXME: Taylor expansion should be used to handle theta ~ 0.</span>
    <span class="n">eps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span><span class="o">.</span><span class="n">tiny</span> <span class="o">**</span> <span class="p">(</span><span class="mi">2</span> <span class="o">/</span> <span class="mi">3</span><span class="p">)</span>
    <span class="n">theta_sq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">v_ang</span><span class="p">),</span> <span class="mi">0</span><span class="p">),</span> <span class="n">eps</span><span class="p">)</span>
    <span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">theta_sq</span><span class="p">)</span>
    <span class="n">theta_cos</span><span class="p">,</span> <span class="n">theta_sin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
    <span class="n">alpha_wxv</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">theta_cos</span><span class="p">)</span> <span class="o">/</span> <span class="n">theta_sq</span>
    <span class="n">alpha_w2</span> <span class="o">=</span> <span class="p">(</span><span class="n">theta</span> <span class="o">-</span> <span class="n">theta_sin</span><span class="p">)</span> <span class="o">/</span> <span class="n">theta_sq</span> <span class="o">/</span> <span class="n">theta</span>
    <span class="n">wxv_x</span> <span class="o">=</span> <span class="n">v_ang</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">v_lin</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">v_ang</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">v_lin</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">wxv_y</span> <span class="o">=</span> <span class="n">v_ang</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">v_lin</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">v_ang</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">v_lin</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">wxv_z</span> <span class="o">=</span> <span class="n">v_ang</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">v_lin</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">v_ang</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">v_lin</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">w2xv_x</span> <span class="o">=</span> <span class="n">v_ang</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">wxv_z</span> <span class="o">-</span> <span class="n">v_ang</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">wxv_y</span>
    <span class="n">w2xv_y</span> <span class="o">=</span> <span class="n">v_ang</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">wxv_x</span> <span class="o">-</span> <span class="n">v_ang</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">wxv_z</span>
    <span class="n">w2xv_z</span> <span class="o">=</span> <span class="n">v_ang</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">wxv_y</span> <span class="o">-</span> <span class="n">v_ang</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">wxv_x</span>
    <span class="n">out_</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">v_lin</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">alpha_wxv</span> <span class="o">*</span> <span class="n">wxv_x</span> <span class="o">+</span> <span class="n">alpha_w2</span> <span class="o">*</span> <span class="n">w2xv_x</span>
    <span class="n">out_</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">v_lin</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">alpha_wxv</span> <span class="o">*</span> <span class="n">wxv_y</span> <span class="o">+</span> <span class="n">alpha_w2</span> <span class="o">*</span> <span class="n">w2xv_y</span>
    <span class="n">out_</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">v_lin</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">alpha_wxv</span> <span class="o">*</span> <span class="n">wxv_z</span> <span class="o">+</span> <span class="n">alpha_w2</span> <span class="o">*</span> <span class="n">w2xv_z</span>

    <span class="c1"># Compute the angular part</span>
    <span class="n">exp3</span><span class="p">(</span><span class="n">v_ang</span><span class="p">,</span> <span class="n">out_</span><span class="p">[</span><span class="o">-</span><span class="mi">4</span><span class="p">:])</span>

    <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">out_</span>
    <span class="k">return</span> <span class="kc">None</span></div>



<span class="nd">@overload</span>
<span class="k">def</span> <span class="nf">quat_difference</span><span class="p">(</span><span class="n">quat_left</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                    <span class="n">quat_right</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                    <span class="n">out</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="o">...</span>


<span class="nd">@overload</span>
<span class="k">def</span> <span class="nf">quat_difference</span><span class="p">(</span><span class="n">quat_left</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                    <span class="n">quat_right</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                    <span class="n">out</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="o">...</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="o">...</span>


<div class="viewcode-block" id="quat_difference">
<a class="viewcode-back" href="../../../../api/gym_jiminy/common/utils/math.html#gym_jiminy.common.utils.math.quat_difference">[docs]</a>
<span class="nd">@nb</span><span class="o">.</span><span class="n">jit</span><span class="p">(</span><span class="n">nopython</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">quat_difference</span><span class="p">(</span><span class="n">quat_left</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                    <span class="n">quat_right</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute the pair-wise SO3 difference between two batches of quaternions</span>
<span class="sd">    (qx, qy, qz, qz). For each pairs, it returns a angular velocity vector</span>
<span class="sd">    (wx, wy, wz) in tangent space of SO3 Lie Group.</span>

<span class="sd">    First, it computes the residual rotation for all pairs, ie</span>
<span class="sd">    `quat_diff = quat_left.conjugate() * quat_right`. Then, it computes the</span>
<span class="sd">    angle-axis representation of the residual rotations, ie `log3(quat_diff)`.</span>
<span class="sd">    See `pinocchio.liegroups.SO3.difference` documentation for reference.</span>

<span class="sd">    .. note::</span>
<span class="sd">        Calling this method is faster than `pinocchio.liegroups.SO3.difference`</span>
<span class="sd">        if at least 2 pairs of quaternions with pre-allocated output. This is</span>
<span class="sd">        not surprising since vectorization does not have any effect in this</span>
<span class="sd">        case. This expected speed up is about x5 and x15 for 10 and 100 pairs</span>
<span class="sd">        respectively with pre-allocated output.</span>

<span class="sd">    :param quat_left: Left-hand side of SO3 difference, as a N-dimensional</span>
<span class="sd">                      array whose first dimension gathers the 4 quaternion</span>
<span class="sd">                      coordinates (qx, qy, qz, qw).</span>
<span class="sd">    :param quat_right: Right-hand side of SO3 difference, as a N-dimensional</span>
<span class="sd">                       array whose first dimension gathers the 4 quaternion</span>
<span class="sd">                       coordinates (qx, qy, qz, qw).</span>
<span class="sd">    :param out: Pre-allocated array into which to store the result. If not</span>
<span class="sd">                provided, a new array is freshly-allocated and returned, which</span>
<span class="sd">                is slower.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Compute the quaternion representation of the residual rotation</span>
    <span class="n">quat_diff</span> <span class="o">=</span> <span class="n">quat_multiply</span><span class="p">(</span><span class="n">quat_left</span><span class="p">,</span> <span class="n">quat_right</span><span class="p">,</span> <span class="n">is_left_conjugate</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># Compute the angle-axis representation of the residual rotation</span>
    <span class="k">return</span> <span class="n">log3</span><span class="p">(</span><span class="n">quat_diff</span><span class="p">,</span> <span class="n">out</span><span class="p">)</span>  <span class="c1"># type: ignore[call-overload]</span></div>



<div class="viewcode-block" id="xyzquat_difference">
<a class="viewcode-back" href="../../../../api/gym_jiminy/common/utils/math.html#gym_jiminy.common.utils.math.xyzquat_difference">[docs]</a>
<span class="nd">@nb</span><span class="o">.</span><span class="n">jit</span><span class="p">(</span><span class="n">nopython</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">xyzquat_difference</span><span class="p">(</span><span class="n">xyzquat_left</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                       <span class="n">xyzquat_right</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                       <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
                       <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute the pair-wise SE3 difference between two batches of transform</span>
<span class="sd">    vectors (x, y, z, qx, qy, qz, qz). For each pairs, it returns a spatial</span>
<span class="sd">    velocity vector (vx, vy, vz, wx, wy, wz), also called motion vector, in</span>
<span class="sd">    tangent space of SE3 Lie Group.</span>

<span class="sd">    First, it computes the residual transform in local frame for all pairs.</span>
<span class="sd">    Then, it applies the inverse exponential map `log6` of it. See</span>
<span class="sd">    `pinocchio.liegroups.SE3.difference` documentation for reference.</span>

<span class="sd">    :param xyzquat_left: Left-hand side of SE3 difference, as a N-dimensional</span>
<span class="sd">                         array whose first dimension gathers the 7 position and</span>
<span class="sd">                         quaternion coordinates (x, y, z), (qx, qy, qz, qw).</span>
<span class="sd">    :param xyzquat_right: Right-hand side of SO3 difference, as a N-dimensional</span>
<span class="sd">                         array whose first dimension gathers the 7 position and</span>
<span class="sd">                         quaternion coordinates (x, y, z), (qx, qy, qz, qw).</span>
<span class="sd">    :param out: Pre-allocated array into which to store the result. If not</span>
<span class="sd">                provided, a new array is freshly-allocated and returned, which</span>
<span class="sd">                is slower.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Compute the xyzquat representation of the residual pose</span>
    <span class="n">xyzquat_diff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">xyzquat_left</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">xyz_diff</span><span class="p">,</span> <span class="n">quat_diff</span> <span class="o">=</span> <span class="n">xyzquat_diff</span><span class="p">[:</span><span class="mi">3</span><span class="p">],</span> <span class="n">xyzquat_diff</span><span class="p">[</span><span class="o">-</span><span class="mi">4</span><span class="p">:]</span>
    <span class="n">xyz_left</span><span class="p">,</span> <span class="n">quat_left</span> <span class="o">=</span> <span class="n">xyzquat_left</span><span class="p">[:</span><span class="mi">3</span><span class="p">],</span> <span class="n">xyzquat_left</span><span class="p">[</span><span class="o">-</span><span class="mi">4</span><span class="p">:]</span>
    <span class="n">xyz_right</span><span class="p">,</span> <span class="n">quat_right</span> <span class="o">=</span> <span class="n">xyzquat_right</span><span class="p">[:</span><span class="mi">3</span><span class="p">],</span> <span class="n">xyzquat_right</span><span class="p">[</span><span class="o">-</span><span class="mi">4</span><span class="p">:]</span>
    <span class="n">xyz_diff</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">xyz_right</span> <span class="o">-</span> <span class="n">xyz_left</span>
    <span class="n">quat_apply</span><span class="p">(</span><span class="n">quat_left</span><span class="p">,</span> <span class="n">xyz_diff</span><span class="p">,</span> <span class="n">xyz_diff</span><span class="p">,</span> <span class="n">is_conjugate</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">quat_multiply</span><span class="p">(</span><span class="n">quat_left</span><span class="p">,</span> <span class="n">quat_right</span><span class="p">,</span> <span class="n">quat_diff</span><span class="p">,</span> <span class="n">is_left_conjugate</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># Apply inverse exponential map to cast the residual pose in tangent space</span>
    <span class="k">return</span> <span class="n">log6</span><span class="p">(</span><span class="n">xyzquat_diff</span><span class="p">,</span> <span class="n">out</span><span class="p">)</span></div>



<div class="viewcode-block" id="compute_tilt_from_quat">
<a class="viewcode-back" href="../../../../api/gym_jiminy/common/utils/math.html#gym_jiminy.common.utils.math.compute_tilt_from_quat">[docs]</a>
<span class="nd">@nb</span><span class="o">.</span><span class="n">jit</span><span class="p">(</span><span class="n">nopython</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">compute_tilt_from_quat</span><span class="p">(</span><span class="n">q</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span>
                           <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute e_z in R(q) frame (Euler-Rodrigues Formula): R(q).T @ e_z.</span>

<span class="sd">    :param q: Array whose rows are the 4 components of quaternions (x, y, z, w)</span>
<span class="sd">              and columns are N independent orientations.</span>

<span class="sd">    :returns: Tuple of arrays corresponding to the 3 individual components</span>
<span class="sd">              (a_x, a_y, a_z) of N independent tilt axes.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">q_x</span><span class="p">,</span> <span class="n">q_y</span><span class="p">,</span> <span class="n">q_z</span><span class="p">,</span> <span class="n">q_w</span> <span class="o">=</span> <span class="n">q</span>
    <span class="n">v_x</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">q_x</span> <span class="o">*</span> <span class="n">q_z</span> <span class="o">-</span> <span class="n">q_y</span> <span class="o">*</span> <span class="n">q_w</span><span class="p">)</span>
    <span class="n">v_y</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">q_y</span> <span class="o">*</span> <span class="n">q_z</span> <span class="o">+</span> <span class="n">q_w</span> <span class="o">*</span> <span class="n">q_x</span><span class="p">)</span>
    <span class="n">v_z</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">q_x</span> <span class="o">*</span> <span class="n">q_x</span> <span class="o">+</span> <span class="n">q_y</span> <span class="o">*</span> <span class="n">q_y</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">v_x</span><span class="p">,</span> <span class="n">v_y</span><span class="p">,</span> <span class="n">v_z</span><span class="p">)</span></div>



<span class="c1"># FIXME: Enabling cache causes segfault on Apple Silicon</span>
<div class="viewcode-block" id="swing_from_vector">
<a class="viewcode-back" href="../../../../api/gym_jiminy/common/utils/math.html#gym_jiminy.common.utils.math.swing_from_vector">[docs]</a>
<span class="nd">@no_type_check</span>
<span class="nd">@nb</span><span class="o">.</span><span class="n">jit</span><span class="p">(</span><span class="n">nopython</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">swing_from_vector</span><span class="p">(</span>
        <span class="n">v_a</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">ArrayOrScalar</span><span class="p">,</span> <span class="n">ArrayOrScalar</span><span class="p">,</span> <span class="n">ArrayOrScalar</span><span class="p">],</span>
        <span class="n">q</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute the &quot;smallest&quot; rotation transforming vector &#39;v_a&#39; in &#39;e_z&#39;.</span>

<span class="sd">    :param v_a: Tuple of arrays corresponding to the 3 individual components</span>
<span class="sd">                (a_x, a_y, a_z) of N independent tilt axes.</span>
<span class="sd">    :param q: Array where the result will be stored. The rows are the 4</span>
<span class="sd">              components of quaternions (x, y, z, w) and columns are the N</span>
<span class="sd">              independent orientations.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># pylint: disable=possibly-used-before-assignment</span>

    <span class="c1"># Extract individual tilt components</span>
    <span class="n">v_x</span><span class="p">,</span> <span class="n">v_y</span><span class="p">,</span> <span class="n">v_z</span> <span class="o">=</span> <span class="n">v_a</span>

    <span class="c1"># There is a singularity when the rotation axis of orientation estimate</span>
    <span class="c1"># and z-axis are nearly opposites, i.e. v_z ~= -1. One solution that</span>
    <span class="c1"># ensure continuity of q_w is picked arbitrarily using SVD decomposition.</span>
    <span class="c1"># See `Eigen::Quaternion::FromTwoVectors` implementation for details.</span>
    <span class="k">if</span> <span class="n">q</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">is_singular</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">v_z</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mf">1.0</span> <span class="o">+</span> <span class="n">TWIST_SWING_SINGULAR_THR</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">is_singular</span> <span class="o">=</span> <span class="n">v_z</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mf">1.0</span> <span class="o">+</span> <span class="n">TWIST_SWING_SINGULAR_THR</span>
    <span class="k">if</span> <span class="n">is_singular</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">q</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">q_i</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">q</span><span class="o">.</span><span class="n">T</span><span class="p">):</span>
                <span class="n">swing_from_vector</span><span class="p">((</span><span class="n">v_x</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">v_y</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">v_z</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span> <span class="n">q_i</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">eps_thr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">TWIST_SWING_SINGULAR_THR</span><span class="p">)</span>
            <span class="n">eps_x</span> <span class="o">=</span> <span class="o">-</span><span class="n">TWIST_SWING_SINGULAR_THR</span> <span class="o">&lt;</span> <span class="n">v_x</span> <span class="o">&lt;</span> <span class="n">TWIST_SWING_SINGULAR_THR</span>
            <span class="n">eps_y</span> <span class="o">=</span> <span class="o">-</span><span class="n">TWIST_SWING_SINGULAR_THR</span> <span class="o">&lt;</span> <span class="n">v_y</span> <span class="o">&lt;</span> <span class="n">TWIST_SWING_SINGULAR_THR</span>
            <span class="k">if</span> <span class="n">eps_x</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">eps_y</span><span class="p">:</span>
                <span class="n">ratio</span> <span class="o">=</span> <span class="n">v_x</span> <span class="o">/</span> <span class="n">v_y</span>
                <span class="n">esp_ratio</span> <span class="o">=</span> <span class="o">-</span> <span class="n">eps_thr</span> <span class="o">&lt;</span> <span class="n">ratio</span> <span class="o">&lt;</span> <span class="n">eps_thr</span>
            <span class="k">elif</span> <span class="n">eps_y</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">eps_x</span><span class="p">:</span>
                <span class="n">ratio</span> <span class="o">=</span> <span class="n">v_y</span> <span class="o">/</span> <span class="n">v_x</span>
                <span class="n">esp_ratio</span> <span class="o">=</span> <span class="o">-</span> <span class="n">eps_thr</span> <span class="o">&lt;</span> <span class="n">ratio</span> <span class="o">&lt;</span> <span class="n">eps_thr</span>
            <span class="n">w_2</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="nb">max</span><span class="p">(</span><span class="n">v_z</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">))</span> <span class="o">/</span> <span class="mf">2.0</span>
            <span class="k">if</span> <span class="n">eps_x</span> <span class="ow">and</span> <span class="n">eps_y</span><span class="p">:</span>
                <span class="c1"># Both q_x and q_y would do fine. Picking q_y arbitrarily.</span>
                <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
                <span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">w_2</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">esp_ratio</span> <span class="ow">and</span> <span class="n">eps_x</span><span class="p">:</span>
                <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">w_2</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">ratio</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
                <span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">w_2</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">ratio</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">ratio</span> <span class="o">**</span> <span class="mi">3</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">esp_ratio</span> <span class="ow">and</span> <span class="n">eps_y</span><span class="p">:</span>
                <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">w_2</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">ratio</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">ratio</span> <span class="o">**</span> <span class="mi">3</span><span class="p">)</span>
                <span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">w_2</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">ratio</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">w_2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="p">(</span><span class="n">v_x</span> <span class="o">/</span> <span class="n">v_y</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span>
                <span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">w_2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="p">(</span><span class="n">v_y</span> <span class="o">/</span> <span class="n">v_x</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span>
            <span class="n">q</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="n">q</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">w_2</span><span class="p">)</span>
            <span class="c1"># _, _, v_h = np.linalg.svd(np.array((</span>
            <span class="c1">#     (v_x, v_y, v_z),</span>
            <span class="c1">#     (0.0, 0.0, 1.0))</span>
            <span class="c1"># ), full_matrices=True)</span>
            <span class="c1"># q[:3], q[3] = v_h[-1] * np.sqrt(1.0 - w_2), np.sqrt(w_2)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="n">v_z</span><span class="p">))</span>
        <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">q</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">q</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">v_y</span> <span class="o">/</span> <span class="n">s</span><span class="p">,</span> <span class="o">-</span> <span class="n">v_x</span> <span class="o">/</span> <span class="n">s</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">s</span> <span class="o">/</span> <span class="mi">2</span>

    <span class="c1"># First order quaternion normalization to prevent compounding of errors.</span>
    <span class="c1"># If not done, shit may happen with removing twist again and again on the</span>
    <span class="c1"># same quaternion, which is typically the case when the IMU is steady, so</span>
    <span class="c1"># that the mahony filter update is actually skipped internally.</span>
    <span class="n">q</span> <span class="o">*=</span> <span class="p">(</span><span class="mf">3.0</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">q</span><span class="p">),</span> <span class="mi">0</span><span class="p">))</span> <span class="o">/</span> <span class="mi">2</span></div>



<span class="nd">@overload</span>
<span class="k">def</span> <span class="nf">remove_yaw_from_quat</span><span class="p">(</span><span class="n">quat</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="o">...</span>


<span class="nd">@overload</span>
<span class="k">def</span> <span class="nf">remove_yaw_from_quat</span><span class="p">(</span><span class="n">quat</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                         <span class="n">out</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="o">...</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="o">...</span>


<div class="viewcode-block" id="remove_yaw_from_quat">
<a class="viewcode-back" href="../../../../api/gym_jiminy/common/utils/math.html#gym_jiminy.common.utils.math.remove_yaw_from_quat">[docs]</a>
<span class="nd">@nb</span><span class="o">.</span><span class="n">jit</span><span class="p">(</span><span class="n">nopython</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">remove_yaw_from_quat</span><span class="p">(</span><span class="n">quat</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                         <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
                         <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Remove the rotation around z-axis of a single or batch of quaternions.</span>

<span class="sd">    .. note::</span>
<span class="sd">        Note that this decomposition is rarely used in practice, mainly because</span>
<span class="sd">        of singularity issues related to the Roll-Pitch-Yaw decomposition. It</span>
<span class="sd">        is usually preferable to remove the twist part of the Twist-after-Swing</span>
<span class="sd">        decomposition. Note that in both cases, the Roll and Pitch angles from</span>
<span class="sd">        their corresponding Yaw-Pitch-Roll Euler angles representation matches</span>
<span class="sd">        exactly. See `remove_twist_from_quat` documentation for details.</span>

<span class="sd">    :param quat: N-dimensional array whose first dimension gathers the 4</span>
<span class="sd">                 quaternion coordinates (qx, qy, qz, qw).</span>
<span class="sd">    :param out: Pre-allocated array into which to store the result. If not</span>
<span class="sd">                provided, a new array is freshly-allocated and returned, which</span>
<span class="sd">                is slower.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Allocate memory for the output array</span>
    <span class="k">assert</span> <span class="n">quat</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;=</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">out_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">quat</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">out</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">quat</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">out_</span> <span class="o">=</span> <span class="n">out</span>

    <span class="c1"># Compute some intermediary quantities</span>
    <span class="n">q_xx</span><span class="p">,</span> <span class="p">(</span><span class="n">q_xz</span><span class="p">,</span> <span class="n">q_xw</span><span class="p">)</span> <span class="o">=</span> <span class="n">quat</span><span class="p">[</span><span class="o">-</span><span class="mi">4</span><span class="p">]</span> <span class="o">*</span> <span class="n">quat</span><span class="p">[</span><span class="o">-</span><span class="mi">4</span><span class="p">],</span> <span class="n">quat</span><span class="p">[</span><span class="o">-</span><span class="mi">4</span><span class="p">]</span> <span class="o">*</span> <span class="n">quat</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:]</span>
    <span class="n">q_yy</span><span class="p">,</span> <span class="n">q_yz</span><span class="p">,</span> <span class="n">q_yw</span> <span class="o">=</span> <span class="n">quat</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">]</span> <span class="o">*</span> <span class="n">quat</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">:]</span>

    <span class="c1"># Compute some intermediary quantities</span>
    <span class="n">cos_roll</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">q_xx</span> <span class="o">+</span> <span class="n">q_yy</span><span class="p">)</span>
    <span class="n">sin_roll</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">q_xw</span> <span class="o">+</span> <span class="n">q_yz</span><span class="p">)</span>
    <span class="n">cos_roll</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">cos_roll</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">sin_roll</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">cos_roll_2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="n">cos_roll</span><span class="p">))</span>
    <span class="n">sin_roll_2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">sin_roll</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">cos_roll</span><span class="p">))</span>
    <span class="n">sin_pitch</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">q_yw</span> <span class="o">-</span> <span class="n">q_xz</span><span class="p">)</span>
    <span class="n">cos_pitch</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">sin_pitch</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">cos_pitch_2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="n">cos_pitch</span><span class="p">))</span>
    <span class="n">sin_pitch_2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">sin_pitch</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">cos_pitch</span><span class="p">))</span>

    <span class="c1"># q_x, q_y, q_z, q_w = out_</span>
    <span class="n">out_</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">+</span> <span class="n">sin_roll_2</span> <span class="o">*</span> <span class="n">cos_pitch_2</span>
    <span class="n">out_</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">+</span> <span class="n">cos_roll_2</span> <span class="o">*</span> <span class="n">sin_pitch_2</span>
    <span class="n">out_</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span> <span class="n">sin_roll_2</span> <span class="o">*</span> <span class="n">sin_pitch_2</span>
    <span class="n">out_</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="o">+</span> <span class="n">cos_roll_2</span> <span class="o">*</span> <span class="n">cos_pitch_2</span>

    <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">out_</span>
    <span class="k">return</span> <span class="kc">None</span></div>



<span class="c1"># FIXME: Enabling cache causes segfault on Apple Silicon</span>
<div class="viewcode-block" id="remove_twist_from_quat">
<a class="viewcode-back" href="../../../../api/gym_jiminy/common/utils/math.html#gym_jiminy.common.utils.math.remove_twist_from_quat">[docs]</a>
<span class="nd">@nb</span><span class="o">.</span><span class="n">jit</span><span class="p">(</span><span class="n">nopython</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">remove_twist_from_quat</span><span class="p">(</span><span class="n">quat</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                           <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Remove the twist part of the Twist-after-Swing decomposition of given</span>
<span class="sd">    orientations in quaternion representation.</span>

<span class="sd">    Any rotation R can be decomposed as:</span>

<span class="sd">        R = R_z * R_s</span>

<span class="sd">    where R_z (the twist) is a rotation around e_z and R_s (the swing) is</span>
<span class="sd">    the &quot;smallest&quot; rotation matrix (in terms of angle of its corresponding</span>
<span class="sd">    Axis-Angle representation) such that s(R_s) = s(R). Note that although the</span>
<span class="sd">    swing is not free of rotation around z-axis, the latter only depends on the</span>
<span class="sd">    rotation around e_x, e_y, which is the main motivation for using this</span>
<span class="sd">    decomposition. One must use `remove_yaw_from_quat` to completely cancel you</span>
<span class="sd">    the rotation around z-axis.</span>

<span class="sd">    .. seealso::</span>
<span class="sd">        * See &quot;Estimation and control of the deformations of an exoskeleton</span>
<span class="sd">          using inertial sensors&quot;, PhD Thesis, M. Vigne, 2021, p. 130.</span>
<span class="sd">        * See &quot;Swing-twist decomposition in Clifford algebra&quot;, P. Dobrowolski,</span>
<span class="sd">          2015 (https://arxiv.org/abs/1506.05481)</span>

<span class="sd">    :param q: Array whose rows are the 4 components of quaternions (x, y, z, w)</span>
<span class="sd">              and columns are N independent orientations from which to remove</span>
<span class="sd">              the swing part.</span>
<span class="sd">    :param out: Pre-allocated array into which to store the result. `None` to</span>
<span class="sd">                update the input quaternion in-place.</span>
<span class="sd">                Optional: `None` by default.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Update in-place in no out has been specified</span>
    <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">out_</span> <span class="o">=</span> <span class="n">quat</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">out</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">quat</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">out_</span> <span class="o">=</span> <span class="n">out</span>

    <span class="c1"># Compute e_z in R(q) frame (Euler-Rodrigues Formula): R(q).T @ e_z</span>
    <span class="n">v_a</span> <span class="o">=</span> <span class="n">compute_tilt_from_quat</span><span class="p">(</span><span class="n">quat</span><span class="p">)</span>

    <span class="c1"># Compute the &quot;smallest&quot; rotation transforming vector &#39;v_a&#39; in &#39;e_z&#39;</span>
    <span class="n">swing_from_vector</span><span class="p">(</span><span class="n">v_a</span><span class="p">,</span> <span class="n">out_</span><span class="p">)</span></div>



<div class="viewcode-block" id="quat_average">
<a class="viewcode-back" href="../../../../api/gym_jiminy/common/utils/math.html#gym_jiminy.common.utils.math.quat_average">[docs]</a>
<span class="k">def</span> <span class="nf">quat_average</span><span class="p">(</span><span class="n">quat</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                 <span class="n">axes</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span>
                 <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute the average of a batch of quaternions (qx, qy, qz, qw) over some</span>
<span class="sd">    or all axes.</span>

<span class="sd">    Here, the average is defined as a quaternion minimizing the mean error</span>
<span class="sd">    wrt every individual quaternion. The distance metric used as error is the</span>
<span class="sd">    dot product of quaternions `p.dot(q)`, which is directly related to the</span>
<span class="sd">    angle between them `cos(angle(p.conjugate() * q) / 2)`. This metric as the</span>
<span class="sd">    major advantage to yield a quadratic problem, which can be solved very</span>
<span class="sd">    efficiently, unlike the squared angle `angle(p.conjugate() * q) ** 2`.</span>

<span class="sd">    :param quat: N-dimensional (N &gt;= 2) array whose first dimension gathers the</span>
<span class="sd">                 4 quaternion coordinates (qx, qy, qz, qw).</span>
<span class="sd">    :param axes: Batch dimensions to preserve without computing the average.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># TODO: This function cannot be jitted because numba does not support</span>
    <span class="c1"># batched matrix multiplication for now. See official issue for details:</span>
    <span class="c1"># https://github.com/numba/numba/issues/3804</span>
    <span class="k">assert</span> <span class="n">quat</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;=</span> <span class="mi">2</span>
    <span class="k">if</span> <span class="n">axes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">axes</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">quat</span><span class="o">.</span><span class="n">ndim</span><span class="p">))</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">axes</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
        <span class="n">axes</span> <span class="o">=</span> <span class="p">(</span><span class="n">axes</span><span class="p">,)</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">axes</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="mi">0</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">axes</span>

    <span class="n">q_perm</span> <span class="o">=</span> <span class="n">quat</span><span class="o">.</span><span class="n">transpose</span><span class="p">((</span>
        <span class="o">*</span><span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">quat</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">axes</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="o">*</span><span class="n">axes</span><span class="p">))</span>
    <span class="n">q_flat</span> <span class="o">=</span> <span class="n">q_perm</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">*</span><span class="n">q_perm</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">axes</span><span class="p">)],</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">eigvec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eigh</span><span class="p">(</span><span class="n">q_flat</span> <span class="o">@</span> <span class="n">np</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="n">q_flat</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">eigvec</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span></div>



<span class="nd">@overload</span>
<span class="k">def</span> <span class="nf">quat_interpolate_middle</span><span class="p">(</span><span class="n">quat1</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                            <span class="n">quat2</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                            <span class="n">out</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="o">...</span>


<span class="nd">@overload</span>
<span class="k">def</span> <span class="nf">quat_interpolate_middle</span><span class="p">(</span><span class="n">quat1</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                            <span class="n">quat2</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                            <span class="n">out</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="o">...</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="o">...</span>


<div class="viewcode-block" id="quat_interpolate_middle">
<a class="viewcode-back" href="../../../../api/gym_jiminy/common/utils/math.html#gym_jiminy.common.utils.math.quat_interpolate_middle">[docs]</a>
<span class="nd">@nb</span><span class="o">.</span><span class="n">jit</span><span class="p">(</span><span class="n">nopython</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">fastmath</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">quat_interpolate_middle</span><span class="p">(</span><span class="n">quat1</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                            <span class="n">quat2</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                            <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
                            <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute the midpoint interpolation between two batches of quaternions</span>
<span class="sd">    (qx, qy, qz, qw).</span>

<span class="sd">    The midpoint interpolation of two quaternion is defined as the integration</span>
<span class="sd">    of half the difference between them, starting from the first one, ie</span>
<span class="sd">    `q_mid = integrate(q1, 0.5 * difference(q1, d2))`, which is a special case</span>
<span class="sd">    of the `slerp` method (spherical linear interpolation) for `alpha=0.5`.</span>

<span class="sd">    For the midpoint in particular, one can show that the middle quaternion is</span>
<span class="sd">    simply normalized sum of the previous and next quaternions.</span>

<span class="sd">    :param quat1: First batch of quaternions as a N-dimensional array whose</span>
<span class="sd">                  first dimension gathers the 4 quaternion coordinates.</span>
<span class="sd">    :param quat2: Second batch of quaternions as a N-dimensional array.</span>
<span class="sd">    :param out: Pre-allocated array in which to store the result. If not</span>
<span class="sd">                provided, a new array is freshly-allocated and returned, which</span>
<span class="sd">                is slower.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="n">quat1</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;=</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">quat1</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">quat2</span><span class="o">.</span><span class="n">shape</span>
    <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">out_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span> <span class="o">*</span><span class="n">quat1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">out</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="o">*</span><span class="n">quat1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
        <span class="n">out_</span> <span class="o">=</span> <span class="n">out</span>

    <span class="n">dot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">quat1</span> <span class="o">*</span> <span class="n">quat2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">dot_</span> <span class="o">=</span> <span class="n">dot</span> <span class="k">if</span> <span class="n">quat1</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">dot</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">out_</span><span class="p">[:]</span> <span class="o">=</span> <span class="p">(</span><span class="n">quat1</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">dot_</span><span class="p">)</span> <span class="o">*</span> <span class="n">quat2</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">dot_</span><span class="p">)))</span>

    <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">out_</span>
    <span class="k">return</span> <span class="kc">None</span></div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2020, Alexis Duburcq - MIT licence.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>