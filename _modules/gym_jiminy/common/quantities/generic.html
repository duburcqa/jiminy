

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>gym_jiminy.common.quantities.generic &mdash; jiminy 1.8.12 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../../../../_static/css/theme.css?v=e59714d7" />

  
      <script src="../../../../_static/documentation_options.js?v=32cf9813"></script>
      <script src="../../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../../index.html" class="icon icon-home">
            jiminy
              <img src="../../../../_static/jiminy_logo.svg" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">README</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../README.html">Key features</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../README.html#gym-jiminy">Gym Jiminy</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../README.html#demo">Demo</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../README.html#getting-started">Getting started</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">INSTALLATION</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../INSTALL.html">Easy-install on Ubuntu 18+</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../INSTALL.html#building-from-source">Building from source</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">TUTORIALS</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../tutorial.html">An introduction to Jiminy</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">API DOC</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/jiminy/index.html">Jiminy C++ API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/jiminy_py/index.html">Jiminy Python API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/gym_jiminy/common/index.html">Gym Jiminy API</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Technical Specifications</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../spec/src/tlmc_format_specification.html">HDF5 telemetry log format (TLMC)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../spec/pdf/index.html">Downloadable PDF</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../index.html">jiminy</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">gym_jiminy.common.quantities.generic</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for gym_jiminy.common.quantities.generic</h1><div class="highlight"><pre>
<span></span><span class="c1"># pylint: disable=redefined-builtin</span>
<span class="sd">&quot;&quot;&quot;Generic quantities that may be relevant for any kind of robot, regardless</span>
<span class="sd">its topology (multiple or single branch, fixed or floating base...) and the</span>
<span class="sd">application (locomotion, grasping...).</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">from</span> <span class="nn">enum</span> <span class="kn">import</span> <span class="n">IntEnum</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">partial</span>
<span class="kn">from</span> <span class="nn">operator</span> <span class="kn">import</span> <span class="n">attrgetter</span>
<span class="kn">from</span> <span class="nn">dataclasses</span> <span class="kn">import</span> <span class="n">dataclass</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">List</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Protocol</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Callable</span><span class="p">,</span>
    <span class="n">runtime_checkable</span><span class="p">)</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">numba</span> <span class="k">as</span> <span class="nn">nb</span>

<span class="kn">import</span> <span class="nn">jiminy_py.core</span> <span class="k">as</span> <span class="nn">jiminy</span>
<span class="kn">from</span> <span class="nn">jiminy_py.core</span> <span class="kn">import</span> <span class="p">(</span>  <span class="c1"># pylint: disable=no-name-in-module</span>
    <span class="n">multi_array_copyto</span><span class="p">)</span>
<span class="kn">import</span> <span class="nn">pinocchio</span> <span class="k">as</span> <span class="nn">pin</span>
<span class="kn">import</span> <span class="nn">hppfcl</span> <span class="k">as</span> <span class="nn">fcl</span>

<span class="kn">from</span> <span class="nn">..bases</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">InterfaceJiminyEnv</span><span class="p">,</span> <span class="n">InterfaceQuantity</span><span class="p">,</span> <span class="n">AbstractQuantity</span><span class="p">,</span> <span class="n">StateQuantity</span><span class="p">,</span>
    <span class="n">QuantityEvalMode</span><span class="p">,</span> <span class="n">partial_hashable</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">..utils</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">mean</span><span class="p">,</span> <span class="n">matrix_to_rpy</span><span class="p">,</span> <span class="n">matrix_to_quat</span><span class="p">,</span> <span class="n">quat_apply</span><span class="p">,</span> <span class="n">remove_yaw_from_quat</span><span class="p">,</span>
    <span class="n">quat_interpolate_middle</span><span class="p">)</span>

<span class="kn">from</span> <span class="nn">.transform</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">StackedQuantity</span><span class="p">,</span> <span class="n">MaskedQuantity</span><span class="p">,</span> <span class="n">UnaryOpQuantity</span><span class="p">,</span> <span class="n">BinaryOpQuantity</span><span class="p">)</span>


<div class="viewcode-block" id="FrameQuantity">
<a class="viewcode-back" href="../../../../api/gym_jiminy/common/quantities/generic.html#gym_jiminy.common.quantities.generic.FrameQuantity">[docs]</a>
<span class="nd">@runtime_checkable</span>
<span class="k">class</span> <span class="nc">FrameQuantity</span><span class="p">(</span><span class="n">Protocol</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Protocol that must be satisfied by all quantities associated with one</span>
<span class="sd">    particular frame.</span>

<span class="sd">    This protocol is used when aggregating individual frame-level quantities</span>
<span class="sd">    in a larger batch for computation vectorization on all frames at once.</span>
<span class="sd">    Intermediate quantities managing these batches will make sure that all</span>
<span class="sd">    their parents derive from one of the supported protocols, which includes</span>
<span class="sd">    this one.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">frame_name</span><span class="p">:</span> <span class="nb">str</span></div>



<div class="viewcode-block" id="MultiFrameQuantity">
<a class="viewcode-back" href="../../../../api/gym_jiminy/common/quantities/generic.html#gym_jiminy.common.quantities.generic.MultiFrameQuantity">[docs]</a>
<span class="nd">@runtime_checkable</span>
<span class="k">class</span> <span class="nc">MultiFrameQuantity</span><span class="p">(</span><span class="n">Protocol</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Protocol that must be satisfied by all quantities associated with</span>
<span class="sd">    a particular set of frames for which the same batched intermediary</span>
<span class="sd">    quantities must be computed.</span>

<span class="sd">    This protocol is involved in automatic computation vectorization. See</span>
<span class="sd">    `FrameQuantity` documentation for details.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">frame_names</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span></div>



<div class="viewcode-block" id="aggregate_frame_names">
<a class="viewcode-back" href="../../../../api/gym_jiminy/common/quantities/generic.html#gym_jiminy.common.quantities.generic.aggregate_frame_names">[docs]</a>
<span class="k">def</span> <span class="nf">aggregate_frame_names</span><span class="p">(</span><span class="n">quantity</span><span class="p">:</span> <span class="n">InterfaceQuantity</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span>
        <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span>
        <span class="n">Dict</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">]],</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[()],</span> <span class="nb">slice</span><span class="p">]]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Generate a sequence of frame names that contains all the sub-sequences</span>
<span class="sd">    specified by the parents of all the cache owners of a given quantity.</span>

<span class="sd">    Ideally, the generated sequence should be the shortest possible. Since</span>
<span class="sd">    finding the optimal sequence is a complex problem, a heuristic is used</span>
<span class="sd">    instead. It consists in aggregating first all multi-frame quantities</span>
<span class="sd">    sequentially after ordering them by decreasing length, followed by all</span>
<span class="sd">    single-frame quantities.</span>

<span class="sd">    .. note::</span>
<span class="sd">        Only active quantities are considered for best performance, which may</span>
<span class="sd">        change dynamically. Delegating this responsibility to cache owners may</span>
<span class="sd">        be possible but difficult to implement because `frame_names` must be</span>
<span class="sd">        cleared first before re-registering themselves, just in case of optimal</span>
<span class="sd">        computation graph has changed, not only once to avoid getting rid of</span>
<span class="sd">        quantities that just registered themselves. Nevertheless, whenever</span>
<span class="sd">        re-initializing this quantity to take into account changes of the</span>
<span class="sd">        active set must be decided by cache owners.</span>

<span class="sd">    :param quantity: Quantity whose parent implements either `FrameQuantity` or</span>
<span class="sd">                     `MultiFrameQuantity` protocol. All the parents of all its</span>
<span class="sd">                     cache owners must also implement one of these protocol.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Make sure that parent quantity implement multi- or single-frame protocol</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">quantity</span><span class="o">.</span><span class="n">parent</span><span class="p">,</span> <span class="p">(</span><span class="n">FrameQuantity</span><span class="p">,</span> <span class="n">MultiFrameQuantity</span><span class="p">))</span>
    <span class="n">quantities</span> <span class="o">=</span> <span class="p">(</span><span class="n">quantity</span><span class="o">.</span><span class="n">cache</span><span class="o">.</span><span class="n">owners</span> <span class="k">if</span> <span class="n">quantity</span><span class="o">.</span><span class="n">has_cache</span> <span class="k">else</span> <span class="p">(</span><span class="n">quantity</span><span class="p">,))</span>

    <span class="c1"># First, order all multi-frame quantities by decreasing length</span>
    <span class="n">frame_names_chunks</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">owner</span> <span class="ow">in</span> <span class="n">quantities</span><span class="p">:</span>
        <span class="n">parent</span> <span class="o">=</span> <span class="n">owner</span><span class="o">.</span><span class="n">parent</span>
        <span class="k">assert</span> <span class="n">parent</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">parent</span><span class="o">.</span><span class="n">is_active</span><span class="p">(</span><span class="n">any_cache_owner</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">MultiFrameQuantity</span><span class="p">):</span>
                <span class="n">frame_names_chunks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">parent</span><span class="o">.</span><span class="n">frame_names</span><span class="p">)</span>

    <span class="c1"># Next, process ordered multi-frame quantities sequentially.</span>
    <span class="c1"># For each of them, we first check if its set of frames is completely</span>
    <span class="c1"># included in the current full set. If so, then there is nothing do not and</span>
    <span class="c1"># we can move to the next quantity. If not, then we check if a part of its</span>
    <span class="c1"># tail or head is contained at the beginning or end of the full set</span>
    <span class="c1"># respectively. If so, only the missing part is prepended or appended</span>
    <span class="c1"># respectively. If not, then the while set of frames is appended to the</span>
    <span class="c1"># current full set before moving to the next quantity.</span>
    <span class="n">frame_names</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">frame_names_chunks</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">frame_names_chunks</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="nb">len</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">frame_names_</span> <span class="ow">in</span> <span class="nb">map</span><span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="n">frame_names_chunks</span><span class="p">):</span>
        <span class="n">nframes</span><span class="p">,</span> <span class="n">nframes_</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="nb">len</span><span class="p">,</span> <span class="p">(</span><span class="n">frame_names</span><span class="p">,</span> <span class="n">frame_names_</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nframes</span> <span class="o">-</span> <span class="n">nframes_</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="c1"># Check if the sub-chain is completely included in the</span>
            <span class="c1"># current full set.</span>
            <span class="k">if</span> <span class="n">frame_names_</span> <span class="o">==</span> <span class="n">frame_names</span><span class="p">[</span><span class="n">i</span><span class="p">:(</span><span class="n">i</span> <span class="o">+</span> <span class="n">nframes_</span><span class="p">)]:</span>
                <span class="k">break</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nframes_</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                <span class="c1"># Check if part of the frame names matches with the</span>
                <span class="c1"># tail of the current full set. If so, append the</span>
                <span class="c1"># disjoint head only.</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">frame_names</span><span class="p">[(</span><span class="n">nframes</span> <span class="o">-</span> <span class="n">nframes_</span> <span class="o">+</span> <span class="n">i</span><span class="p">):]</span> <span class="o">==</span>
                        <span class="n">frame_names_</span><span class="p">[:(</span><span class="n">nframes_</span> <span class="o">-</span> <span class="n">i</span><span class="p">)]):</span>
                    <span class="n">frame_names</span> <span class="o">+=</span> <span class="n">frame_names_</span><span class="p">[(</span><span class="n">nframes_</span> <span class="o">-</span> <span class="n">i</span><span class="p">):]</span>
                    <span class="k">break</span>
                <span class="c1"># Check if part of the frame names matches with the</span>
                <span class="c1"># head of the current full set. If so, prepend the</span>
                <span class="c1"># disjoint tail only.</span>
                <span class="k">if</span> <span class="n">frame_names</span><span class="p">[:(</span><span class="n">nframes_</span> <span class="o">-</span> <span class="n">i</span><span class="p">)]</span> <span class="o">==</span> <span class="n">frame_names_</span><span class="p">[</span><span class="n">i</span><span class="p">:]:</span>
                    <span class="n">frame_names</span> <span class="o">=</span> <span class="n">frame_names_</span><span class="p">[:</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">frame_names</span>
                    <span class="k">break</span>

    <span class="c1"># Finally, loop over all single-frame quantities.</span>
    <span class="c1"># If a frame name is missing, then it is appended to the current full set.</span>
    <span class="c1"># Otherwise, we just move to the next quantity.</span>
    <span class="n">frame_name_chunks</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">owner</span> <span class="ow">in</span> <span class="n">quantities</span><span class="p">:</span>
        <span class="n">parent</span> <span class="o">=</span> <span class="n">owner</span><span class="o">.</span><span class="n">parent</span>
        <span class="k">assert</span> <span class="n">parent</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">parent</span><span class="o">.</span><span class="n">is_active</span><span class="p">(</span><span class="n">any_cache_owner</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">FrameQuantity</span><span class="p">):</span>
                <span class="n">frame_name_chunks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">parent</span><span class="o">.</span><span class="n">frame_name</span><span class="p">)</span>
                <span class="n">frame_name</span> <span class="o">=</span> <span class="n">frame_name_chunks</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">frame_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">frame_names</span><span class="p">:</span>
                    <span class="n">frame_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">frame_name</span><span class="p">)</span>
    <span class="n">frame_names</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">frame_names</span><span class="p">)</span>

    <span class="c1"># Compute mapping from frame names to their corresponding indices in the</span>
    <span class="c1"># generated sequence of frame names.</span>
    <span class="c1"># The indices are stored as a slice for non-empty multi-frame quantities,</span>
    <span class="c1"># as an empty tuple for empty multi-frame quantities, or as an integer for</span>
    <span class="c1"># single-frame quantities.</span>
    <span class="n">frame_slices</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span>
        <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">]],</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[()],</span> <span class="nb">slice</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">nframes</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">frame_names</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">frame_names_</span> <span class="ow">in</span> <span class="n">frame_names_chunks</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">frame_names_</span> <span class="ow">in</span> <span class="n">frame_slices</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">frame_names_</span><span class="p">:</span>
            <span class="n">frame_slices</span><span class="p">[</span><span class="n">frame_names_</span><span class="p">]</span> <span class="o">=</span> <span class="p">()</span>
            <span class="k">continue</span>
        <span class="n">nframes_</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">frame_names_</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nframes</span> <span class="o">-</span> <span class="n">nframes_</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">frame_names_</span> <span class="o">==</span> <span class="n">frame_names</span><span class="p">[</span><span class="n">i</span><span class="p">:(</span><span class="n">i</span> <span class="o">+</span> <span class="n">nframes_</span><span class="p">)]:</span>
                <span class="k">break</span>
        <span class="n">frame_slices</span><span class="p">[</span><span class="n">frame_names_</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="n">nframes_</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">frame_name</span> <span class="ow">in</span> <span class="n">frame_name_chunks</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">frame_name</span> <span class="ow">in</span> <span class="n">frame_slices</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="n">frame_slices</span><span class="p">[</span><span class="n">frame_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">frame_names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">frame_name</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">frame_names</span><span class="p">,</span> <span class="n">frame_slices</span></div>



<span class="nd">@dataclass</span><span class="p">(</span><span class="n">unsafe_hash</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">_BatchedFramesRotationMatrix</span><span class="p">(</span>
        <span class="n">AbstractQuantity</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">]],</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;3D rotation matrix of the orientation of all frames involved in</span>
<span class="sd">    quantities relying on it and are active since last reset of computation</span>
<span class="sd">    tracking if shared cache is available, its parent otherwise.</span>

<span class="sd">    This quantity only provides a performance benefit when managed by some</span>
<span class="sd">    `QuantityManager`. It is not supposed to be instantiated manually but use</span>
<span class="sd">    as requirement of some other quantity for computation vectorization on all</span>
<span class="sd">    frames at once.</span>

<span class="sd">    The data associated with each frame is exposed to the user as a batched 3D</span>
<span class="sd">    contiguous array. The two first dimensions are rotation matrix elements,</span>
<span class="sd">    while the last one are individual frames with the same ordering as</span>
<span class="sd">    &#39;self.frame_names&#39;.</span>

<span class="sd">    .. note::</span>
<span class="sd">        This quantity does not allow for specifying frames directly. There is</span>
<span class="sd">        no way to get the orientation of multiple frames at once for now.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">env</span><span class="p">:</span> <span class="n">InterfaceJiminyEnv</span><span class="p">,</span>
                 <span class="n">parent</span><span class="p">:</span> <span class="n">InterfaceQuantity</span><span class="p">,</span>
                 <span class="n">mode</span><span class="p">:</span> <span class="n">QuantityEvalMode</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param env: Base or wrapped jiminy environment.</span>
<span class="sd">        :param parent: Higher-level quantity from which this quantity is a</span>
<span class="sd">                       requirement.</span>
<span class="sd">        :param mode: Desired mode of evaluation for this quantity.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Make sure that a parent has been specified</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="p">(</span><span class="n">FrameQuantity</span><span class="p">,</span> <span class="n">MultiFrameQuantity</span><span class="p">))</span>

        <span class="c1"># Call base implementation</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">env</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">requirements</span><span class="o">=</span><span class="p">{},</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span> <span class="n">auto_refresh</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># Initialize the ordered list of frame names</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">frame_names</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="p">()</span>

        <span class="c1"># Store all rotation matrices at once</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_rot_mat_batch</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>

        <span class="c1"># Define proxy for views of the batch storing all rotation matrices</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_rot_mat_views</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Define proxy for the rotation matrices of all frames</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_rot_mat_list</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Mapping from frame names to views of batched rotation matrices</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_rot_mat_map</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">]],</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Deactivate all cache owners first since only one is tracking frames</span>
        <span class="k">for</span> <span class="n">quantity</span> <span class="ow">in</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="o">.</span><span class="n">owners</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_cache</span> <span class="k">else</span> <span class="p">(</span><span class="bp">self</span><span class="p">,)):</span>
            <span class="n">quantity</span><span class="o">.</span><span class="n">_is_active</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># Call base implementation</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">initialize</span><span class="p">()</span>

        <span class="c1"># Update the frame names based on the cache owners of this quantity</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">frame_names</span><span class="p">,</span> <span class="n">frame_slices</span> <span class="o">=</span> <span class="n">aggregate_frame_names</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="c1"># Re-allocate memory as the number of frames is not known in advance.</span>
        <span class="c1"># Note that Fortran memory layout (column-major) is used for speed up</span>
        <span class="c1"># because it preserves contiguity when copying frame data.</span>
        <span class="c1"># Anyway, C memory layout (row-major) does not make sense in this case</span>
        <span class="c1"># since chunks of columns are systematically extracted, which means</span>
        <span class="c1"># that the returned array would NEVER be contiguous.</span>
        <span class="n">nframes</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">frame_names</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_rot_mat_batch</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">nframes</span><span class="p">),</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span>

        <span class="c1"># Refresh proxies</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_rot_mat_views</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_rot_mat_list</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">frame_name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">frame_names</span><span class="p">):</span>
            <span class="n">frame_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pinocchio_model</span><span class="o">.</span><span class="n">getFrameId</span><span class="p">(</span><span class="n">frame_name</span><span class="p">)</span>
            <span class="n">rot_matrix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pinocchio_data</span><span class="o">.</span><span class="n">oMf</span><span class="p">[</span><span class="n">frame_index</span><span class="p">]</span><span class="o">.</span><span class="n">rotation</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_rot_mat_views</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_rot_mat_batch</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">i</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_rot_mat_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rot_matrix</span><span class="p">)</span>

        <span class="c1"># Re-assign mapping from frame names to their corresponding data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_rot_mat_map</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">key</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rot_mat_batch</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">frame_slice</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">frame_slice</span> <span class="ow">in</span> <span class="n">frame_slices</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>

    <span class="k">def</span> <span class="nf">refresh</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">]],</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
        <span class="c1"># Copy all rotation matrices in contiguous buffer</span>
        <span class="n">multi_array_copyto</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_rot_mat_views</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rot_mat_list</span><span class="p">)</span>

        <span class="c1"># Return proxy directly without copy</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rot_mat_map</span>


<div class="viewcode-block" id="OrientationType">
<a class="viewcode-back" href="../../../../api/gym_jiminy/common/quantities/generic.html#gym_jiminy.common.quantities.generic.OrientationType">[docs]</a>
<span class="k">class</span> <span class="nc">OrientationType</span><span class="p">(</span><span class="n">IntEnum</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Specify the desired vector representation of the frame orientations.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">MATRIX</span> <span class="o">=</span> <span class="mi">0</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;3D rotation matrix.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">EULER</span> <span class="o">=</span> <span class="mi">1</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Euler angles (Roll, Pitch, Yaw).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">QUATERNION</span> <span class="o">=</span> <span class="mi">2</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Quaternion coordinates (QuatX, QuatY, QuatZ, QuatW).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">ANGLE_AXIS</span> <span class="o">=</span> <span class="mi">3</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Angle-Axis representation (theta * AxisX, theta * AxisY, theta * AxisZ).</span>
<span class="sd">    &quot;&quot;&quot;</span></div>



<span class="c1"># Define proxies for fast lookup</span>
<span class="n">_MATRIX</span><span class="p">,</span> <span class="n">_EULER</span><span class="p">,</span> <span class="n">_QUATERNION</span><span class="p">,</span> <span class="n">_ANGLE_AXIS</span> <span class="o">=</span> <span class="p">(</span>  <span class="c1"># pylint: disable=invalid-name</span>
    <span class="n">OrientationType</span><span class="p">)</span>


<span class="nd">@dataclass</span><span class="p">(</span><span class="n">unsafe_hash</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">_BatchedFramesOrientation</span><span class="p">(</span>
        <span class="n">InterfaceQuantity</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">]],</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Vector representation of the orientation in world reference frame of all</span>
<span class="sd">    frames involved in quantities relying on it and are active since last reset</span>
<span class="sd">    of computation tracking if shared cache is available, its parent otherwise.</span>

<span class="sd">    The vector representation of the orientation of all the frames are stacked</span>
<span class="sd">    in a single contiguous N-dimensional array whose last dimension corresponds</span>
<span class="sd">    to the individual frames.</span>

<span class="sd">    The orientation of all frames is exposed to the user as a dictionary whose</span>
<span class="sd">    keys are the individual frame names. Internally, data are stored in batched</span>
<span class="sd">    2D contiguous array for efficiency. The first dimension gathers the 3 Euler</span>
<span class="sd">    angles (roll, pitch, yaw), while the second one are individual frames with</span>
<span class="sd">    the same ordering as &#39;self.frame_names&#39;.</span>

<span class="sd">    This quantity is used internally by `FrameOrientation`. It is not supposed</span>
<span class="sd">    to be instantiated manually. See `_BatchedFramesRotationMatrix`</span>
<span class="sd">    documentation for details.</span>

<span class="sd">    In the particular case of Euler angle representation, the expected maximum</span>
<span class="sd">    speedup wrt computing Euler angles individually is about x15, which is</span>
<span class="sd">    achieved asymptotically for more than 100 frames. Still, it is already x5</span>
<span class="sd">    faster for 5 frames, x7 for 10 frames, and x9 for 20 frames.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nb">type</span><span class="p">:</span> <span class="n">OrientationType</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Selected vector representation of the orientation for all frames.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">mode</span><span class="p">:</span> <span class="n">QuantityEvalMode</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Specify on which state to evaluate this quantity. See `QuantityEvalMode`</span>
<span class="sd">    documentation for details about each mode.</span>

<span class="sd">    .. warning::</span>
<span class="sd">        Mode `REFERENCE` requires a reference trajectory to be selected</span>
<span class="sd">        manually prior to evaluating this quantity for the first time.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">env</span><span class="p">:</span> <span class="n">InterfaceJiminyEnv</span><span class="p">,</span>
                 <span class="n">parent</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="s2">&quot;FrameOrientation&quot;</span><span class="p">,</span> <span class="s2">&quot;MultiFrameOrientation&quot;</span><span class="p">],</span>
                 <span class="nb">type</span><span class="p">:</span> <span class="n">OrientationType</span><span class="p">,</span>
                 <span class="n">mode</span><span class="p">:</span> <span class="n">QuantityEvalMode</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param env: Base or wrapped jiminy environment.</span>
<span class="sd">        :param parent: `FrameOrientation` or `MultiFrameOrientation` instance</span>
<span class="sd">                       from which this quantity is a requirement.</span>
<span class="sd">        :param type: Desired vector representation of the orientation for all</span>
<span class="sd">                     frames. Note that `OrientationType.ANGLE_AXIS` is not</span>
<span class="sd">                     supported for now.</span>
<span class="sd">        :param mode: Desired mode of evaluation for this quantity.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Make sure that a suitable parent has been provided</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="p">(</span><span class="n">FrameOrientation</span><span class="p">,</span> <span class="n">MultiFrameOrientation</span><span class="p">))</span>

        <span class="c1"># Make sure that the specified orientation representation is supported</span>
        <span class="k">if</span> <span class="nb">type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="n">OrientationType</span><span class="o">.</span><span class="n">MATRIX</span><span class="p">,</span>
                        <span class="n">OrientationType</span><span class="o">.</span><span class="n">EULER</span><span class="p">,</span>
                        <span class="n">OrientationType</span><span class="o">.</span><span class="n">QUATERNION</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;This quantity only supports orientation representations &quot;</span>
                <span class="s2">&quot;&#39;MATRIX&#39;, &#39;EULER&#39;, and &#39;QUATERNION&#39;.&quot;</span><span class="p">)</span>

        <span class="c1"># Backup some user argument(s)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">type</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="o">=</span> <span class="n">mode</span>

        <span class="c1"># Initialize the ordered list of frame names.</span>
        <span class="c1"># Note that this must be done BEFORE calling base `__init__`, otherwise</span>
        <span class="c1"># `isinstance(..., (FrameQuantity, MultiFrameQuantity))` will fail.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">frame_names</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="p">()</span>

        <span class="c1"># Call base implementation</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">env</span><span class="p">,</span>
            <span class="n">parent</span><span class="p">,</span>
            <span class="n">requirements</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span>
                <span class="n">rot_mat_map</span><span class="o">=</span><span class="p">(</span><span class="n">_BatchedFramesRotationMatrix</span><span class="p">,</span> <span class="nb">dict</span><span class="p">(</span><span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">))),</span>
            <span class="n">auto_refresh</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># Mapping from frame names managed by this specific instance to their</span>
        <span class="c1"># corresponding indices in the generated sequence of frame names.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_frame_slices</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span>
            <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">]],</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[()],</span> <span class="nb">slice</span><span class="p">]],</span> <span class="o">...</span>
            <span class="p">]</span> <span class="o">=</span> <span class="p">()</span>

        <span class="c1"># Store the representation of the orientation of all frames at once</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data_batch</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>

        <span class="c1"># Mapping from chunks of frame names to vector representation views</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data_map</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">]],</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Deactivate all cache owners first since only one is tracking frames</span>
        <span class="k">for</span> <span class="n">quantity</span> <span class="ow">in</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="o">.</span><span class="n">owners</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_cache</span> <span class="k">else</span> <span class="p">(</span><span class="bp">self</span><span class="p">,)):</span>
            <span class="n">quantity</span><span class="o">.</span><span class="n">_is_active</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># Call base implementation</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">initialize</span><span class="p">()</span>

        <span class="c1"># Update the frame names based on the cache owners of this quantity</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">frame_names</span><span class="p">,</span> <span class="n">frame_slices_map</span> <span class="o">=</span> <span class="n">aggregate_frame_names</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="c1"># Re-assign mapping of chunk of frame names being managed</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_frame_slices</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">frame_slices_map</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>

        <span class="c1"># Re-allocate memory as the number of frames is not known in advance</span>
        <span class="n">nframes</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">frame_names</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="ow">in</span> <span class="p">(</span><span class="n">OrientationType</span><span class="o">.</span><span class="n">EULER</span><span class="p">,</span> <span class="n">OrientationType</span><span class="o">.</span><span class="n">ANGLE_AXIS</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_data_batch</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">nframes</span><span class="p">),</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">OrientationType</span><span class="o">.</span><span class="n">QUATERNION</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_data_batch</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span> <span class="n">nframes</span><span class="p">),</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span>

        <span class="c1"># Re-assign mapping from chunks of frame names to corresponding data</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">OrientationType</span><span class="o">.</span><span class="n">MATRIX</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_data_map</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">key</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_batch</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">frame_slice</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">frame_slice</span> <span class="ow">in</span> <span class="n">frame_slices_map</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>

    <span class="k">def</span> <span class="nf">refresh</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">]],</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
        <span class="c1"># Get the complete batch of rotation matrices managed by this instance</span>
        <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rot_mat_map</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
        <span class="n">rot_mat_batch</span> <span class="o">=</span> <span class="n">value</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">frame_names</span><span class="p">]</span>

        <span class="c1"># Convert all rotation matrices at once to the desired representation</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">_EULER</span><span class="p">:</span>
            <span class="n">matrix_to_rpy</span><span class="p">(</span><span class="n">rot_mat_batch</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_batch</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">_QUATERNION</span><span class="p">:</span>
            <span class="n">matrix_to_quat</span><span class="p">(</span><span class="n">rot_mat_batch</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_batch</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Slice data.</span>
            <span class="c1"># Note that it cannot be pre-computed once and for all because</span>
            <span class="c1"># the batched data reference may changed dynamically.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_data_map</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">key</span><span class="p">:</span> <span class="n">rot_mat_batch</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">frame_slice</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">frame_slice</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_frame_slices</span><span class="p">}</span>

        <span class="c1"># Return proxy directly without copy</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_map</span>


<div class="viewcode-block" id="FrameOrientation">
<a class="viewcode-back" href="../../../../api/gym_jiminy/common/quantities/generic.html#gym_jiminy.common.quantities.generic.FrameOrientation">[docs]</a>
<span class="nd">@dataclass</span><span class="p">(</span><span class="n">unsafe_hash</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">FrameOrientation</span><span class="p">(</span><span class="n">InterfaceQuantity</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Vector representation of the orientation of a given frame in world</span>
<span class="sd">    reference frame at the end of the agent step.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">frame_name</span><span class="p">:</span> <span class="nb">str</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Name of the frame on which to operate.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nb">type</span><span class="p">:</span> <span class="n">OrientationType</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Desired vector representation of the orientation.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">mode</span><span class="p">:</span> <span class="n">QuantityEvalMode</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Specify on which state to evaluate this quantity. See `QuantityEvalMode`</span>
<span class="sd">    documentation for details about each mode.</span>

<span class="sd">    .. warning::</span>
<span class="sd">        Mode `REFERENCE` requires a reference trajectory to be selected</span>
<span class="sd">        manually prior to evaluating this quantity for the first time.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">env</span><span class="p">:</span> <span class="n">InterfaceJiminyEnv</span><span class="p">,</span>
                 <span class="n">parent</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">InterfaceQuantity</span><span class="p">],</span>
                 <span class="n">frame_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
                 <span class="o">*</span><span class="p">,</span>
                 <span class="nb">type</span><span class="p">:</span> <span class="n">OrientationType</span> <span class="o">=</span> <span class="n">OrientationType</span><span class="o">.</span><span class="n">MATRIX</span><span class="p">,</span>
                 <span class="n">mode</span><span class="p">:</span> <span class="n">QuantityEvalMode</span> <span class="o">=</span> <span class="n">QuantityEvalMode</span><span class="o">.</span><span class="n">TRUE</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param env: Base or wrapped jiminy environment.</span>
<span class="sd">        :param parent: Higher-level quantity from which this quantity is a</span>
<span class="sd">                       requirement if any, `None` otherwise.</span>
<span class="sd">        :param frame_name: Name of the frame on which to operate.</span>
<span class="sd">        :param type: Desired vector representation of the orientation.</span>
<span class="sd">                     Optional: &#39;OrientationType.MATRIX&#39; by default.</span>
<span class="sd">        :param mode: Desired mode of evaluation for this quantity.</span>
<span class="sd">                     Optional: &#39;QuantityEvalMode.TRUE&#39; by default.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Backup some user argument(s)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">frame_name</span> <span class="o">=</span> <span class="n">frame_name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">type</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="o">=</span> <span class="n">mode</span>

        <span class="c1"># Call base implementation</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">env</span><span class="p">,</span>
            <span class="n">parent</span><span class="p">,</span>
            <span class="n">requirements</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span>
                <span class="n">data</span><span class="o">=</span><span class="p">(</span><span class="n">_BatchedFramesOrientation</span><span class="p">,</span> <span class="nb">dict</span><span class="p">(</span>
                    <span class="nb">type</span><span class="o">=</span><span class="nb">type</span><span class="p">,</span>
                    <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">))),</span>
            <span class="n">auto_refresh</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

<div class="viewcode-block" id="FrameOrientation.initialize">
<a class="viewcode-back" href="../../../../api/gym_jiminy/common/quantities/generic.html#gym_jiminy.common.quantities.generic.FrameOrientation.initialize">[docs]</a>
    <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Check if the quantity is already active</span>
        <span class="n">was_active</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_active</span>

        <span class="c1"># Call base implementation</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">initialize</span><span class="p">()</span>

        <span class="c1"># Force re-initializing shared data if the active set has changed</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">was_active</span><span class="p">:</span>
            <span class="c1"># Must reset the tracking for shared computation systematically,</span>
            <span class="c1"># just in case the optimal computation path has changed to the</span>
            <span class="c1"># point that relying on batched quantity is no longer relevant.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">reset</span><span class="p">(</span><span class="n">reset_tracking</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>


<div class="viewcode-block" id="FrameOrientation.refresh">
<a class="viewcode-back" href="../../../../api/gym_jiminy/common/quantities/generic.html#gym_jiminy.common.quantities.generic.FrameOrientation.refresh">[docs]</a>
    <span class="k">def</span> <span class="nf">refresh</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="c1"># Return a slice of batched data.</span>
        <span class="c1"># Note that mapping from frame names to frame index in batched data</span>
        <span class="c1"># cannot be pre-computed as it may changed dynamically.</span>
        <span class="c1"># Note that avoiding defining a temporary variable to store the current</span>
        <span class="c1"># value of the quantity slightly improves performance.</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">get</span><span class="p">()[</span><span class="bp">self</span><span class="o">.</span><span class="n">frame_name</span><span class="p">]</span></div>
</div>



<div class="viewcode-block" id="MultiFrameOrientation">
<a class="viewcode-back" href="../../../../api/gym_jiminy/common/quantities/generic.html#gym_jiminy.common.quantities.generic.MultiFrameOrientation">[docs]</a>
<span class="nd">@dataclass</span><span class="p">(</span><span class="n">unsafe_hash</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">MultiFrameOrientation</span><span class="p">(</span><span class="n">InterfaceQuantity</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Vector representation of the orientation of a given set of frames in</span>
<span class="sd">    world reference frame at the end of the agent step.</span>

<span class="sd">    The vector representation of the orientation of all the frames are stacked</span>
<span class="sd">    in a single contiguous N-dimensional array whose last dimension corresponds</span>
<span class="sd">    to the individual frames. See `_BatchedFramesOrientation` documentation for</span>
<span class="sd">    details.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">frame_names</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Name of the frames on which to operate.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nb">type</span><span class="p">:</span> <span class="n">OrientationType</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Selected vector representation of the orientation for all frames.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">mode</span><span class="p">:</span> <span class="n">QuantityEvalMode</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Specify on which state to evaluate this quantity. See `QuantityEvalMode`</span>
<span class="sd">    documentation for details about each mode.</span>

<span class="sd">    .. warning::</span>
<span class="sd">        Mode `REFERENCE` requires a reference trajectory to be selected</span>
<span class="sd">        manually prior to evaluating this quantity for the first time.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">env</span><span class="p">:</span> <span class="n">InterfaceJiminyEnv</span><span class="p">,</span>
                 <span class="n">parent</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">InterfaceQuantity</span><span class="p">],</span>
                 <span class="n">frame_names</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
                 <span class="o">*</span><span class="p">,</span>
                 <span class="nb">type</span><span class="p">:</span> <span class="n">OrientationType</span> <span class="o">=</span> <span class="n">OrientationType</span><span class="o">.</span><span class="n">MATRIX</span><span class="p">,</span>
                 <span class="n">mode</span><span class="p">:</span> <span class="n">QuantityEvalMode</span> <span class="o">=</span> <span class="n">QuantityEvalMode</span><span class="o">.</span><span class="n">TRUE</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param env: Base or wrapped jiminy environment.</span>
<span class="sd">        :param parent: Higher-level quantity from which this quantity is a</span>
<span class="sd">                       requirement if any, `None` otherwise.</span>
<span class="sd">        :param frame_names: Name of the frames on which to operate.</span>
<span class="sd">        :param type: Desired vector representation of the orientation for all</span>
<span class="sd">                     frames.</span>
<span class="sd">                     Optional: &#39;OrientationType.MATRIX&#39; by default.</span>
<span class="sd">        :param mode: Desired mode of evaluation for this quantity.</span>
<span class="sd">                     Optional: &#39;QuantityEvalMode.TRUE&#39; by default.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Make sure that the user did not pass a single frame name</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">frame_names</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>

        <span class="c1"># Backup some user argument(s)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">frame_names</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">frame_names</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">type</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="o">=</span> <span class="n">mode</span>

        <span class="c1"># Call base implementation</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">env</span><span class="p">,</span>
            <span class="n">parent</span><span class="p">,</span>
            <span class="n">requirements</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span>
                <span class="n">data</span><span class="o">=</span><span class="p">(</span><span class="n">_BatchedFramesOrientation</span><span class="p">,</span> <span class="nb">dict</span><span class="p">(</span>
                    <span class="nb">type</span><span class="o">=</span><span class="nb">type</span><span class="p">,</span>
                    <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">))),</span>
            <span class="n">auto_refresh</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

<div class="viewcode-block" id="MultiFrameOrientation.initialize">
<a class="viewcode-back" href="../../../../api/gym_jiminy/common/quantities/generic.html#gym_jiminy.common.quantities.generic.MultiFrameOrientation.initialize">[docs]</a>
    <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Check if the quantity is already active</span>
        <span class="n">was_active</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_active</span>

        <span class="c1"># Call base implementation.</span>
        <span class="c1"># The quantity is now considered active at this point.</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">initialize</span><span class="p">()</span>

        <span class="c1"># Force re-initializing shared data if the active set has changed</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">was_active</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">reset</span><span class="p">(</span><span class="n">reset_tracking</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>


<div class="viewcode-block" id="MultiFrameOrientation.refresh">
<a class="viewcode-back" href="../../../../api/gym_jiminy/common/quantities/generic.html#gym_jiminy.common.quantities.generic.MultiFrameOrientation.refresh">[docs]</a>
    <span class="k">def</span> <span class="nf">refresh</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">get</span><span class="p">()[</span><span class="bp">self</span><span class="o">.</span><span class="n">frame_names</span><span class="p">]</span></div>
</div>



<span class="nd">@dataclass</span><span class="p">(</span><span class="n">unsafe_hash</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">_BatchedFramesPosition</span><span class="p">(</span>
        <span class="n">AbstractQuantity</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">]],</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Position vector (X, Y, Z) of all frames involved in quantities relying</span>
<span class="sd">    on it and are active since last reset of computation tracking if shared</span>
<span class="sd">    cache is available, its parent otherwise.</span>

<span class="sd">    It is not supposed to be instantiated manually but use internally by</span>
<span class="sd">    `FramePosition`. See `_BatchedFramesRotationMatrix` documentation.</span>

<span class="sd">    The positions of all frames are exposed to the user as a dictionary whose</span>
<span class="sd">    keys are the individual frame names and/or set of frame names as a tuple.</span>
<span class="sd">    Internally, data are stored in batched 2D contiguous array for efficiency.</span>
<span class="sd">    The first dimension gathers the 3 components (X, Y, Z), while the second</span>
<span class="sd">    one are individual frames with the same ordering as &#39;self.frame_names&#39;.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">env</span><span class="p">:</span> <span class="n">InterfaceJiminyEnv</span><span class="p">,</span>
                 <span class="n">parent</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="s2">&quot;FramePosition&quot;</span><span class="p">,</span> <span class="s2">&quot;MultiFramePosition&quot;</span><span class="p">],</span>
                 <span class="n">mode</span><span class="p">:</span> <span class="n">QuantityEvalMode</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param env: Base or wrapped jiminy environment.</span>
<span class="sd">        :param parent: `FramePosition` or `MultiFramePosition` instance from</span>
<span class="sd">                       which this quantity is a requirement.</span>
<span class="sd">        :param mode: Desired mode of evaluation for this quantity.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Make sure that a suitable parent has been provided</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="p">(</span><span class="n">FramePosition</span><span class="p">,</span> <span class="n">MultiFramePosition</span><span class="p">))</span>

        <span class="c1"># Initialize the ordered list of frame names</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">frame_names</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="p">()</span>

        <span class="c1"># Call base implementation</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">env</span><span class="p">,</span>
            <span class="n">parent</span><span class="p">,</span>
            <span class="n">requirements</span><span class="o">=</span><span class="p">{},</span>
            <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span>
            <span class="n">auto_refresh</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># Define proxy for the position vectors of all frames</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_pos_refs</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Store the position of all frames at once</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_pos_batch</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>

        <span class="c1"># Define proxy for views of the batch storing all translation vectors</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_pos_views</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Mapping from chunks of frame names to individual position views</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_pos_map</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">]],</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Deactivate all cache owners first since only one is tracking frames</span>
        <span class="k">for</span> <span class="n">quantity</span> <span class="ow">in</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="o">.</span><span class="n">owners</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_cache</span> <span class="k">else</span> <span class="p">(</span><span class="bp">self</span><span class="p">,)):</span>
            <span class="n">quantity</span><span class="o">.</span><span class="n">_is_active</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># Call base implementation</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">initialize</span><span class="p">()</span>

        <span class="c1"># Update the frame names based on the cache owners of this quantity</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">frame_names</span><span class="p">,</span> <span class="n">frame_slices</span> <span class="o">=</span> <span class="n">aggregate_frame_names</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="c1"># Re-allocate memory as the number of frames is not known in advance</span>
        <span class="n">nframes</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">frame_names</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_pos_batch</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">nframes</span><span class="p">),</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span>

        <span class="c1"># Refresh proxies</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_pos_views</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_pos_refs</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">frame_name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">frame_names</span><span class="p">):</span>
            <span class="n">frame_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pinocchio_model</span><span class="o">.</span><span class="n">getFrameId</span><span class="p">(</span><span class="n">frame_name</span><span class="p">)</span>
            <span class="n">translation</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pinocchio_data</span><span class="o">.</span><span class="n">oMf</span><span class="p">[</span><span class="n">frame_index</span><span class="p">]</span><span class="o">.</span><span class="n">translation</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_pos_views</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_pos_batch</span><span class="p">[:,</span> <span class="n">i</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_pos_refs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">translation</span><span class="p">)</span>

        <span class="c1"># Re-assign mapping from frame names to their corresponding data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_pos_map</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">key</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pos_batch</span><span class="p">[:,</span> <span class="n">frame_slice</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">frame_slice</span> <span class="ow">in</span> <span class="n">frame_slices</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>

    <span class="k">def</span> <span class="nf">refresh</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">]],</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
        <span class="c1"># Copy all translations in contiguous buffer</span>
        <span class="n">multi_array_copyto</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_pos_views</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pos_refs</span><span class="p">)</span>

        <span class="c1"># Return proxy directly without copy</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pos_map</span>


<div class="viewcode-block" id="FramePosition">
<a class="viewcode-back" href="../../../../api/gym_jiminy/common/quantities/generic.html#gym_jiminy.common.quantities.generic.FramePosition">[docs]</a>
<span class="nd">@dataclass</span><span class="p">(</span><span class="n">unsafe_hash</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">FramePosition</span><span class="p">(</span><span class="n">InterfaceQuantity</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Position vector (X, Y, Z) of a given frame in world reference frame at</span>
<span class="sd">    the end of the agent step.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">frame_name</span><span class="p">:</span> <span class="nb">str</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Name of the frame on which to operate.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">mode</span><span class="p">:</span> <span class="n">QuantityEvalMode</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Specify on which state to evaluate this quantity. See `QuantityEvalMode`</span>
<span class="sd">    documentation for details about each mode.</span>

<span class="sd">    .. warning::</span>
<span class="sd">        Mode `REFERENCE` requires a reference trajectory to be selected</span>
<span class="sd">        manually prior to evaluating this quantity for the first time.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">env</span><span class="p">:</span> <span class="n">InterfaceJiminyEnv</span><span class="p">,</span>
                 <span class="n">parent</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">InterfaceQuantity</span><span class="p">],</span>
                 <span class="n">frame_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
                 <span class="o">*</span><span class="p">,</span>
                 <span class="n">mode</span><span class="p">:</span> <span class="n">QuantityEvalMode</span> <span class="o">=</span> <span class="n">QuantityEvalMode</span><span class="o">.</span><span class="n">TRUE</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param env: Base or wrapped jiminy environment.</span>
<span class="sd">        :param parent: Higher-level quantity from which this quantity is a</span>
<span class="sd">                       requirement if any, `None` otherwise.</span>
<span class="sd">        :param frame_name: Name of the frame on which to operate.</span>
<span class="sd">        :param mode: Desired mode of evaluation for this quantity.</span>
<span class="sd">                     Optional: &#39;QuantityEvalMode.TRUE&#39; by default.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Backup some user argument(s)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">frame_name</span> <span class="o">=</span> <span class="n">frame_name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="o">=</span> <span class="n">mode</span>

        <span class="c1"># Call base implementation</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">env</span><span class="p">,</span>
            <span class="n">parent</span><span class="p">,</span>
            <span class="n">requirements</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span>
                <span class="n">data</span><span class="o">=</span><span class="p">(</span><span class="n">_BatchedFramesPosition</span><span class="p">,</span> <span class="nb">dict</span><span class="p">(</span><span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">))),</span>
            <span class="n">auto_refresh</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

<div class="viewcode-block" id="FramePosition.initialize">
<a class="viewcode-back" href="../../../../api/gym_jiminy/common/quantities/generic.html#gym_jiminy.common.quantities.generic.FramePosition.initialize">[docs]</a>
    <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Check if the quantity is already active</span>
        <span class="n">was_active</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_active</span>

        <span class="c1"># Call base implementation</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">initialize</span><span class="p">()</span>

        <span class="c1"># Force re-initializing shared data if the active set has changed</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">was_active</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">reset</span><span class="p">(</span><span class="n">reset_tracking</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>


<div class="viewcode-block" id="FramePosition.refresh">
<a class="viewcode-back" href="../../../../api/gym_jiminy/common/quantities/generic.html#gym_jiminy.common.quantities.generic.FramePosition.refresh">[docs]</a>
    <span class="k">def</span> <span class="nf">refresh</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">get</span><span class="p">()[</span><span class="bp">self</span><span class="o">.</span><span class="n">frame_name</span><span class="p">]</span></div>
</div>



<div class="viewcode-block" id="MultiFramePosition">
<a class="viewcode-back" href="../../../../api/gym_jiminy/common/quantities/generic.html#gym_jiminy.common.quantities.generic.MultiFramePosition">[docs]</a>
<span class="nd">@dataclass</span><span class="p">(</span><span class="n">unsafe_hash</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">MultiFramePosition</span><span class="p">(</span><span class="n">InterfaceQuantity</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Position vector (X, Y, Z) of a given set of frames in world reference</span>
<span class="sd">    frame at the end of the agent step.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">frame_names</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Name of the frames on which to operate.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">mode</span><span class="p">:</span> <span class="n">QuantityEvalMode</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Specify on which state to evaluate this quantity. See `QuantityEvalMode`</span>
<span class="sd">    documentation for details about each mode.</span>

<span class="sd">    .. warning::</span>
<span class="sd">        Mode `REFERENCE` requires a reference trajectory to be selected</span>
<span class="sd">        manually prior to evaluating this quantity for the first time.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">env</span><span class="p">:</span> <span class="n">InterfaceJiminyEnv</span><span class="p">,</span>
                 <span class="n">parent</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">InterfaceQuantity</span><span class="p">],</span>
                 <span class="n">frame_names</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
                 <span class="o">*</span><span class="p">,</span>
                 <span class="n">mode</span><span class="p">:</span> <span class="n">QuantityEvalMode</span> <span class="o">=</span> <span class="n">QuantityEvalMode</span><span class="o">.</span><span class="n">TRUE</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param env: Base or wrapped jiminy environment.</span>
<span class="sd">        :param parent: Higher-level quantity from which this quantity is a</span>
<span class="sd">                       requirement if any, `None` otherwise.</span>
<span class="sd">        :param frame_name: Name of the frames on which to operate.</span>
<span class="sd">        :param mode: Desired mode of evaluation for this quantity.</span>
<span class="sd">                     Optional: &#39;QuantityEvalMode.TRUE&#39; by default.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Make sure that the user did not pass a single frame name</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">frame_names</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>

        <span class="c1"># Backup some user argument(s)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">frame_names</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">frame_names</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="o">=</span> <span class="n">mode</span>

        <span class="c1"># Call base implementation</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">env</span><span class="p">,</span>
            <span class="n">parent</span><span class="p">,</span>
            <span class="n">requirements</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span>
                <span class="n">data</span><span class="o">=</span><span class="p">(</span><span class="n">_BatchedFramesPosition</span><span class="p">,</span> <span class="nb">dict</span><span class="p">(</span><span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">))),</span>
            <span class="n">auto_refresh</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

<div class="viewcode-block" id="MultiFramePosition.initialize">
<a class="viewcode-back" href="../../../../api/gym_jiminy/common/quantities/generic.html#gym_jiminy.common.quantities.generic.MultiFramePosition.initialize">[docs]</a>
    <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Check if the quantity is already active</span>
        <span class="n">was_active</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_active</span>

        <span class="c1"># Call base implementation</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">initialize</span><span class="p">()</span>

        <span class="c1"># Force re-initializing shared data if the active set has changed</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">was_active</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">reset</span><span class="p">(</span><span class="n">reset_tracking</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>


<div class="viewcode-block" id="MultiFramePosition.refresh">
<a class="viewcode-back" href="../../../../api/gym_jiminy/common/quantities/generic.html#gym_jiminy.common.quantities.generic.MultiFramePosition.refresh">[docs]</a>
    <span class="k">def</span> <span class="nf">refresh</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">get</span><span class="p">()[</span><span class="bp">self</span><span class="o">.</span><span class="n">frame_names</span><span class="p">]</span></div>
</div>



<div class="viewcode-block" id="FrameXYZQuat">
<a class="viewcode-back" href="../../../../api/gym_jiminy/common/quantities/generic.html#gym_jiminy.common.quantities.generic.FrameXYZQuat">[docs]</a>
<span class="nd">@dataclass</span><span class="p">(</span><span class="n">unsafe_hash</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">FrameXYZQuat</span><span class="p">(</span><span class="n">InterfaceQuantity</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Spatial vector representation (X, Y, Z, QuatX, QuatY, QuatZ, QuatW) of</span>
<span class="sd">    the transform of a given frame in world reference frame at the end of the</span>
<span class="sd">    agent step.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">frame_name</span><span class="p">:</span> <span class="nb">str</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Name of the frame on which to operate.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">mode</span><span class="p">:</span> <span class="n">QuantityEvalMode</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Specify on which state to evaluate this quantity. See `QuantityEvalMode`</span>
<span class="sd">    documentation for details about each mode.</span>

<span class="sd">    .. warning::</span>
<span class="sd">        Mode `REFERENCE` requires a reference trajectory to be selected</span>
<span class="sd">        manually prior to evaluating this quantity for the first time.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">env</span><span class="p">:</span> <span class="n">InterfaceJiminyEnv</span><span class="p">,</span>
                 <span class="n">parent</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">InterfaceQuantity</span><span class="p">],</span>
                 <span class="n">frame_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
                 <span class="o">*</span><span class="p">,</span>
                 <span class="n">mode</span><span class="p">:</span> <span class="n">QuantityEvalMode</span> <span class="o">=</span> <span class="n">QuantityEvalMode</span><span class="o">.</span><span class="n">TRUE</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param env: Base or wrapped jiminy environment.</span>
<span class="sd">        :param parent: Higher-level quantity from which this quantity is a</span>
<span class="sd">                       requirement if any, `None` otherwise.</span>
<span class="sd">        :param frame_name: Name of the frame on which to operate.</span>
<span class="sd">        :param mode: Desired mode of evaluation for this quantity.</span>
<span class="sd">                     Optional: &#39;QuantityEvalMode.TRUE&#39; by default.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Backup some user argument(s)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">frame_name</span> <span class="o">=</span> <span class="n">frame_name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="o">=</span> <span class="n">mode</span>

        <span class="c1"># Call base implementation</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">env</span><span class="p">,</span>
            <span class="n">parent</span><span class="p">,</span>
            <span class="n">requirements</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span>
                <span class="n">position</span><span class="o">=</span><span class="p">(</span><span class="n">FramePosition</span><span class="p">,</span> <span class="nb">dict</span><span class="p">(</span>
                    <span class="n">frame_name</span><span class="o">=</span><span class="n">frame_name</span><span class="p">,</span>
                    <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">)),</span>
                <span class="n">quat</span><span class="o">=</span><span class="p">(</span><span class="n">FrameOrientation</span><span class="p">,</span> <span class="nb">dict</span><span class="p">(</span>
                    <span class="n">frame_name</span><span class="o">=</span><span class="n">frame_name</span><span class="p">,</span>
                    <span class="nb">type</span><span class="o">=</span><span class="n">OrientationType</span><span class="o">.</span><span class="n">QUATERNION</span><span class="p">,</span>
                    <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">))),</span>
            <span class="n">auto_refresh</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># Pre-allocate memory for storing the pose XYZQuat of all frames</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_xyzquat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">7</span><span class="p">,))</span>

        <span class="c1"># Define position and orientation memory views for fast assignment</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_xyzquat_views</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_xyzquat</span><span class="p">[:</span><span class="mi">3</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xyzquat</span><span class="p">[</span><span class="o">-</span><span class="mi">4</span><span class="p">:])</span>

<div class="viewcode-block" id="FrameXYZQuat.refresh">
<a class="viewcode-back" href="../../../../api/gym_jiminy/common/quantities/generic.html#gym_jiminy.common.quantities.generic.FrameXYZQuat.refresh">[docs]</a>
    <span class="k">def</span> <span class="nf">refresh</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="c1"># Compute the position and orientation of all frames at once</span>
        <span class="n">xyz_quat</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">position</span><span class="o">.</span><span class="n">get</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">quat</span><span class="o">.</span><span class="n">get</span><span class="p">())</span>

        <span class="c1"># Copy data in contiguous buffer</span>
        <span class="n">multi_array_copyto</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_xyzquat_views</span><span class="p">,</span> <span class="n">xyz_quat</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xyzquat</span></div>
</div>



<div class="viewcode-block" id="MultiFrameXYZQuat">
<a class="viewcode-back" href="../../../../api/gym_jiminy/common/quantities/generic.html#gym_jiminy.common.quantities.generic.MultiFrameXYZQuat">[docs]</a>
<span class="nd">@dataclass</span><span class="p">(</span><span class="n">unsafe_hash</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">MultiFrameXYZQuat</span><span class="p">(</span><span class="n">InterfaceQuantity</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Spatial vector representation (X, Y, Z, QuatX, QuatY, QuatZ, QuatW) of</span>
<span class="sd">    the transform of a given set of frames in world reference frame at the end</span>
<span class="sd">    of the agent step.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">frame_names</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Name of the frames on which to operate.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">mode</span><span class="p">:</span> <span class="n">QuantityEvalMode</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Specify on which state to evaluate this quantity. See `QuantityEvalMode`</span>
<span class="sd">    documentation for details about each mode.</span>

<span class="sd">    .. warning::</span>
<span class="sd">        Mode `REFERENCE` requires a reference trajectory to be selected</span>
<span class="sd">        manually prior to evaluating this quantity for the first time.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">env</span><span class="p">:</span> <span class="n">InterfaceJiminyEnv</span><span class="p">,</span>
                 <span class="n">parent</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">InterfaceQuantity</span><span class="p">],</span>
                 <span class="n">frame_names</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
                 <span class="o">*</span><span class="p">,</span>
                 <span class="n">mode</span><span class="p">:</span> <span class="n">QuantityEvalMode</span> <span class="o">=</span> <span class="n">QuantityEvalMode</span><span class="o">.</span><span class="n">TRUE</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param env: Base or wrapped jiminy environment.</span>
<span class="sd">        :param parent: Higher-level quantity from which this quantity is a</span>
<span class="sd">                       requirement if any, `None` otherwise.</span>
<span class="sd">        :param frame_name: Name of the frames on which to operate.</span>
<span class="sd">        :param mode: Desired mode of evaluation for this quantity.</span>
<span class="sd">                     Optional: &#39;QuantityEvalMode.TRUE&#39; by default.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Make sure that the user did not pass a single frame name</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">frame_names</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>

        <span class="c1"># Backup some user argument(s)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">frame_names</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">frame_names</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="o">=</span> <span class="n">mode</span>

        <span class="c1"># Call base implementation</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">env</span><span class="p">,</span>
            <span class="n">parent</span><span class="p">,</span>
            <span class="n">requirements</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span>
                <span class="n">positions</span><span class="o">=</span><span class="p">(</span><span class="n">MultiFramePosition</span><span class="p">,</span> <span class="nb">dict</span><span class="p">(</span>
                    <span class="n">frame_names</span><span class="o">=</span><span class="n">frame_names</span><span class="p">,</span>
                    <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">)),</span>
                <span class="n">quats</span><span class="o">=</span><span class="p">(</span><span class="n">MultiFrameOrientation</span><span class="p">,</span> <span class="nb">dict</span><span class="p">(</span>
                    <span class="n">frame_names</span><span class="o">=</span><span class="n">frame_names</span><span class="p">,</span>
                    <span class="nb">type</span><span class="o">=</span><span class="n">OrientationType</span><span class="o">.</span><span class="n">QUATERNION</span><span class="p">,</span>
                    <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">))),</span>
            <span class="n">auto_refresh</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># Pre-allocate memory for storing the pose XYZQuat of all frames</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_xyzquats</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">7</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">frame_names</span><span class="p">)),</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">)</span>

        <span class="c1"># Define position and orientation memory views for fast assignment</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_xyzquats_views</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_xyzquats</span><span class="p">[:</span><span class="mi">3</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xyzquats</span><span class="p">[</span><span class="o">-</span><span class="mi">4</span><span class="p">:])</span>

<div class="viewcode-block" id="MultiFrameXYZQuat.refresh">
<a class="viewcode-back" href="../../../../api/gym_jiminy/common/quantities/generic.html#gym_jiminy.common.quantities.generic.MultiFrameXYZQuat.refresh">[docs]</a>
    <span class="k">def</span> <span class="nf">refresh</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="c1"># Compute the position and orientation of all frames at once</span>
        <span class="n">xyz_quat_batch</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">positions</span><span class="o">.</span><span class="n">get</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">quats</span><span class="o">.</span><span class="n">get</span><span class="p">())</span>

        <span class="c1"># Copy data in contiguous buffer</span>
        <span class="n">multi_array_copyto</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_xyzquats_views</span><span class="p">,</span> <span class="n">xyz_quat_batch</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xyzquats</span></div>
</div>



<div class="viewcode-block" id="position_average">
<a class="viewcode-back" href="../../../../api/gym_jiminy/common/quantities/generic.html#gym_jiminy.common.quantities.generic.position_average">[docs]</a>
<span class="nd">@nb</span><span class="o">.</span><span class="n">jit</span><span class="p">(</span><span class="n">nopython</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">fastmath</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">position_average</span><span class="p">(</span><span class="n">value</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute the mean of an array over its last axis only.</span>

<span class="sd">    :param value: N-dimensional array from which the last axis will be</span>
<span class="sd">                  reduced.</span>
<span class="sd">    :param out: Pre-allocated array in which to store the result.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">out</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">value</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span></div>



<div class="viewcode-block" id="quat_average_2d">
<a class="viewcode-back" href="../../../../api/gym_jiminy/common/quantities/generic.html#gym_jiminy.common.quantities.generic.quat_average_2d">[docs]</a>
<span class="nd">@nb</span><span class="o">.</span><span class="n">jit</span><span class="p">(</span><span class="n">nopython</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">fastmath</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">quat_average_2d</span><span class="p">(</span><span class="n">quat</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute the average of a batch of quaternions [qx, qy, qz, qw].</span>

<span class="sd">    .. note::</span>
<span class="sd">        Jit-able specialization of `quat_average` for 2D matrices, with further</span>
<span class="sd">        optimization for the special case where there is only 2 quaternions.</span>

<span class="sd">    :param quat: N-dimensional (N &gt;= 2) array whose first dimension gathers the</span>
<span class="sd">                 4 quaternion coordinates [qx, qy, qz, qw].</span>
<span class="sd">    :param out: Pre-allocated array in which to store the result.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">num_quats</span> <span class="o">=</span> <span class="n">quat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">num_quats</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">out</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">quat</span>
    <span class="k">elif</span> <span class="n">num_quats</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">quat_interpolate_middle</span><span class="p">(</span><span class="n">quat</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">quat</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">out</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">eigvec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eigh</span><span class="p">(</span><span class="n">quat</span> <span class="o">@</span> <span class="n">quat</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        <span class="n">out</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">eigvec</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span></div>



<div class="viewcode-block" id="MultiFrameMeanXYZQuat">
<a class="viewcode-back" href="../../../../api/gym_jiminy/common/quantities/generic.html#gym_jiminy.common.quantities.generic.MultiFrameMeanXYZQuat">[docs]</a>
<span class="nd">@dataclass</span><span class="p">(</span><span class="n">unsafe_hash</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">MultiFrameMeanXYZQuat</span><span class="p">(</span><span class="n">InterfaceQuantity</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Spatial vector representation (X, Y, Z, QuatX, QuatY, QuatZ, QuatW) of</span>
<span class="sd">    the average transform of a given set of frames in world reference frame at</span>
<span class="sd">    the end of the agent step.</span>

<span class="sd">    Broadly speaking, the average is defined as the value minimizing the mean</span>
<span class="sd">    error wrt every individual elements, considering some distance metric. In</span>
<span class="sd">    this case, the average position (X, Y, Z) and orientation as a quaternion</span>
<span class="sd">    vector (QuatX, QuatY, QuatZ, QuatW) are computed separately (double</span>
<span class="sd">    geodesic). It has the advantage to be much easier to compute, and to</span>
<span class="sd">    decouple the translation from the rotation, which is desirable when</span>
<span class="sd">    defining reward components weighting differently position or orientation</span>
<span class="sd">    errors. See `quaternion_average` for details about the distance metric</span>
<span class="sd">    being used to compute the average orientation.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">frame_names</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Name of the frames on which to operate.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">mode</span><span class="p">:</span> <span class="n">QuantityEvalMode</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Specify on which state to evaluate this quantity. See `QuantityEvalMode`</span>
<span class="sd">    documentation for details about each mode.</span>

<span class="sd">    .. warning::</span>
<span class="sd">        Mode `REFERENCE` requires a reference trajectory to be selected</span>
<span class="sd">        manually prior to evaluating this quantity for the first time.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">env</span><span class="p">:</span> <span class="n">InterfaceJiminyEnv</span><span class="p">,</span>
                 <span class="n">parent</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">InterfaceQuantity</span><span class="p">],</span>
                 <span class="n">frame_names</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
                 <span class="o">*</span><span class="p">,</span>
                 <span class="n">mode</span><span class="p">:</span> <span class="n">QuantityEvalMode</span> <span class="o">=</span> <span class="n">QuantityEvalMode</span><span class="o">.</span><span class="n">TRUE</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param env: Base or wrapped jiminy environment.</span>
<span class="sd">        :param parent: Higher-level quantity from which this quantity is a</span>
<span class="sd">                       requirement if any, `None` otherwise.</span>
<span class="sd">        :param frame_name: Name of the frames on which to operate.</span>
<span class="sd">        :param mode: Desired mode of evaluation for this quantity.</span>
<span class="sd">                     Optional: &#39;QuantityEvalMode.TRUE&#39; by default.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Make sure that the user did not pass a single frame name</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">frame_names</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>

        <span class="c1"># Backup some user argument(s)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">frame_names</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">frame_names</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="o">=</span> <span class="n">mode</span>

        <span class="c1"># Call base implementation</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">env</span><span class="p">,</span>
            <span class="n">parent</span><span class="p">,</span>
            <span class="n">requirements</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span>
                <span class="n">positions</span><span class="o">=</span><span class="p">(</span><span class="n">MultiFramePosition</span><span class="p">,</span> <span class="nb">dict</span><span class="p">(</span>
                    <span class="n">frame_names</span><span class="o">=</span><span class="n">frame_names</span><span class="p">,</span>
                    <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">)),</span>
                <span class="n">quats</span><span class="o">=</span><span class="p">(</span><span class="n">MultiFrameOrientation</span><span class="p">,</span> <span class="nb">dict</span><span class="p">(</span>
                    <span class="n">frame_names</span><span class="o">=</span><span class="n">frame_names</span><span class="p">,</span>
                    <span class="nb">type</span><span class="o">=</span><span class="n">OrientationType</span><span class="o">.</span><span class="n">QUATERNION</span><span class="p">,</span>
                    <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">))),</span>
            <span class="n">auto_refresh</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># Pre-allocate memory for the mean for mean pose vector XYZQuat</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_xyzquat_mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">7</span><span class="p">,))</span>

        <span class="c1"># Define position and orientation proxies for fast access</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_position_mean_view</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xyzquat_mean</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_quat_mean_view</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xyzquat_mean</span><span class="p">[</span><span class="mi">3</span><span class="p">:]</span>

<div class="viewcode-block" id="MultiFrameMeanXYZQuat.refresh">
<a class="viewcode-back" href="../../../../api/gym_jiminy/common/quantities/generic.html#gym_jiminy.common.quantities.generic.MultiFrameMeanXYZQuat.refresh">[docs]</a>
    <span class="k">def</span> <span class="nf">refresh</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="c1"># Compute the mean translation</span>
        <span class="n">position_average</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">positions</span><span class="o">.</span><span class="n">get</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_position_mean_view</span><span class="p">)</span>

        <span class="c1"># Compute the mean quaternion</span>
        <span class="n">quat_average_2d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">quats</span><span class="o">.</span><span class="n">get</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_quat_mean_view</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xyzquat_mean</span></div>
</div>



<div class="viewcode-block" id="MultiFrameCollisionDetection">
<a class="viewcode-back" href="../../../../api/gym_jiminy/common/quantities/generic.html#gym_jiminy.common.quantities.generic.MultiFrameCollisionDetection">[docs]</a>
<span class="nd">@dataclass</span><span class="p">(</span><span class="n">unsafe_hash</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">MultiFrameCollisionDetection</span><span class="p">(</span><span class="n">InterfaceQuantity</span><span class="p">[</span><span class="nb">bool</span><span class="p">]):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Check if some geometry objects are colliding with each other.</span>

<span class="sd">    It takes into account some safety margins by which their volume will be</span>
<span class="sd">    inflated / deflated.</span>

<span class="sd">    .. note::</span>
<span class="sd">        Jiminy enforces all collision geometries to be either primitive shapes</span>
<span class="sd">        or convex polyhedra for efficiency. In practice, if meshes has been</span>
<span class="sd">        specified in the original URDF file, then they will be converted into</span>
<span class="sd">        their respective convex hull.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">frame_names</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Name of the bodies of the robot to consider for collision detection.</span>

<span class="sd">    All the geometry objects sharing with them the same parent joint will be</span>
<span class="sd">    taking into account.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">security_margin</span><span class="p">:</span> <span class="nb">float</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Signed distance below which a pair of geometry objects is stated in</span>
<span class="sd">    collision.</span>

<span class="sd">    This can be interpreted as inflating or deflating the geometry objects by</span>
<span class="sd">    the safety margin depending on whether it is positive or negative</span>
<span class="sd">    respectively. Therefore, the actual geometry objects do no have to be in</span>
<span class="sd">    contact to be stated in collision if the satefy margin is positive. On the</span>
<span class="sd">    contrary, the penetration depth must be large enough if the security margin</span>
<span class="sd">    is positive.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">env</span><span class="p">:</span> <span class="n">InterfaceJiminyEnv</span><span class="p">,</span>
                 <span class="n">parent</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">InterfaceQuantity</span><span class="p">],</span>
                 <span class="n">frame_names</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
                 <span class="o">*</span><span class="p">,</span>
                 <span class="n">security_margin</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param env: Base or wrapped jiminy environment.</span>
<span class="sd">        :param parent: Higher-level quantity from which this quantity is a</span>
<span class="sd">                       requirement if any, `None` otherwise.</span>
<span class="sd">        :param frame_names: Name of the bodies of the robot to consider for</span>
<span class="sd">                            collision detection. All the geometry objects</span>
<span class="sd">                            sharing with them the same parent joint will be</span>
<span class="sd">                            taking into account.</span>
<span class="sd">        :param security_margin: Signed distance below which a pair of geometry</span>
<span class="sd">                                objects is stated in collision.</span>
<span class="sd">                                Optional: 0.0 by default.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Backup some user-arguments</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">frame_names</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">frame_names</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">security_margin</span> <span class="o">=</span> <span class="n">security_margin</span>

        <span class="c1"># Call base implementation</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">env</span><span class="p">,</span>
            <span class="n">parent</span><span class="p">,</span>
            <span class="n">requirements</span><span class="o">=</span><span class="p">{},</span>
            <span class="n">auto_refresh</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># Initialize a broadphase manager for each collision group</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_collision_groups</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">fcl</span><span class="o">.</span><span class="n">DynamicAABBTreeCollisionManager</span><span class="p">()</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">frame_names</span><span class="p">]</span>

        <span class="c1"># Initialize pair-wise collision requests between groups of bodies</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_requests</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span>
            <span class="n">fcl</span><span class="o">.</span><span class="n">BroadPhaseCollisionManager</span><span class="p">,</span>
            <span class="n">fcl</span><span class="o">.</span><span class="n">BroadPhaseCollisionManager</span><span class="p">,</span>
            <span class="n">fcl</span><span class="o">.</span><span class="n">CollisionCallBackBase</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">frame_names</span><span class="p">)):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">frame_names</span><span class="p">)):</span>
                <span class="n">manager_1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_collision_groups</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">manager_2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_collision_groups</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="n">callback</span> <span class="o">=</span> <span class="n">fcl</span><span class="o">.</span><span class="n">CollisionCallBackDefault</span><span class="p">()</span>
                <span class="n">request</span><span class="p">:</span> <span class="n">fcl</span><span class="o">.</span><span class="n">CollisionRequest</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">callback</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">request</span><span class="p">)</span>  <span class="c1"># pylint: disable=no-member</span>
                <span class="n">request</span><span class="o">.</span><span class="n">gjk_initial_guess</span> <span class="o">=</span> <span class="n">jiminy</span><span class="o">.</span><span class="n">GJKInitialGuess</span><span class="o">.</span><span class="n">CachedGuess</span>
                <span class="c1"># request.gjk_variant = fcl.GJKVariant.NesterovAcceleration</span>
                <span class="c1"># request.break_distance = 0.1</span>
                <span class="n">request</span><span class="o">.</span><span class="n">gjk_tolerance</span> <span class="o">=</span> <span class="mf">1e-6</span>
                <span class="n">request</span><span class="o">.</span><span class="n">distance_upper_bound</span> <span class="o">=</span> <span class="mf">1e-6</span>
                <span class="n">request</span><span class="o">.</span><span class="n">num_max_contacts</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="n">request</span><span class="o">.</span><span class="n">security_margin</span> <span class="o">=</span> <span class="n">security_margin</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_requests</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">manager_1</span><span class="p">,</span> <span class="n">manager_2</span><span class="p">,</span> <span class="n">callback</span><span class="p">))</span>

        <span class="c1"># Store callable responsible to updating transform of colision objects</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_transform_updates</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Callable</span><span class="p">[[],</span> <span class="kc">None</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[]</span>

<div class="viewcode-block" id="MultiFrameCollisionDetection.initialize">
<a class="viewcode-back" href="../../../../api/gym_jiminy/common/quantities/generic.html#gym_jiminy.common.quantities.generic.MultiFrameCollisionDetection.initialize">[docs]</a>
    <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Call base implementation</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">initialize</span><span class="p">()</span>

        <span class="c1"># Define robot proxy for convenience</span>
        <span class="n">robot</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">robot</span>

        <span class="c1"># Clear all collision managers</span>
        <span class="k">for</span> <span class="n">manager</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_collision_groups</span><span class="p">:</span>
            <span class="n">manager</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>

        <span class="c1"># Get the list of parent joint indices mapping</span>
        <span class="n">frame_indices_map</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">frame_name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">frame_names</span><span class="p">):</span>
            <span class="n">frame_index</span> <span class="o">=</span> <span class="n">robot</span><span class="o">.</span><span class="n">pinocchio_model</span><span class="o">.</span><span class="n">getFrameId</span><span class="p">(</span><span class="n">frame_name</span><span class="p">)</span>
            <span class="n">frame</span> <span class="o">=</span> <span class="n">robot</span><span class="o">.</span><span class="n">pinocchio_model</span><span class="o">.</span><span class="n">frames</span><span class="p">[</span><span class="n">frame_index</span><span class="p">]</span>
            <span class="n">frame_indices_map</span><span class="p">[</span><span class="n">frame</span><span class="o">.</span><span class="n">parent</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>

        <span class="c1"># Add collision objects to their corresponding manager</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_transform_updates</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">geom</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">robot</span><span class="o">.</span><span class="n">collision_model</span><span class="o">.</span><span class="n">geometryObjects</span><span class="p">):</span>
            <span class="n">j</span> <span class="o">=</span> <span class="n">frame_indices_map</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">geom</span><span class="o">.</span><span class="n">parentJoint</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">j</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">obj</span> <span class="o">=</span> <span class="n">fcl</span><span class="o">.</span><span class="n">CollisionObject</span><span class="p">(</span><span class="n">geom</span><span class="o">.</span><span class="n">geometry</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_collision_groups</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">registerObject</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
                <span class="n">pose</span> <span class="o">=</span> <span class="n">robot</span><span class="o">.</span><span class="n">collision_data</span><span class="o">.</span><span class="n">oMg</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">translation</span><span class="p">,</span> <span class="n">rotation</span> <span class="o">=</span> <span class="n">pose</span><span class="o">.</span><span class="n">translation</span><span class="p">,</span> <span class="n">pose</span><span class="o">.</span><span class="n">rotation</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_transform_updates</span> <span class="o">+=</span> <span class="p">(</span>
                    <span class="n">partial</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">setTranslation</span><span class="p">,</span> <span class="n">translation</span><span class="p">),</span>
                    <span class="n">partial</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">setRotation</span><span class="p">,</span> <span class="n">rotation</span><span class="p">))</span>

        <span class="c1"># Initialize collision detection facilities</span>
        <span class="k">for</span> <span class="n">manager</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_collision_groups</span><span class="p">:</span>
            <span class="n">manager</span><span class="o">.</span><span class="n">setup</span><span class="p">()</span></div>


<div class="viewcode-block" id="MultiFrameCollisionDetection.refresh">
<a class="viewcode-back" href="../../../../api/gym_jiminy/common/quantities/generic.html#gym_jiminy.common.quantities.generic.MultiFrameCollisionDetection.refresh">[docs]</a>
    <span class="k">def</span> <span class="nf">refresh</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="c1"># Update collision object placement</span>
        <span class="k">for</span> <span class="n">transform_update</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transform_updates</span><span class="p">:</span>
            <span class="n">transform_update</span><span class="p">()</span>

        <span class="c1"># Update all collision managers</span>
        <span class="c1"># for manager in self._collision_groups:</span>
        <span class="c1">#     manager.update()</span>

        <span class="c1"># Check collision for all candidate pairs</span>
        <span class="k">for</span> <span class="n">manager_1</span><span class="p">,</span> <span class="n">manager_2</span><span class="p">,</span> <span class="n">callback</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_requests</span><span class="p">:</span>
            <span class="n">manager_1</span><span class="o">.</span><span class="n">collide</span><span class="p">(</span><span class="n">manager_2</span><span class="p">,</span> <span class="n">callback</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">callback</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">result</span><span class="o">.</span><span class="n">isCollision</span><span class="p">():</span>
                <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">False</span></div>
</div>



<span class="nd">@dataclass</span><span class="p">(</span><span class="n">unsafe_hash</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">_DifferenceFrameXYZQuat</span><span class="p">(</span><span class="n">InterfaceQuantity</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Motion vector representation (VX, VY, VZ, WX, WY, WZ) of the finite</span>
<span class="sd">    difference between the pose of a given frame at the end of previous and</span>
<span class="sd">    current agent steps.</span>

<span class="sd">    The finite difference is defined here as the geodesic distance in SE3 Lie</span>
<span class="sd">    Group. Under this definition, the rate of change of the translation depends</span>
<span class="sd">    on rate of change of the orientation of the frame, which may be undesirable</span>
<span class="sd">    in some cases. Alternatively, the double geodesic distance could be used</span>
<span class="sd">    instead to completely decouple the position from the orientation.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">frame_name</span><span class="p">:</span> <span class="nb">str</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Name of the frame on which to operate.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">mode</span><span class="p">:</span> <span class="n">QuantityEvalMode</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Specify on which state to evaluate this quantity. See `QuantityEvalMode`</span>
<span class="sd">    documentation for details about each mode.</span>

<span class="sd">    .. warning::</span>
<span class="sd">        Mode `REFERENCE` requires a reference trajectory to be selected</span>
<span class="sd">        manually prior to evaluating this quantity for the first time.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">env</span><span class="p">:</span> <span class="n">InterfaceJiminyEnv</span><span class="p">,</span>
                 <span class="n">parent</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">InterfaceQuantity</span><span class="p">],</span>
                 <span class="n">frame_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
                 <span class="o">*</span><span class="p">,</span>
                 <span class="n">mode</span><span class="p">:</span> <span class="n">QuantityEvalMode</span> <span class="o">=</span> <span class="n">QuantityEvalMode</span><span class="o">.</span><span class="n">TRUE</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param env: Base or wrapped jiminy environment.</span>
<span class="sd">        :param parent: Higher-level quantity from which this quantity is a</span>
<span class="sd">                       requirement if any, `None` otherwise.</span>
<span class="sd">        :param frame_name: Name of the frame on which to operate.</span>
<span class="sd">        :param reference_frame:</span>
<span class="sd">            Whether the spatial velocity must be computed in local reference</span>
<span class="sd">            frame (aka &#39;pin.LOCAL&#39;) or re-aligned with world axes (aka</span>
<span class="sd">            &#39;pin.LOCAL_WORLD_ALIGNED&#39;).</span>
<span class="sd">            Optional: &#39;pinocchio.ReferenceFrame.LOCAL&#39; by default.</span>
<span class="sd">        :param mode: Desired mode of evaluation for this quantity.</span>
<span class="sd">                     Optional: &#39;QuantityEvalMode.TRUE&#39; by default.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Backup some user argument(s)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">frame_name</span> <span class="o">=</span> <span class="n">frame_name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="o">=</span> <span class="n">mode</span>

        <span class="c1"># Call base implementation</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">env</span><span class="p">,</span>
            <span class="n">parent</span><span class="p">,</span>
            <span class="n">requirements</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span>
                <span class="n">xyzquat_stack</span><span class="o">=</span><span class="p">(</span><span class="n">StackedQuantity</span><span class="p">,</span> <span class="nb">dict</span><span class="p">(</span>
                    <span class="n">quantity</span><span class="o">=</span><span class="p">(</span><span class="n">FrameXYZQuat</span><span class="p">,</span> <span class="nb">dict</span><span class="p">(</span>
                        <span class="n">frame_name</span><span class="o">=</span><span class="n">frame_name</span><span class="p">,</span>
                        <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">)),</span>
                    <span class="n">max_stack</span><span class="o">=</span><span class="mi">2</span><span class="p">))),</span>
            <span class="n">auto_refresh</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># Define specialize difference operator on SE3 Lie group</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_difference</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">pin</span><span class="o">.</span><span class="n">liegroups</span><span class="o">.</span><span class="n">SE3</span><span class="p">()</span><span class="o">.</span><span class="n">difference</span><span class="p">)</span>  <span class="c1"># pylint: disable=no-member</span>

        <span class="c1"># Pre-allocate memory to store the pose difference</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">refresh</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="c1"># Fetch previous and current XYZQuat representation of frame transform.</span>
        <span class="c1"># It will raise an exception if not enough data is available at this</span>
        <span class="c1"># point. This should never occur in practice as it will be fine at</span>
        <span class="c1"># the end of the first step already, before the reward and termination</span>
        <span class="c1"># conditions are evaluated.</span>
        <span class="n">xyzquat_prev</span><span class="p">,</span> <span class="n">xyzquat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xyzquat_stack</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>

        <span class="c1"># Compute average frame velocity in local frame since previous step</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_difference</span><span class="p">(</span><span class="n">xyzquat_prev</span><span class="p">,</span> <span class="n">xyzquat</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span>


<div class="viewcode-block" id="AverageFrameXYZQuat">
<a class="viewcode-back" href="../../../../api/gym_jiminy/common/quantities/generic.html#gym_jiminy.common.quantities.generic.AverageFrameXYZQuat">[docs]</a>
<span class="nd">@dataclass</span><span class="p">(</span><span class="n">unsafe_hash</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">AverageFrameXYZQuat</span><span class="p">(</span><span class="n">InterfaceQuantity</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Spatial vector representation (X, Y, Z, QuatX, QuatY, QuatZ, QuatW) of</span>
<span class="sd">    the midpoint pose of a given frame over the whole agent step.</span>

<span class="sd">    The midpoint frame pose is obtained by integration of the average velocity</span>
<span class="sd">    over the whole agent step, backward in time from the state at the end of</span>
<span class="sd">    the step to the midpoint. See `_DifferenceFrameXYZQuat` documentation for</span>
<span class="sd">    details.</span>

<span class="sd">    .. note::</span>
<span class="sd">        There is a coupling between the rate of change of the orientation over</span>
<span class="sd">        the agent step and the position of the midpoint. Depending on the</span>
<span class="sd">        application, it may be desirable to decouple the translation from the</span>
<span class="sd">        rotation completely by performing computation on the Cartesian Product</span>
<span class="sd">        of the 3D Euclidean space R3 times the Special Orthogonal Group SO3.</span>
<span class="sd">        The resulting distance metric is referred to as double geodesic and</span>
<span class="sd">        does not correspond to the actual shortest path anymore.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">frame_name</span><span class="p">:</span> <span class="nb">str</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Name of the frame on which to operate.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">mode</span><span class="p">:</span> <span class="n">QuantityEvalMode</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Specify on which state to evaluate this quantity. See `QuantityEvalMode`</span>
<span class="sd">    documentation for details about each mode.</span>

<span class="sd">    .. warning::</span>
<span class="sd">        Mode `REFERENCE` requires a reference trajectory to be selected</span>
<span class="sd">        manually prior to evaluating this quantity for the first time.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">env</span><span class="p">:</span> <span class="n">InterfaceJiminyEnv</span><span class="p">,</span>
                 <span class="n">parent</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">InterfaceQuantity</span><span class="p">],</span>
                 <span class="n">frame_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
                 <span class="o">*</span><span class="p">,</span>
                 <span class="n">mode</span><span class="p">:</span> <span class="n">QuantityEvalMode</span> <span class="o">=</span> <span class="n">QuantityEvalMode</span><span class="o">.</span><span class="n">TRUE</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param env: Base or wrapped jiminy environment.</span>
<span class="sd">        :param parent: Higher-level quantity from which this quantity is a</span>
<span class="sd">                       requirement if any, `None` otherwise.</span>
<span class="sd">        :param frame_name: Name of the frame on which to operate.</span>
<span class="sd">        :param mode: Desired mode of evaluation for this quantity.</span>
<span class="sd">                     Optional: &#39;QuantityEvalMode.TRUE&#39; by default.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Backup some user argument(s)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">frame_name</span> <span class="o">=</span> <span class="n">frame_name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="o">=</span> <span class="n">mode</span>

        <span class="c1"># Call base implementation</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">env</span><span class="p">,</span>
            <span class="n">parent</span><span class="p">,</span>
            <span class="n">requirements</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span>
                <span class="n">xyzquat_next</span><span class="o">=</span><span class="p">(</span><span class="n">FrameXYZQuat</span><span class="p">,</span> <span class="nb">dict</span><span class="p">(</span>
                    <span class="n">frame_name</span><span class="o">=</span><span class="n">frame_name</span><span class="p">,</span>
                    <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">)),</span>
                <span class="n">xyzquat_diff</span><span class="o">=</span><span class="p">(</span><span class="n">_DifferenceFrameXYZQuat</span><span class="p">,</span> <span class="nb">dict</span><span class="p">(</span>
                    <span class="n">frame_name</span><span class="o">=</span><span class="n">frame_name</span><span class="p">,</span>
                    <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">))),</span>
            <span class="n">auto_refresh</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># Define specialize integrate operator on SE3 Lie group</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_integrate</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">pin</span><span class="o">.</span><span class="n">liegroups</span><span class="o">.</span><span class="n">SE3</span><span class="p">()</span><span class="o">.</span><span class="n">integrate</span><span class="p">)</span>  <span class="c1"># pylint: disable=no-member</span>

<div class="viewcode-block" id="AverageFrameXYZQuat.refresh">
<a class="viewcode-back" href="../../../../api/gym_jiminy/common/quantities/generic.html#gym_jiminy.common.quantities.generic.AverageFrameXYZQuat.refresh">[docs]</a>
    <span class="k">def</span> <span class="nf">refresh</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="c1"># Interpolate the average spatial velocity at midpoint</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_integrate</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">xyzquat_next</span><span class="o">.</span><span class="n">get</span><span class="p">(),</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">xyzquat_diff</span><span class="o">.</span><span class="n">get</span><span class="p">())</span></div>
</div>



<div class="viewcode-block" id="AverageFrameRollPitch">
<a class="viewcode-back" href="../../../../api/gym_jiminy/common/quantities/generic.html#gym_jiminy.common.quantities.generic.AverageFrameRollPitch">[docs]</a>
<span class="nd">@dataclass</span><span class="p">(</span><span class="n">unsafe_hash</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">AverageFrameRollPitch</span><span class="p">(</span><span class="n">InterfaceQuantity</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Quaternion representation of the average Yaw-free orientation from the</span>
<span class="sd">    Roll-Pitch-Yaw decomposition of a given frame over the whole agent step.</span>

<span class="sd">    .. seealso::</span>
<span class="sd">        See `remove_yaw_from_quat` and `AverageFrameXYZQuat` for details about</span>
<span class="sd">        the Roll-Pitch-Yaw decomposition and how the average frame pose is</span>
<span class="sd">        defined respectively.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">frame_name</span><span class="p">:</span> <span class="nb">str</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Name of the frame on which to operate.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">mode</span><span class="p">:</span> <span class="n">QuantityEvalMode</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Specify on which state to evaluate this quantity. See `QuantityEvalMode`</span>
<span class="sd">    documentation for details about each mode.</span>

<span class="sd">    .. warning::</span>
<span class="sd">        Mode `REFERENCE` requires a reference trajectory to be selected</span>
<span class="sd">        manually prior to evaluating this quantity for the first time.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">env</span><span class="p">:</span> <span class="n">InterfaceJiminyEnv</span><span class="p">,</span>
                 <span class="n">parent</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">InterfaceQuantity</span><span class="p">],</span>
                 <span class="n">frame_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
                 <span class="o">*</span><span class="p">,</span>
                 <span class="n">mode</span><span class="p">:</span> <span class="n">QuantityEvalMode</span> <span class="o">=</span> <span class="n">QuantityEvalMode</span><span class="o">.</span><span class="n">TRUE</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param env: Base or wrapped jiminy environment.</span>
<span class="sd">        :param parent: Higher-level quantity from which this quantity is a</span>
<span class="sd">                       requirement if any, `None` otherwise.</span>
<span class="sd">        :param frame_name: Name of the frame on which to operate.</span>
<span class="sd">        :param mode: Desired mode of evaluation for this quantity.</span>
<span class="sd">                     Optional: &#39;QuantityEvalMode.TRUE&#39; by default.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Backup some user argument(s)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">frame_name</span> <span class="o">=</span> <span class="n">frame_name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="o">=</span> <span class="n">mode</span>

        <span class="c1"># Call base implementation</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">env</span><span class="p">,</span>
            <span class="n">parent</span><span class="p">,</span>
            <span class="n">requirements</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span>
                <span class="n">quat_mean</span><span class="o">=</span><span class="p">(</span><span class="n">MaskedQuantity</span><span class="p">,</span> <span class="nb">dict</span><span class="p">(</span>
                    <span class="n">quantity</span><span class="o">=</span><span class="p">(</span><span class="n">AverageFrameXYZQuat</span><span class="p">,</span> <span class="nb">dict</span><span class="p">(</span>
                        <span class="n">frame_name</span><span class="o">=</span><span class="n">frame_name</span><span class="p">,</span>
                        <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">)),</span>
                    <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                    <span class="n">keys</span><span class="o">=</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">)))),</span>
            <span class="n">auto_refresh</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># Twist-free average orientation of the base as a quaternion</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_quat_no_yaw_mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">4</span><span class="p">,))</span>

<div class="viewcode-block" id="AverageFrameRollPitch.refresh">
<a class="viewcode-back" href="../../../../api/gym_jiminy/common/quantities/generic.html#gym_jiminy.common.quantities.generic.AverageFrameRollPitch.refresh">[docs]</a>
    <span class="k">def</span> <span class="nf">refresh</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="c1"># Compute Yaw-free average orientation</span>
        <span class="n">remove_yaw_from_quat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">quat_mean</span><span class="o">.</span><span class="n">get</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_quat_no_yaw_mean</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_quat_no_yaw_mean</span></div>
</div>



<div class="viewcode-block" id="FrameSpatialAverageVelocity">
<a class="viewcode-back" href="../../../../api/gym_jiminy/common/quantities/generic.html#gym_jiminy.common.quantities.generic.FrameSpatialAverageVelocity">[docs]</a>
<span class="nd">@dataclass</span><span class="p">(</span><span class="n">unsafe_hash</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">FrameSpatialAverageVelocity</span><span class="p">(</span><span class="n">InterfaceQuantity</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Average spatial velocity of a given frame at the end of the agent step.</span>

<span class="sd">    The average spatial velocity is obtained by finite difference. More</span>
<span class="sd">    precisely, it is defined here as the ratio of the geodesic distance in SE3</span>
<span class="sd">    Lie Group between the pose of the frame at the end of previous and current</span>
<span class="sd">    step over the time difference between them. Notably, under this definition,</span>
<span class="sd">    the linear average velocity jointly depends on rate of change of the</span>
<span class="sd">    translation and rotation of the frame, which may be undesirable in some</span>
<span class="sd">    cases. Alternatively, the double geodesic distance could be used instead to</span>
<span class="sd">    completely decouple the translation from the rotation.</span>

<span class="sd">    .. note::</span>
<span class="sd">        The local frame for which the velocity is expressed is defined as the</span>
<span class="sd">        midpoint interpolation between the previous and current frame pose.</span>
<span class="sd">        This definition is arbitrary, in a sense that any other point for an</span>
<span class="sd">        interpolation ratio going from 0.0 (previous pose) to 1.0 (current</span>
<span class="sd">        pose) would be equally valid.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">frame_name</span><span class="p">:</span> <span class="nb">str</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Name of the frame on which to operate.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">reference_frame</span><span class="p">:</span> <span class="n">pin</span><span class="o">.</span><span class="n">ReferenceFrame</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Whether the spatial velocity must be computed in local reference frame</span>
<span class="sd">    or re-aligned with world axes.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">mode</span><span class="p">:</span> <span class="n">QuantityEvalMode</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Specify on which state to evaluate this quantity. See `QuantityEvalMode`</span>
<span class="sd">    documentation for details about each mode.</span>

<span class="sd">    .. warning::</span>
<span class="sd">        Mode `REFERENCE` requires a reference trajectory to be selected</span>
<span class="sd">        manually prior to evaluating this quantity for the first time.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">env</span><span class="p">:</span> <span class="n">InterfaceJiminyEnv</span><span class="p">,</span>
                 <span class="n">parent</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">InterfaceQuantity</span><span class="p">],</span>
                 <span class="n">frame_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
                 <span class="o">*</span><span class="p">,</span>
                 <span class="n">reference_frame</span><span class="p">:</span> <span class="n">pin</span><span class="o">.</span><span class="n">ReferenceFrame</span> <span class="o">=</span> <span class="n">pin</span><span class="o">.</span><span class="n">LOCAL</span><span class="p">,</span>
                 <span class="n">mode</span><span class="p">:</span> <span class="n">QuantityEvalMode</span> <span class="o">=</span> <span class="n">QuantityEvalMode</span><span class="o">.</span><span class="n">TRUE</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param env: Base or wrapped jiminy environment.</span>
<span class="sd">        :param parent: Higher-level quantity from which this quantity is a</span>
<span class="sd">                       requirement if any, `None` otherwise.</span>
<span class="sd">        :param frame_name: Name of the frame on which to operate.</span>
<span class="sd">        :param reference_frame:</span>
<span class="sd">            Whether the spatial velocity must be computed in local reference</span>
<span class="sd">            frame (aka &#39;pin.LOCAL&#39;) or re-aligned with world axes (aka</span>
<span class="sd">            &#39;pin.LOCAL_WORLD_ALIGNED&#39;).</span>
<span class="sd">            Optional: &#39;pinocchio.ReferenceFrame.LOCAL&#39; by default.</span>
<span class="sd">        :param mode: Desired mode of evaluation for this quantity.</span>
<span class="sd">                     Optional: &#39;QuantityEvalMode.TRUE&#39; by default.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Make sure at requested reference frame is supported</span>
        <span class="k">if</span> <span class="n">reference_frame</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="n">pin</span><span class="o">.</span><span class="n">LOCAL</span><span class="p">,</span> <span class="n">pin</span><span class="o">.</span><span class="n">LOCAL_WORLD_ALIGNED</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Reference frame must be either &#39;pin.LOCAL&#39; or &quot;</span>
                             <span class="s2">&quot;&#39;pin.LOCAL_WORLD_ALIGNED&#39;.&quot;</span><span class="p">)</span>

        <span class="c1"># Backup some user argument(s)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">frame_name</span> <span class="o">=</span> <span class="n">frame_name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reference_frame</span> <span class="o">=</span> <span class="n">reference_frame</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="o">=</span> <span class="n">mode</span>

        <span class="c1"># Call base implementation</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">env</span><span class="p">,</span>
            <span class="n">parent</span><span class="p">,</span>
            <span class="n">requirements</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span>
                <span class="n">xyzquat_diff</span><span class="o">=</span><span class="p">(</span><span class="n">_DifferenceFrameXYZQuat</span><span class="p">,</span> <span class="nb">dict</span><span class="p">(</span>
                    <span class="n">frame_name</span><span class="o">=</span><span class="n">frame_name</span><span class="p">,</span>
                    <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">)),</span>
                <span class="n">quat_mean</span><span class="o">=</span><span class="p">(</span><span class="n">MaskedQuantity</span><span class="p">,</span> <span class="nb">dict</span><span class="p">(</span>
                    <span class="n">quantity</span><span class="o">=</span><span class="p">(</span><span class="n">AverageFrameXYZQuat</span><span class="p">,</span> <span class="nb">dict</span><span class="p">(</span>
                        <span class="n">frame_name</span><span class="o">=</span><span class="n">frame_name</span><span class="p">,</span>
                        <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">)),</span>
                    <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                    <span class="n">keys</span><span class="o">=</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">)))),</span>
            <span class="n">auto_refresh</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># Inverse time difference from previous to next state</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_inv_step_dt</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">step_dt</span>

        <span class="c1"># Pre-allocate memory for the spatial velocity</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_v_spatial</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>

        <span class="c1"># Reshape linear plus angular velocity vector to vectorize rotation</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_v_lin_ang</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v_spatial</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>

<div class="viewcode-block" id="FrameSpatialAverageVelocity.refresh">
<a class="viewcode-back" href="../../../../api/gym_jiminy/common/quantities/generic.html#gym_jiminy.common.quantities.generic.FrameSpatialAverageVelocity.refresh">[docs]</a>
    <span class="k">def</span> <span class="nf">refresh</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="c1"># Compute average frame velocity in local frame since previous step</span>
        <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">xyzquat_diff</span><span class="o">.</span><span class="n">get</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inv_step_dt</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v_spatial</span><span class="p">)</span>

        <span class="c1"># Translate local velocity to world frame</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">reference_frame</span> <span class="o">==</span> <span class="n">pin</span><span class="o">.</span><span class="n">LOCAL_WORLD_ALIGNED</span><span class="p">:</span>
            <span class="c1"># Define world frame as the &quot;middle&quot; between prev and next pose.</span>
            <span class="c1"># Here, we only care about the middle rotation, so we can consider</span>
            <span class="c1"># SO3 Lie Group algebra instead of SE3.</span>
            <span class="n">quat_apply</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">quat_mean</span><span class="o">.</span><span class="n">get</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v_lin_ang</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v_lin_ang</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v_spatial</span></div>
</div>



<div class="viewcode-block" id="MultiActuatedJointKinematic">
<a class="viewcode-back" href="../../../../api/gym_jiminy/common/quantities/generic.html#gym_jiminy.common.quantities.generic.MultiActuatedJointKinematic">[docs]</a>
<span class="nd">@dataclass</span><span class="p">(</span><span class="n">unsafe_hash</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">MultiActuatedJointKinematic</span><span class="p">(</span><span class="n">AbstractQuantity</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Current position, velocity or acceleration of all the actuated joints</span>
<span class="sd">    of the robot in motor order, before or after the mechanical transmissions.</span>

<span class="sd">    In practice, all actuated joints must be 1DoF for now. In the case of</span>
<span class="sd">    revolute unbounded revolute joints, the principal angle &#39;theta&#39; is used to</span>
<span class="sd">    encode the position, not the polar coordinates `(cos(theta), sin(theta))`.</span>

<span class="sd">    .. warning::</span>
<span class="sd">        Data is extracted from the true configuration vector instead of using</span>
<span class="sd">        sensor data. As a result, this quantity is appropriate for computing</span>
<span class="sd">        reward components and termination conditions but must be avoided in</span>
<span class="sd">        observers and controllers, unless `mode=QuantityEvalMode.REFERENCE`.</span>

<span class="sd">    .. warning::</span>
<span class="sd">        Revolute unbounded joints are not supported for now.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">kinematic_level</span><span class="p">:</span> <span class="n">pin</span><span class="o">.</span><span class="n">KinematicLevel</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Kinematic level to consider, ie position, velocity or acceleration.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">is_motor_side</span><span class="p">:</span> <span class="nb">bool</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Whether the compute kinematic data on motor- or joint-side, ie before or</span>
<span class="sd">    after their respective mechanical transmision.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">env</span><span class="p">:</span> <span class="n">InterfaceJiminyEnv</span><span class="p">,</span>
                 <span class="n">parent</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">InterfaceQuantity</span><span class="p">],</span>
                 <span class="o">*</span><span class="p">,</span>
                 <span class="n">kinematic_level</span><span class="p">:</span> <span class="n">pin</span><span class="o">.</span><span class="n">KinematicLevel</span> <span class="o">=</span> <span class="n">pin</span><span class="o">.</span><span class="n">POSITION</span><span class="p">,</span>
                 <span class="n">is_motor_side</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                 <span class="n">mode</span><span class="p">:</span> <span class="n">QuantityEvalMode</span> <span class="o">=</span> <span class="n">QuantityEvalMode</span><span class="o">.</span><span class="n">TRUE</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param env: Base or wrapped jiminy environment.</span>
<span class="sd">        :param parent: Higher-level quantity from which this quantity is a</span>
<span class="sd">                       requirement if any, `None` otherwise.</span>
<span class="sd">        :param kinematic_level: Desired kinematic level, ie position, velocity</span>
<span class="sd">                                or acceleration.</span>
<span class="sd">        :param is_motor_side: Whether the compute kinematic data on motor- or</span>
<span class="sd">                              joint-side, ie before or after the mechanical</span>
<span class="sd">                              transmisions.</span>
<span class="sd">                              Optional: False by default.</span>
<span class="sd">        :param mode: Desired mode of evaluation for this quantity.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Backup some of the user-arguments</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kinematic_level</span> <span class="o">=</span> <span class="n">kinematic_level</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_motor_side</span> <span class="o">=</span> <span class="n">is_motor_side</span>

        <span class="c1"># Call base implementation</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">env</span><span class="p">,</span>
            <span class="n">parent</span><span class="p">,</span>
            <span class="n">requirements</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span>
                <span class="n">state</span><span class="o">=</span><span class="p">(</span><span class="n">StateQuantity</span><span class="p">,</span> <span class="nb">dict</span><span class="p">(</span>
                    <span class="n">update_kinematics</span><span class="o">=</span><span class="kc">False</span><span class="p">))),</span>
            <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span>
            <span class="n">auto_refresh</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># Mechanical joint position indices.</span>
        <span class="c1"># Note that it will only be used in last resort if it can be written as</span>
        <span class="c1"># a slice. Indeed, &quot;fancy&quot; indexing returns a copy of the original data</span>
        <span class="c1"># instead of a view, which requires fetching data at every refresh.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kinematic_indices</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Keep track of the mechanical reduction ratio for all the motors</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_joint_to_motor_ratios</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>

        <span class="c1"># Buffer storing mechanical joint positions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>

        <span class="c1"># Whether mechanical joint positions must be updated at every refresh</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_must_refresh</span> <span class="o">=</span> <span class="kc">False</span>

<div class="viewcode-block" id="MultiActuatedJointKinematic.initialize">
<a class="viewcode-back" href="../../../../api/gym_jiminy/common/quantities/generic.html#gym_jiminy.common.quantities.generic.MultiActuatedJointKinematic.initialize">[docs]</a>
    <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Call base implementation</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">initialize</span><span class="p">()</span>

        <span class="c1"># Make sure that the state data meet requirements</span>
        <span class="n">state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
        <span class="k">if</span> <span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">kinematic_level</span> <span class="o">==</span> <span class="n">pin</span><span class="o">.</span><span class="n">ACCELERATION</span> <span class="ow">and</span> <span class="n">state</span><span class="o">.</span><span class="n">a</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span>
                <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kinematic_level</span> <span class="o">&gt;=</span> <span class="n">pin</span><span class="o">.</span><span class="n">VELOCITY</span> <span class="ow">and</span> <span class="n">state</span><span class="o">.</span><span class="n">v</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                <span class="s2">&quot;Available state data do not meet requirements for kinematic &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;level &#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">kinematic_level</span><span class="si">}</span><span class="s2">&#39;.&quot;</span><span class="p">)</span>

        <span class="c1"># Refresh mechanical joint position indices and reduction ratio</span>
        <span class="n">joint_to_motor_ratios</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kinematic_indices</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">motor</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">robot</span><span class="o">.</span><span class="n">motors</span><span class="p">:</span>
            <span class="c1"># Note that pinocchio model may be theoretical or extended, which</span>
            <span class="c1"># means that `motor.joint_index` cannot be used reliably.</span>
            <span class="n">joint_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pinocchio_model</span><span class="o">.</span><span class="n">getJointId</span><span class="p">(</span><span class="n">motor</span><span class="o">.</span><span class="n">joint_name</span><span class="p">)</span>
            <span class="n">joint</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pinocchio_model</span><span class="o">.</span><span class="n">joints</span><span class="p">[</span><span class="n">joint_index</span><span class="p">]</span>
            <span class="n">joint_type</span> <span class="o">=</span> <span class="n">jiminy</span><span class="o">.</span><span class="n">get_joint_type</span><span class="p">(</span><span class="n">joint</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">joint_type</span> <span class="o">==</span> <span class="n">jiminy</span><span class="o">.</span><span class="n">JointModelType</span><span class="o">.</span><span class="n">ROTARY_UNBOUNDED</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Revolute unbounded joints are not supported for now.&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">kinematic_level</span> <span class="o">==</span> <span class="n">pin</span><span class="o">.</span><span class="n">KinematicLevel</span><span class="o">.</span><span class="n">POSITION</span><span class="p">:</span>
                <span class="n">kin_first</span><span class="p">,</span> <span class="n">kin_last</span> <span class="o">=</span> <span class="n">joint</span><span class="o">.</span><span class="n">idx_q</span><span class="p">,</span> <span class="n">joint</span><span class="o">.</span><span class="n">idx_q</span> <span class="o">+</span> <span class="n">joint</span><span class="o">.</span><span class="n">nq</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">kin_first</span><span class="p">,</span> <span class="n">kin_last</span> <span class="o">=</span> <span class="n">joint</span><span class="o">.</span><span class="n">idx_v</span><span class="p">,</span> <span class="n">joint</span><span class="o">.</span><span class="n">idx_v</span> <span class="o">+</span> <span class="n">joint</span><span class="o">.</span><span class="n">nv</span>
            <span class="n">motor_options</span> <span class="o">=</span> <span class="n">motor</span><span class="o">.</span><span class="n">get_options</span><span class="p">()</span>
            <span class="n">mechanical_reduction</span> <span class="o">=</span> <span class="n">motor_options</span><span class="p">[</span><span class="s2">&quot;mechanicalReduction&quot;</span><span class="p">]</span>
            <span class="n">joint_to_motor_ratios</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mechanical_reduction</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">kinematic_indices</span> <span class="o">+=</span> <span class="nb">range</span><span class="p">(</span><span class="n">kin_first</span><span class="p">,</span> <span class="n">kin_last</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_joint_to_motor_ratios</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">joint_to_motor_ratios</span><span class="p">)</span>

        <span class="c1"># Determine whether data can be extracted from state by reference</span>
        <span class="n">kin_first</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kinematic_indices</span><span class="p">)</span>
        <span class="n">kin_last</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kinematic_indices</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_must_refresh</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="o">==</span> <span class="n">QuantityEvalMode</span><span class="o">.</span><span class="n">TRUE</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kinematic_indices</span><span class="p">)</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span>
                        <span class="n">kin_first</span><span class="p">,</span> <span class="n">kin_last</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_must_refresh</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">elif</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kinematic_indices</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kinematic_indices</span><span class="p">:</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                        <span class="s2">&quot;Consider using the same ordering for motors and &quot;</span>
                        <span class="s2">&quot;joints for optimal performance.&quot;</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="k">pass</span>

        <span class="c1"># Try extracting mechanical joint positions by reference if possible</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_must_refresh</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kinematic_indices</span><span class="p">),),</span> <span class="nb">float</span><span class="p">(</span><span class="s2">&quot;nan&quot;</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">kinematic_level</span> <span class="o">==</span> <span class="n">pin</span><span class="o">.</span><span class="n">KinematicLevel</span><span class="o">.</span><span class="n">POSITION</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">q</span><span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="n">kin_first</span><span class="p">,</span> <span class="n">kin_last</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">kinematic_level</span> <span class="o">==</span> <span class="n">pin</span><span class="o">.</span><span class="n">KinematicLevel</span><span class="o">.</span><span class="n">VELOCITY</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">v</span><span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="n">kin_first</span><span class="p">,</span> <span class="n">kin_last</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">a</span><span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="n">kin_first</span><span class="p">,</span> <span class="n">kin_last</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span></div>


<div class="viewcode-block" id="MultiActuatedJointKinematic.refresh">
<a class="viewcode-back" href="../../../../api/gym_jiminy/common/quantities/generic.html#gym_jiminy.common.quantities.generic.MultiActuatedJointKinematic.refresh">[docs]</a>
    <span class="k">def</span> <span class="nf">refresh</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="c1"># Update mechanical joint positions only if necessary</span>
        <span class="n">state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_must_refresh</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">kinematic_level</span> <span class="o">==</span> <span class="n">pin</span><span class="o">.</span><span class="n">KinematicLevel</span><span class="o">.</span><span class="n">POSITION</span><span class="p">:</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">q</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">kinematic_level</span> <span class="o">==</span> <span class="n">pin</span><span class="o">.</span><span class="n">KinematicLevel</span><span class="o">.</span><span class="n">VELOCITY</span><span class="p">:</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">v</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">a</span>
            <span class="n">data</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kinematic_indices</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="s2">&quot;clip&quot;</span><span class="p">)</span>

        <span class="c1"># Translate encoder data at joint level</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_motor_side</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="o">*=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_joint_to_motor_ratios</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span></div>
</div>



<div class="viewcode-block" id="EnergyGenerationMode">
<a class="viewcode-back" href="../../../../api/gym_jiminy/common/quantities/generic.html#gym_jiminy.common.quantities.generic.EnergyGenerationMode">[docs]</a>
<span class="k">class</span> <span class="nc">EnergyGenerationMode</span><span class="p">(</span><span class="n">IntEnum</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Specify what happens to the energy generated by motors when breaking.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">CHARGE</span> <span class="o">=</span> <span class="mi">0</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;The energy flows back to the battery to charge them without any kind of</span>
<span class="sd">    losses in the process if negative overall.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">LOST_EACH</span> <span class="o">=</span> <span class="mi">1</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;The generated energy by each motor individually is lost by thermal</span>
<span class="sd">    dissipation, without flowing back to the battery nor powering other motors</span>
<span class="sd">    consuming energy if any.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">LOST_GLOBAL</span> <span class="o">=</span> <span class="mi">2</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;The energy is lost by thermal dissipation without flowing back to the</span>
<span class="sd">    battery if negative overall.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">PENALIZE</span> <span class="o">=</span> <span class="mi">3</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;The generated energy by each motor individually is treated as consumed.</span>
<span class="sd">    This mode does not really makes sense physically speaking, but may be</span>
<span class="sd">    relevant to penalize energy generation during training as it may damage</span>
<span class="sd">    some hardware that are none designed to handle it.</span>
<span class="sd">    &quot;&quot;&quot;</span></div>



<div class="viewcode-block" id="compute_power">
<a class="viewcode-back" href="../../../../api/gym_jiminy/common/quantities/generic.html#gym_jiminy.common.quantities.generic.compute_power">[docs]</a>
<span class="nd">@nb</span><span class="o">.</span><span class="n">jit</span><span class="p">(</span><span class="n">nopython</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">fastmath</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">compute_power</span><span class="p">(</span><span class="n">generator_mode</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>  <span class="c1"># EnergyGenerationMode</span>
                  <span class="n">motor_velocities</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                  <span class="n">motor_efforts</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute the total instantaneous mechanical power consumption of all</span>
<span class="sd">    motors.</span>

<span class="sd">    :param generator_mode: Specify what happens to the energy generated by</span>
<span class="sd">                           motors when breaking.</span>
<span class="sd">    :param motor_velocities: Velocity of all the motors before transmission as</span>
<span class="sd">                             a 1D array. The order must be consistent with the</span>
<span class="sd">                             motor indices.</span>
<span class="sd">    :param motor_efforts: Effort of all the motors before transmission as a 1D</span>
<span class="sd">                          array. The order must be consistent with the motor</span>
<span class="sd">                          indices.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">generator_mode</span> <span class="ow">in</span> <span class="p">(</span><span class="n">_CHARGE</span><span class="p">,</span> <span class="n">_LOST_GLOBAL</span><span class="p">):</span>
        <span class="n">total_power</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">motor_velocities</span><span class="p">,</span> <span class="n">motor_efforts</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">generator_mode</span> <span class="o">==</span> <span class="n">_CHARGE</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">total_power</span>
        <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="n">total_power</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>
    <span class="n">motor_powers</span> <span class="o">=</span> <span class="n">motor_velocities</span> <span class="o">*</span> <span class="n">motor_efforts</span>
    <span class="k">if</span> <span class="n">generator_mode</span> <span class="o">==</span> <span class="n">_LOST_EACH</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">motor_powers</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">motor_powers</span><span class="p">))</span></div>



<div class="viewcode-block" id="MechanicalPowerConsumption">
<a class="viewcode-back" href="../../../../api/gym_jiminy/common/quantities/generic.html#gym_jiminy.common.quantities.generic.MechanicalPowerConsumption">[docs]</a>
<span class="nd">@dataclass</span><span class="p">(</span><span class="n">unsafe_hash</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">MechanicalPowerConsumption</span><span class="p">(</span><span class="n">InterfaceQuantity</span><span class="p">[</span><span class="nb">float</span><span class="p">]):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Instantaneous power consumption induced by all the motors.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">generator_mode</span><span class="p">:</span> <span class="n">EnergyGenerationMode</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Specify what happens to the energy generated by motors when breaking.</span>
<span class="sd">    See `EnergyGenerationMode` documentation for details.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">mode</span><span class="p">:</span> <span class="n">QuantityEvalMode</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Specify on which state to evaluate this quantity. See `QuantityEvalMode`</span>
<span class="sd">    documentation for details about each mode.</span>

<span class="sd">    .. warning::</span>
<span class="sd">        Mode `REFERENCE` requires a reference trajectory to be selected</span>
<span class="sd">        manually prior to evaluating this quantity for the first time.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">env</span><span class="p">:</span> <span class="n">InterfaceJiminyEnv</span><span class="p">,</span>
            <span class="n">parent</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">InterfaceQuantity</span><span class="p">],</span>
            <span class="o">*</span><span class="p">,</span>
            <span class="n">generator_mode</span><span class="p">:</span> <span class="n">EnergyGenerationMode</span> <span class="o">=</span> <span class="n">EnergyGenerationMode</span><span class="o">.</span><span class="n">CHARGE</span><span class="p">,</span>
            <span class="n">mode</span><span class="p">:</span> <span class="n">QuantityEvalMode</span> <span class="o">=</span> <span class="n">QuantityEvalMode</span><span class="o">.</span><span class="n">TRUE</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param env: Base or wrapped jiminy environment.</span>
<span class="sd">        :param parent: Higher-level quantity from which this quantity is a</span>
<span class="sd">                       requirement if any, `None` otherwise.</span>
<span class="sd">        :param generator_mode: Specify what happens to the energy generated by</span>
<span class="sd">                               motors when breaking.</span>
<span class="sd">                               Optional: `EnergyGenerationMode.CHARGE` by</span>
<span class="sd">                               default.</span>
<span class="sd">        :param mode: Desired mode of evaluation for this quantity.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Backup some of the user-arguments</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">generator_mode</span> <span class="o">=</span> <span class="n">generator_mode</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="o">=</span> <span class="n">mode</span>

        <span class="c1"># Call base implementation</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">env</span><span class="p">,</span>
            <span class="n">parent</span><span class="p">,</span>
            <span class="n">requirements</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span>
                <span class="n">data</span><span class="o">=</span><span class="p">(</span><span class="n">BinaryOpQuantity</span><span class="p">,</span> <span class="nb">dict</span><span class="p">(</span>
                    <span class="n">quantity_left</span><span class="o">=</span><span class="p">(</span><span class="n">UnaryOpQuantity</span><span class="p">,</span> <span class="nb">dict</span><span class="p">(</span>
                        <span class="n">quantity</span><span class="o">=</span><span class="p">(</span><span class="n">StateQuantity</span><span class="p">,</span> <span class="nb">dict</span><span class="p">(</span>
                            <span class="n">update_kinematics</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                            <span class="n">mode</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mode</span><span class="p">)),</span>
                        <span class="n">op</span><span class="o">=</span><span class="n">attrgetter</span><span class="p">(</span><span class="s2">&quot;command&quot;</span><span class="p">))),</span>
                    <span class="n">quantity_right</span><span class="o">=</span><span class="p">(</span><span class="n">MultiActuatedJointKinematic</span><span class="p">,</span> <span class="nb">dict</span><span class="p">(</span>
                        <span class="n">kinematic_level</span><span class="o">=</span><span class="n">pin</span><span class="o">.</span><span class="n">KinematicLevel</span><span class="o">.</span><span class="n">VELOCITY</span><span class="p">,</span>
                        <span class="n">is_motor_side</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                        <span class="n">mode</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mode</span><span class="p">)),</span>
                    <span class="n">op</span><span class="o">=</span><span class="n">partial_hashable</span><span class="p">(</span>
                        <span class="n">compute_power</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">generator_mode</span><span class="p">))))),</span>
            <span class="n">auto_refresh</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># Enable direct forwarding (inlining) for efficiency</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="s2">&quot;refresh&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">get</span>

<div class="viewcode-block" id="MechanicalPowerConsumption.refresh">
<a class="viewcode-back" href="../../../../api/gym_jiminy/common/quantities/generic.html#gym_jiminy.common.quantities.generic.MechanicalPowerConsumption.refresh">[docs]</a>
    <span class="k">def</span> <span class="nf">refresh</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">get</span><span class="p">()</span></div>
</div>



<span class="c1"># Define proxies for fast lookup</span>
<span class="n">_CHARGE</span><span class="p">,</span> <span class="n">_LOST_EACH</span><span class="p">,</span> <span class="n">_LOST_GLOBAL</span><span class="p">,</span> <span class="n">_PENALIZE</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">EnergyGenerationMode</span><span class="p">)</span>


<div class="viewcode-block" id="AverageMechanicalPowerConsumption">
<a class="viewcode-back" href="../../../../api/gym_jiminy/common/quantities/generic.html#gym_jiminy.common.quantities.generic.AverageMechanicalPowerConsumption">[docs]</a>
<span class="nd">@dataclass</span><span class="p">(</span><span class="n">unsafe_hash</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">AverageMechanicalPowerConsumption</span><span class="p">(</span><span class="n">InterfaceQuantity</span><span class="p">[</span><span class="nb">float</span><span class="p">]):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Average mechanical power consumption by all the motors over a sliding</span>
<span class="sd">    time window.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">max_stack</span><span class="p">:</span> <span class="nb">int</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Time horizon over which values of the instantaneous power consumption</span>
<span class="sd">    will be stacked for computing the average.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">generator_mode</span><span class="p">:</span> <span class="n">EnergyGenerationMode</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Specify what happens to the energy generated by motors when breaking.</span>
<span class="sd">    See `EnergyGenerationMode` documentation for details.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">mode</span><span class="p">:</span> <span class="n">QuantityEvalMode</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Specify on which state to evaluate this quantity. See `QuantityEvalMode`</span>
<span class="sd">    documentation for details about each mode.</span>

<span class="sd">    .. warning::</span>
<span class="sd">        Mode `REFERENCE` requires a reference trajectory to be selected</span>
<span class="sd">        manually prior to evaluating this quantity for the first time.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">env</span><span class="p">:</span> <span class="n">InterfaceJiminyEnv</span><span class="p">,</span>
            <span class="n">parent</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">InterfaceQuantity</span><span class="p">],</span>
            <span class="o">*</span><span class="p">,</span>
            <span class="n">horizon</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
            <span class="n">generator_mode</span><span class="p">:</span> <span class="n">EnergyGenerationMode</span> <span class="o">=</span> <span class="n">EnergyGenerationMode</span><span class="o">.</span><span class="n">CHARGE</span><span class="p">,</span>
            <span class="n">mode</span><span class="p">:</span> <span class="n">QuantityEvalMode</span> <span class="o">=</span> <span class="n">QuantityEvalMode</span><span class="o">.</span><span class="n">TRUE</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param env: Base or wrapped jiminy environment.</span>
<span class="sd">        :param parent: Higher-level quantity from which this quantity is a</span>
<span class="sd">                       requirement if any, `None` otherwise.</span>
<span class="sd">        :param horizon: Horizon over which values of the quantity will be</span>
<span class="sd">                        stacked before computing the average.</span>
<span class="sd">        :param generator_mode: Specify what happens to the energy generated by</span>
<span class="sd">                               motors when breaking.</span>
<span class="sd">                               Optional: `EnergyGenerationMode.CHARGE` by</span>
<span class="sd">                               default.</span>
<span class="sd">        :param mode: Desired mode of evaluation for this quantity.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Convert horizon in stack length, assuming constant env timestep</span>
        <span class="n">max_stack</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">horizon</span> <span class="o">/</span> <span class="n">env</span><span class="o">.</span><span class="n">step_dt</span><span class="p">)),</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="c1"># Backup some of the user-arguments</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_stack</span> <span class="o">=</span> <span class="n">max_stack</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">generator_mode</span> <span class="o">=</span> <span class="n">generator_mode</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="o">=</span> <span class="n">mode</span>

        <span class="c1"># Call base implementation</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">env</span><span class="p">,</span>
            <span class="n">parent</span><span class="p">,</span>
            <span class="n">requirements</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span>
                <span class="n">total_power_stack</span><span class="o">=</span><span class="p">(</span><span class="n">StackedQuantity</span><span class="p">,</span> <span class="nb">dict</span><span class="p">(</span>
                    <span class="n">quantity</span><span class="o">=</span><span class="p">(</span><span class="n">MechanicalPowerConsumption</span><span class="p">,</span> <span class="nb">dict</span><span class="p">(</span>
                        <span class="n">generator_mode</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">generator_mode</span><span class="p">,</span>
                        <span class="n">mode</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mode</span><span class="p">)),</span>
                    <span class="n">max_stack</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">max_stack</span><span class="p">,</span>
                    <span class="n">is_wrapping</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                    <span class="n">as_array</span><span class="o">=</span><span class="kc">True</span><span class="p">))),</span>
            <span class="n">auto_refresh</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

<div class="viewcode-block" id="AverageMechanicalPowerConsumption.refresh">
<a class="viewcode-back" href="../../../../api/gym_jiminy/common/quantities/generic.html#gym_jiminy.common.quantities.generic.AverageMechanicalPowerConsumption.refresh">[docs]</a>
    <span class="k">def</span> <span class="nf">refresh</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">mean</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">total_power_stack</span><span class="o">.</span><span class="n">get</span><span class="p">())</span></div>
</div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2020, Alexis Duburcq - MIT licence.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>